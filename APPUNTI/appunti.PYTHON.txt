
source ~/.sdkman/bin/sdkman-init.sh
interpreter:
tiv@stiv-GP60-2PE:~$ python
Python 2.7.8 (default, Oct 20 2014, 15:05:19)
[GCC 4.9.1] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> print "Hello World!"
Hello World!



file:
vi test.py
#!/usr/bin/env python
print "Hello World!"
ZZ
chmod +x test.py
./test.py







________________________________________

#--------------- <-- comment line
________________________________________

print "-" * 50       ---------------------   like in vi a command  50a


________________________________________

import           import math            to import module mathg.py
                 print math.e

________________________________________

+ - * /  % (mod)

+= -= *= /=

divmod         returns 2 num: div and also mod
               print "Months = %d Days = %d" % (divmod(days, 30))

<  ... ==  !=    test on num

and  or  not     test on bool


string <--->  num           float(string)    int(string)      give  num  from text
                            str(num)                          gives text from num


________________________________________

,              tuple  / or list
               a , b = 45, 54          a:45   b:54
               a, b = b , a            a <--> b    (switch)

               data = ("Kushal Das", "India", "Python")
               name, country, language = data      name:Kushal Das country:India language:Python

               n.b.  tuple are immutable cannot be added\remove values
                     a tuple of 1 elem is (1,)  not (1)

named tuple    For readability I can give a name xxx to a tuple
               namedtuple('xxx', ...)

               from collections import namedtuple
               Point = namedtuple('Point', ['x', 'y'])
               p = Point(10, y=20) <--- without the above line, here we had an error on undef Point

________________________________________

a = [ 1, 342, 2233423, 'India', 'Fedora']    <--- is a sequence (int and string here)

a[0]                    1
a[-1]                   'Fedora'
a[-2]                   'India'
a[0:-1]                 [1, 342, 2233423, 'India']
a[2:-2]                 [2233423]
a[:-2]                  [1, 342, 2233423]
a[0::2]                 from 0 at step of 2:  [1, 2233423, 'Fedora']
                        a[i:e:s]    from i-nit to e-nd  at s-tep

range(i,e,s)            returns a sequence from i to e-1 at step s
                        ange(1, 5)          [1, 2, 3, 4]
                        range(1, 15, 3)     [1, 4, 7, 10, 13]
                        range(10)           [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


'Fedora' in a           True
'xxxx'   in a           False
if a:                   True is a not empty!

len(a)                  5
for x in a:             to iterate on the sequence


a.append(45)            ...., 45]     n.b.  if b is another list  a.append(b)
                                            [...., [ - ]]    a list in a list
                                            a.extend(b)      insert insted b values
                                                             [...., -, -, -]
a.insert(0, 1)          [1, .....
a.count(45)             1    (number of occurrence of 45 in a)
a.remove('India')
a.pop()                 moves out the last elem
a.pop(i)                moves out the 'i'  elem       pop(0)  the 1st
a.reverse()
a.sort
________________________________________

if:  else:  read_input_text    ( raw_input (...)    waits then returns keyboard input
                 #!/usr/bin/env python
                 number = int(raw_input("Enter an integer: "))
                 if number < 100:                if      :
                     print "smaller"
                 elif number == 100:             elif     :
                     print "is equal:
                 else:                           else      :
                     print "greater"

________________________________________

for:
               sum = 0.0
               for i in range(1, 11):
                   sum += 1.0 / i
________________________________________

while:
               f = float(raw_input("Enter f: "))
               i = int(raw_input("Enter i: "))
               while f <= i:
                   print "INT %d FLOAT %.2f" % (i, f)
                   f = f + 1
________________________________________ else on loops
         while / for :
             print 1
         else:
             print 2
________________________________________ break continue
break / conintue   as usual
________________________________________ List Comprehensions

build a list with a for inside []

>>> a = [1, 2, 3]
>>> [x ** 2 for x in a]
[1, 4, 9]
>>> z = [x + 1 for x in [x ** 2 for x in a]]
>>> z
[2, 5, 10]
________________________________________ for with both index and values
>>> for i, j in enumerate(['a', 'b', 'c']):
...     print i, j
...
0 a
1 b
2 c
________________________________________ zip()  to iterate in parallel on 2 lists
>>> a = ['Pradeepto', 'Kushal']
>>> b = ['OpenSUSE', 'Fedora']
>>> for x, y in zip(a, b):
...     print "%s uses %s" % (x, y)
________________________________________ Set (no duplicates inside)

>>> a = set('abcthabcjwethddda')
>>> a
set(['a', 'c', 'b', 'e', 'd', 'h', 'j', 't', 'w'])

>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # unique letters in a
set(['a', 'r', 'b', 'c', 'd'])
>>> a - b                              # letters in a but not in b
set(['r', 'd', 'b'])
>>> a | b                              # letters in either a or b
set(['a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'])
>>> a & b                              # letters in both a and b
set(['a', 'c'])
>>> a ^ b                              # letters in a or b but not both
set(['r', 'd', 'b', 'm', 'z', 'l'])

To add or pop values from a set

>>> a
set(['a', 'c', 'b', 'e', 'd', 'h', 'j', 'q', 't', 'w'])
>>> a.add('p')
>>> a
set(['a', 'c', 'b', 'e', 'd', 'h', 'j', 'q', 'p', 't', 'w'])


________________________________________ Dictionary (are the associative array)

>>> data = {'kushal':'Fedora', 'kart_':'Debian', 'Jace':'Mac'}
>>> data
{'kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian'}
>>> data['kart_']
'Debian'
---------- add
>>> data['parthan'] = 'Ubuntu'
>>> data
{'kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'}
---------- del
>>> del data['kushal']
>>> data
{'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'
---------- check
>>> 'Soumya' in data
False
---------- dict()     create from 2 tuple of keys and values
>>> dict((('Indian','Delhi'),('Bangladesh','Dhaka')))
{'Indian': 'Delhi', 'Bangladesh': 'Dhaka'}
---------- loop /iteritems()
>>> data
{'Kushal': 'Fedora', 'Jace': 'Mac', 'kart_': 'Debian', 'parthan': 'Ubuntu'}
>>> for x, y in data.iteritems():
...     print "%s uses %s" % (x, y)
---------- add
---------- add

________________________________________Strings

" or '

s = "Here is a line \                  splitted on 2 lines
... splitted in two lines"


s = "Here is a line \n split in two lines"    splitted on 2 lines


s = """ This is a                        3 "   to split on + lines
... multiline string, so you can
... write many lines"""

U = s.upper()
u = s.lower()
s.swapcase()
s.isalnum()            True if represents a num
s.isalpha()            True if only letters
s.split(':')           "Nishant:is:waiting"  --> ['Nishant', 'is', 'waiting']
join                   -".join("GNU/Linux is great".split(" ")) --> 'GNU/Linux-is-great'
strip(chars)           strip any combination of chars (default blanks (\s \n))
                       s = "  abc\n " s.strip() --> 'abc'
find()                 s = "faulty for a reason"   s.find("for") : 7    s.find("fora") : -1
startswith             s.startswith("fa")     True
endswith               s.endswith("reason")   True


n.b.  s = "....."   z = s[::-1]      z is the reverse of s
________________________________________ Functions

def functionname(params):           def .... :
    ....

def sum(a, b):                      args                default arg:  def sum(a , b=-99):
    ...     return a + b

def change(b):                      local var
    a = 90
    print a

def change(b):                      global var
    global a
    a = 90
    print a


print locals()     returns the var that I see in this scope (in a function the local)
print globals()    returns global vars


n.b.  default args are evaluated only ONCE.
      In some cases this can produce unexpected results:

      def f(a, L=[]):
          L.append(a)
          return L

     print f(1)    -->  [1]
     print f(2)    -->  [1, 2]
     print f(3)    -->  [1, 2, 3]

     args, are normally positional:  ...(a,b) means in a call ...(1,2)  a:1 b:2
     but are also 'named', which means I can also call like ...(b=2, a=1)
     so inverting the order, but still it works.


* args     both in a definition:  def f1(...,*args):    def f2(..., **args)
** args    and in a subsequent call to fun:
                      t=(1, 2, 3)            h== {'x': 1, 'y': 2}
                      a=[1,2]                f2(**h)
                      f1(*t)
                      f1(*a)

           I can use *args  **args to pass a list or a hash in 1 shot.


functions are objects in Python, just like everything else.
This means that I can pass a function as 'argument' to another function,
or in the return statement.

                     >>> def apply(func, x, y):   <--- I then can call as applay(add, 2, 1)
                     ...     return func(x, y)         where i.e. def add(x,y):
                                                                      return x+y
                    _______________________________
                   | def outer():
                   | ...     def inner():
                   | ...         print "Inside inner"
                   | ...     return inner
                   |
                   | f = outer()
                   | f() -->  Inside inner
                   |_______________________________
                   |                            Closures: is the scope-envrionment saved
                   | def outer():               for inner functions. The above inner()
                   | ...     x = 1              once passed out, and used, should not anymore
                   | ...     def inner():       have access to the scope of outer() (so here i.e. x var)
                   | ...         print x        but Python allows the during its life, inner()
                   | ...     return inner       still will have a x=1. It's like that outer()
                   |                            has made by constructor for inner
                   | f = outer()                and 'x' has been added to its private var.
                   | f() -->  Inside inner



map(fun, list)                  receives a fun to call for each elem of the list

                                lst = [1, 2, 3, 4, 5]
                                def square(num):
                                    return num * num
                                ...
                                map(square, lst)          [1, 4, 9, 16, 25]


________________________________________  Files

fobj = open("love.txt")    open in read is the default, so I can skip long form
                           fobj = open("love.txt", 'r')
fobj           -->  <open file 'love.txt', mode 'r' at 0xb7f2d968>
fobj.close()


read()              read ALL the file at once         S=fobj.read()
readline()          read 1 line                       l=fobj.readline()
readlines()         read ALL file in a lines array    a=fobj.readlines()


for                 a way to fast write code that read 1 line a time:
                            fobj = open("sample.txt")
                            for line in fobj:
                            ...     print line,


with                'with' takes care of closing the file for me.
                    with open('setup.py') as fobj:
                    ...     for line in fobj:
                    ...             print line,


write              obj = open("ircnicks.txt", 'w')    last open mode is 'a':append
                   fobj.write('powerpork\n')
                   fobj.close()

seek(offset [,pos])     offset:num bytes from pos
                        pos:    0 (default) start of file
                                1 current position (that I reached somehow)
                                2 end of file

                        fobj.seek(5)     # Goto 5th byte
                        fobj.seek(-3, 2) # goto 3rd byte from the end
                        fobj.tell()      # return Long integer with position

________________________________________ argc, argv

as usual, only import sys

#!/usr/bin/env python                          ./argvtest.py Hi there
import sys                                      First value ./argvtest.py
print "First value", sys.argv[0]                All values
print "All values"                              0 ./argvtest.py
for i, x  in enumerate(sys.argv):               1 Hi
    print i, x                                  2 there


               typical code (with also exit fun):
               if __name__ == '__main__':
                   if len(sys.argv) > 1:
                           main(sys.argv[1])
                   else:
                          sys.exit(-1)
                   sys.exit(0)

________________________________________   Exceptions

try:
   .....
except TypeError:         if empty      except:    it catches ANY excp.
   ...
finally:
   ...

raise                     to throw an excp.  I can even catch it myself in the except block:
                          try:
                          ...     raise ValueError("A value error happened.")
                          except ValueError:
                          ...     print "ValueError."


________________________________________  Class

class nameoftheclass(parent_class):       class MyClass(object):
    statement1                            ...     a = 90
    statement2                            ...     b = 88
    statement3


__init__                  the constructor
                          def __init__(self, name, branch, year):
                                       self.name = name
                                       self.branch = branch
                                       self.year = year

del                       to remove an object.
                          It decreases reference count. When it becomes 0
                          the garbage collector will delete that object.


setters / getters         Do not use. Refer directly fields  (get) ob.field / (set) ob.field = v
                          There is control on fields as private/ public / protected
                                     .....

Inheritance               class Person(object):
                                     .....
                          class Student(Person):
                                     .....

Multiple Inheritance      class MyClass(Parentclass1, Parentclass2,...):
                                     .....
________________________________________ Modules

              module name to import = name of Python file without .py           xxx.py  (a file)
              You can find it by accessing the global var __name__
__init__.py   A module xxx instead of a file xxx.py can also be a dir xxx       xxx     (a dir)
              In this case we have a dir xxx with + files .py and 1 special      |__  *.py
              file __init__.py                                                   |__  __init__.py

              usually __init__.py
              is something as:

              from bars import simplebar      <---  if someone makes:
              __all__ = [simplebar, ]                 from mymodule import *
                                                      it's the same as importing only simplebar


import:       import  bars
              .....
              bars.func (10) ...

from bars import simplebar, starbar      this syntax, import select functions only
                                         but it's a bad practice and should be avoided

help()        enter from python shell the interactive help
           1  >modules              I get the list of installed modules
           2  >xxx                  name of module (here xxx) to have doc on the module

              instead of 1+2 I can directly do  help(xxx)   ex help(str) I've ALL the
              list of functions on strings

pip:       it's the package manager for python modules. (Go to the pip part of this document)

yolk       list all the modules installed
           yolk -l

________________________________________ pip


pip:       modules (external) are usually managed by 'pip' which recursively means (pip install python)

           to check if pip is installed:
           python -m pip --version


           sudo apt-get install python-pip

           once pip is installed, you can install modules:
                             sudo pip install yolk
                             sudo pip install --upgrade yolk      # to update
                             sudo pip install -U        yolk      # to update

           I can update pip via pip itself :
             pip install --upgrade pip
             pip install -U        pip

             but it seems replace by the following
                  python2 -m pip install --upgrade pip   # for Python 2
                  python3 -m pip install --upgrade pip   # for Python 3

              ---------------------------------
              ISSUE OF PIP NOT UPGRADING ITSLEF:
              ---------------------------------

              Python.org sites stopped supporting TLS version 1.0 and 1.1, which could be causing
              the chicken-and-egg problem. Try upgrading pip without using pip

                   curl https://bootstrap.pypa.io/get-pip.py | python             #old

                   curl https://bootstrap.pypa.io/pip/2.7/get-pip.py | python     #new
              ---------------------------------

                                        ╰─ pip3.12  install virtualenv
                                        Collecting virtualenv
                                          Downloading virtualenv-20.26.5-py3-none-any.whl.metadata (4.5 kB)
                                        Collecting distlib<1,>=0.3.7 (from virtualenv)
                                          Downloading distlib-0.3.8-py2.py3-none-any.whl.metadata (5.1 kB)
                                        Collecting filelock<4,>=3.12.2 (from virtualenv)
                                          Downloading filelock-3.16.1-py3-none-any.whl.metadata (2.9 kB)
                                        Collecting platformdirs<5,>=3.9.1 (from virtualenv)
                                          Downloading platformdirs-4.3.6-py3-none-any.whl.metadata (11 kB)
                                        Downloading virtualenv-20.26.5-py3-none-any.whl (6.0 MB)
                                           ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 6.0/6.0 MB 1.4 MB/s eta 0:00:00
                                        Downloading distlib-0.3.8-py2.py3-none-any.whl (468 kB)
                                        Downloading filelock-3.16.1-py3-none-any.whl (16 kB)
                                        Downloading platformdirs-4.3.6-py3-none-any.whl (18 kB)
                                        Installing collected packages: distlib, platformdirs, filelock, virtualenv
                                        Successfully installed distlib-0.3.8 filelock-3.16.1 platformdirs-4.3.6 virtualenv-20.26.5


                                        ╰─ pip3.12  install virtualenvwrapper
                                        Collecting virtualenvwrapper
                                          Using cached virtualenvwrapper-6.1.0-py3-none-any.whl.metadata (5.1 kB)
                                        Requirement already satisfied: virtualenv in /Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages (from virtualenvwrapper) (20.26.5)
                                        Collecting virtualenv-clone (from virtualenvwrapper)
                                          Using cached virtualenv_clone-0.5.7-py3-none-any.whl.metadata (2.7 kB)
                                        Collecting stevedore (from virtualenvwrapper)
                                          Downloading stevedore-5.3.0-py3-none-any.whl.metadata (2.3 kB)
                                        Collecting pbr>=2.0.0 (from stevedore->virtualenvwrapper)
                                          Downloading pbr-6.1.0-py2.py3-none-any.whl.metadata (3.4 kB)
                                        Requirement already satisfied: distlib<1,>=0.3.7 in /Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages (from virtualenv->virtualenvwrapper) (0.3.8)
                                        Requirement already satisfied: filelock<4,>=3.12.2 in /Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages (from virtualenv->virtualenvwrapper) (3.16.1)
                                        Requirement already satisfied: platformdirs<5,>=3.9.1 in /Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages (from virtualenv->virtualenvwrapper) (4.3.6)
                                        Using cached virtualenvwrapper-6.1.0-py3-none-any.whl (22 kB)
                                        Downloading stevedore-5.3.0-py3-none-any.whl (49 kB)
                                        Using cached virtualenv_clone-0.5.7-py3-none-any.whl (6.6 kB)
                                        Downloading pbr-6.1.0-py2.py3-none-any.whl (108 kB)
                                        Installing collected packages: virtualenv-clone, pbr, stevedore, virtualenvwrapper
                                        Successfully installed pbr-6.1.0 stevedore-5.3.0 virtualenv-clone-0.5.7 virtualenvwrapper-6.1.0

                    ╰─ pip3.12  install yawsso
                    Collecting yawsso
                      Downloading yawsso-1.2.0-py3-none-any.whl.metadata (10 kB)
                    Downloading yawsso-1.2.0-py3-none-any.whl (16 kB)
                    Installing collected packages: yawsso
                    Successfully installed yawsso-1.2.0


                    ╰─ which yawsso
                    /Library/Frameworks/Python.framework/Versions/3.12/bin/yawsso



              ---------------------------------
               2.1  At this point is better to tidy up the system wrt python.

               Like perlenv there is
                           . virtualenv          https://virtualenv.pypa.io/en/stable/userguide/
                           . virtualenvwrapper   is a set of extensions to virtualenv.
                                                 https://virtualenvwrapper.readthedocs.io/en/latest/command_ref.html  <--- cmd reference
                                                 which makes the usage of virtualenv
                                                 easier with shortcuts (e.g. workon)


                     1   pip uninstall virtualenvwrapper
                     2   pip uninstall virtualenv
                     3.  pip install virtualenv    # since a Mac/OS update (2024.05.10)they stopped working. It's now better to install them via brew      brew install virtualenv
                     4.  pip install virtualenvwrapper        # brew install virtualenvwrapper

                         this will install a shell script (virtualenvwrapper.sh) somewhere
                         (on the Mac in 1 of these possible places:
                                         /Library/Frameworks/Python.framework/Versions/2.7/bin/virtualenvwrapper.sh)
                                         /usr/local/bin/virtualenvwrapper.sh                   ^^^^^^^^^^^^^^^^^^^^
                                         ...)           ^^^^^^^^^^^^^^^^^^^^
                     5.  source ....../virtualenvwrapper.sh (add this also in the .bashrc)
                                       ^^^^^^^^^^^^^^^^^^^^
                     6.  WORKON_HOME=~/PYTHON_ENVS (or any wanted dirname)
                     7.  workon             without args just list the virtual envs (they are the dirs inside $WORKON_HOME)
                     8.  mkvirtualenv env1  this will install a new python in a dir $WORKON_HOME/env1
                                            This env1 env2 ... envn dirs
                                            have the same structure:
                                                     these 3 dirs
                                                      ls ~/PYTHON_ENVS/2.5.2
                                                                          |_/bin
                                                                          |_/lib
                                                                          |_/include

                                                      in the "bin" directory the modules are then installed
                                                      every time I do "pip install xxxx"

                                                      ls ~/PYTHON_ENVS/2.5.2
                                                                          |_/bin
                                                                          |      activate
                                                                          |      activate.csh
                                                                          |      activate.fish
                                                                          |      activate.ps1
                                                                          |      activate_this.py
                                                                          |      ansible
                                                                          |      ansible-config
                                                                          |      ansible-connection
                                                                          |      ansible-console
                                                                          |      ansible-doc
                                                                          |      ansible-galaxy
                                                                          |      ansible-inventory
                                                                          |      ansible-playbook
                                                                          |      ansible-pull
                                                                          |      ansible-vault
                                                                          |      easy_install
                                                                          |      easy_install-2.7
                                                                          |      get_env_details
                                                                          |      pip
                                                                          |      pip2
                                                                          |      pip2.7
                                                                          |      postactivate
                                                                          |      postdeactivate
                                                                          |      preactivate
                                                                          |      predeactivate
                                                                          |      python
                                                                          |      python-config
                                                                          |      python2
                                                                          |      python2.7
                                                                          |      wheel
                                                                          |_/lib
                                                                          |      python2.7
                                                                          |
                                                                          |_/include
                                                                                 python2.7

                                            7.1 example then to install python modules with pip (ex. ansible)
                                            pip install ansible==2.5.2
                                            pip install redis

                     9.  lssitepackages     to see the packages
                    10.  mkvirtualenv env2  this will install another python in a dir $WORKON_HOME/env2
                    11.  workon env1        sets the env. (here back to env1)
                    12.  deactivate         Switch from a virtual environment to the system-installed version of Python.

                    virtualenvwrapper (other commands) :
                                       . lsvirtualenv     -b (brief)   -l (long/verbose)   -h (help)
                                       . rmvirtualenv     ex. rmvirtualenv env1    (<---- NB. better to run after a deactivate (of env1))
                    ex. lsvirtualenv    gives

                        env_ansible.2.3.1.0
                        ===================

                        env_ansible.2.5.2           <----------- I then can do    workon env_ansible.2.5.2
                        ===================

                        env_ansible.2.6.2
                        ===================
	________________________________________ penv

	1. python3 -m venv /Users/sbasile/PYTHON_ENVS/PENV
	2. source  /Users/sbasile/PYTHON_ENVS/PENV/bin/activate
	3. python3 -m pip install .....                                  # ex. python3 -m pip install pandas
	________________________________________ 

pip list
            Package         Version
            --------------- -------
            awscli          1.18.53
            boto3           1.13.3
            botocore        1.16.3
            colorama        0.4.3
            docutils        0.15.2
            jmespath        0.9.5
            pip             20.1
            pyasn1          0.4.8
            python-dateutil 2.8.1
            PyYAML          5.3.1
            rsa             3.4.2
            s3transfer      0.3.3
            setuptools      46.1.3
            six             1.14.0
            urllib3         1.25.9
            wheel           0.34.2



pip list --outdated

            Package    Version Latest  Type
            ---------- ------- ------- -----
            awscli     1.18.53 1.18.88 wheel
            boto3      1.13.3  1.14.11 wheel
            botocore   1.16.3  1.17.11 wheel
            docutils   0.15.2  0.16    wheel
            jmespath   0.9.5   0.10.0  wheel
            pip        20.1    20.1.1  wheel
            rsa        3.4.2   4.6     wheel
            setuptools 46.1.3  47.3.1  wheel
            six        1.14.0  1.15.0  wheel



[xml@i-041925ed4c545e6a2 ~]$ pip3 freeze          # (both with pip & pip3)  to show the list of modules

            ansible==2.10.6
            ansible-base==2.10.15
            awscli==1.21.8
            boto==2.49.0
            boto3==1.20.22
            botocore==1.23.22
            cffi==1.15.0
            colorama==0.4.3
            cryptography==35.0.0
            distro==1.6.0
            docutils==0.15.2
            j2cli==0.3.10
            Jinja2==3.0.2
            jmespath==0.10.0
            MarkupSafe==2.0.1
            packaging==21.2
            pyasn1==0.4.8
            pycparser==2.20
            pyparsing==2.4.7
            python-dateutil==2.8.2
            PyYAML==5.4.1
            rsa==4.7.2
            s3transfer==0.5.0
            selinux==0.2.1
            six==1.16.0
            urllib3==1.26.7


[xml@i-041925ed4c545e6a2 ~]$ pip3 show boto3
            Name: boto3
            Version: 1.20.22
            Summary: The AWS SDK for Python
            Home-page: https://github.com/boto/boto3
            Author: Amazon Web Services
            Author-email:
            License: Apache License 2.0
            Location: /usr/local/lib/python3.6/site-packages
            Requires: botocore, jmespath, s3transfer
            Required-by:


________________________________________ MORE PYTHONS


        there are "different" (not "many", as these solution do not always overlap and do different things)
        solutions to have more PYTHON versions and switch between them
        This creates confusion and goes against the Python Zen:

            “There should be one – and preferably only one – obvious way to do it.”


        venv                          is builtin with Python 3, which you can run using
                                                 python3 -m venv
                                      It serves a similar purpose to virtualenv, and works in a very similar way,
                                      but it doesn't need to copy Python binaries around (except on Windows).
                                      Use this if you don't need to support Python 2.

        virtualenv / virtualwrapper : they copy the full python executable binary file in their env directories.
                                      >>>>> As Python looks for its LIBRARIES starting relative to its path first <<<<<<
                                      avery Python will use theirown env libraries

        pyenv / pyenv-virtualenv / pyenv-virtualwrapper : they copy the full python executable binary file in their env directories.
                                      it isolates Python versions (ex. Python 2.6, 2.7, 3.3, 3.4 and 3.5) and switches between them.
                                      It prefixes PATH with
                                                       ~/.pyenv/shims,
                                      which contains special files matching commands (python & pip).
                                      These are not copies of the binaries like in virtualenv / virtualwrapper
                                      but special scripts that decide on the fly which version of Python to run based on
                                               PYENV_VERSION    env var
                                               .python-version  file,
                                               ~/.pyenv/version file.

                                       pyenv also makes the process of downloading and installing multiple Python versions easier, i
                                       using the command pyenv install.

                                       pyenv-virtualenv:     plugin to use both pyenv & virtualenv
                                       pyenv-virtualwrapper: plugin to use both pyenv & virtualwrapper


________________________________________ os

import os

os.getuid()            500  (user id)
os.getpid()            16150 (proc id)
os.getppid()           14847 (parent id)
os.uname()             ('Linux', 'd80', '2.6.34.7-56.fc13.i6 ....

work on dirs           os.getcwd()      -->  '/home/kushal'
                       os.chdir('/tmp')
                       os.getcwd()      -->  '/tmp'

                       names = os.listdir(path)
                       names.sort()
                       for name in names:
                           print name,




________________________________________ Fast operations on Collections

from collections import Counter

z=Counter(l)       receives a list l, returns like an hash: a list of pairs
                   elem:num   enum is any different elem of l, num its the occurrences

z.most_common(N)   returns the first N elem of z, ordere by  occurences

z.elments()        returns a list from z, whit all elem of z, each duplicated n times
                   (its number of occurrences)



________________________________________ Test

import unittest                  unittest is the python module for testing

class MyTestClass (unittest.TestCase):    define a test class (derived from unittest.TestCase)
                                          where call the functions I want to test.
                                          Each method of 'MyTestClass' named like

                                                          test_xxxxx()

                                          will be called launching:

                                                          unittest.main()

                                          Each test_xxx() inside is a template like
                                                          res = ffff()
                                                          self.asserTTTTTTTT

                                          where ffff() is the function I want to test
                                          asserTTTTT is one of many way unittest provides to test:

assertEqual(a, b)           a == b                ex. self.assertEqual(res, 120)
assertNotEqual(a, b)        a != b
assertTrue(x)               bool(x) is True
assertFalse(x)              bool(x) is False
assertIs(a, b)              a is b
assertIsNot(a, b)           a is not b
assertIsNone(x)             x is None
assertIsNotNone(x)          x is not None
assertIn(a, b)              a in b
assertNotIn(a, b)           a not in b
assertIsInstance(a, b)      isinstance(a, b)
assertNotIsInstance(a, b)   not isinstance(a, b)

assertRaises(....Error, ...)          ex. self.assertRaises(ZeroDivisionError, div, 0)



python-coverage             is the module to test how much I test covered my code:
                            sudo pip install coverage
                            coverage -x mytest.py



________________________________________   develop a module 'basilest'

     1. mkdir temp                                         temp
     2. cd temp                                              |__ basilest
     3. mkdir basilest                                       |     |__ myfile.py
     4. vi basilest/myfile.py                                |     |___  __init__.py
     4. vi basilest/ __init__.py                             |__ README.rst
     5. vi ./README.rst                                      |__ MANIFEST.in
     6. vi MANIFEST.in                                       |__ setrup.py
                        include *.py
                        include README.rst
                        n.b. you can also use dir 'exclude'
     7. sudo pip install setuptools
     8. vi setup.py
                        #!/usr/bin/env python
                        """ my module description here"""
                        from setuptools import find_packages, setup

                        setup(name = 'proj_basilest',------------------------\
                        version = '0.1',                                     |
                        description = "Basile module.",                      |
                        long_description = "A test module for our book.",    |
                        platforms = ["Linux"],                               |
                        author="Kushal Das",                                 |
                        author_email="kushaldas@gmail.com",                  |
                        url="http://pymbook.readthedocs.org/en/latest/",     |
                        license = "MIT",                                     |
                        packages=find_packages()                             |
                        )                                                    |
                                             --------------------------------'
                                             |
     9. python setup.py sdist    --->  proj_basilest-0.1.tar.gz
    10. python setup.py install

________________________________________ Decorators


              def outer(fun_to_cut):              receives a fun to cut from  its old def
              ...     x = 1
              ...     def inner():
              ...         print x
              ...         r = fun_to_cut()        here call the original fun
              ...         return r;               return original r
              ...     return inner                outer returns the Closuer 'inner'

              def f():         #1
                 bla bla bla

              f()                here f () calls original #1
              f = outer(f)       assigning again to f, from now on I lost original def
                                 and f() will call the Closuer inner where legacy f is in
              f() -->  Inside inner

@             the f = outer(f) assignment can be left as it is, or
              can be also specified as

              @outer              which means, where there is the original def of f()
              def f():            I use @ and the name of the function containin the Closure
                 bla bla bla      so here 'outer'


(*args, **kwargs)    the moste general form, considering any number and type
             of args, is substitute the 'def inner()' with the syntax:
                      def inner(*args, **kwargs):
             while def 'outer(fun_to_cut)' remains equal, 1 arg only


________________________________________

Python:
                  Interpreted         (like perl)

                  anhhoe there are tools (like
                                             - pyexe
                                             - pyinstaller
                                         ) which compile into 1 native executable

                  1st release       1991
                  2.0               2000       (support Unicode & other features)
                  3.0               2008       (not backward compat.)

Philosophy
                  Beautiful is better than  ugly             <---------- these points are actually 20
                  Explicit        >         implicit                     called "The Zen of Python"
                  Simple          >         complex                      I can see them from inside the REPL
                  Complex         >         complicated                  typing:  >>> import this
                  Readability counts

P E P             Python Enhancement Proposal                   to submit (to the community) extensions to the design

________________________________________
flask             to have a web server listening
                  ex:
                            ───────┬───────────────────────────────────────
                                   │ File: service.py
                                   │ Size: 201 B
                            ───────┼───────────────────────────────────────
                               1   │ from flask import Flask
                               2   │ app = Flask(__name__)
                               3   │
                               4   │ @app.route("/")
                               5   │ def hello():
                               6   │         return "Hello Woorld!"
                               7   │
                               8   │ @app.route("/user/<username>")
                               9   │ def show_user(username):
                              10   │         return "User: %s" % username
                            ───────┴───────────────────────────────────────

                  $ FLASK_APP=service.py  flask run

________________________________________
django            to have a web server listening
                  ex:
                            $ django-admin startproject mysite              # creates a structure for a new project (files & tree of dirs)

                                         .
                                         |___ mnage.py
                                         |___ mysite
                                             |___ __init__.py
                                             |___ settings.py
                                             |___ urls.py
                                             |___ wsgi.py

                  $ python3 manage.py runserver         # il will run the proj(server) on default port 8000
________________________________________
pypi          python package index    (like cpan for perl)
________________________________________

python        binary to:
                         - executing 1 file
                         - rudimentary REPL    (Read / Eval / Print / Loop)

pip           pip-installs-packages

iphyton       very robust interative shell   (much feature-rich than the bultin REPL)

________________________________________
python 2 vs 3
              python 2:        python    pip     ipython
                               python2   pip2    ipython2

              python 3:        python3   pip3    ipython3
________________________________________
REPL

in python3:
import imp           <------- deprecated
import importlib     <------- use this

            they reload a module which maybe was changed.
            ex of usage
                         importlib.reload(mymodule)             # ex the file mymodule.py was edited on disk

in python2:
            call directly the builtin function  'reload'
                         reload(mymodule)            <------- no more supported in python3
_           the underscore has a special meaning only in REPL (not in general in python)
            and it means (the last value)
            ex:
                    >>> x = 5
                    >>> x
                    5
                    >>> 3 * x
                    15
                    >>> -
                    15
                    >>> _ * 2
                    30

print       print "aaaaaa"          ok in python2 (without parentesis is allowed)
            print ('aaaaaa')        Mandatory in python3 (allowed in python2)

indentetion       4 spaces
________________________________________
ipython
            > %load_ext autoreload
            > %autoreload 2                    <---- these 2 instructions allow to have the autoreload (like in Tilt)
                                                     so much better than the explicit reloads in REPL
________________________________________
input         function to get value from the user
              ex
                      print ("gimme a value")
                      resp = input()
________________________________________
import
                 >>> import math               # syntax to import a module.
                                                 notice: an import executes the module (eg. it there are function calls they are executed)
                                                 anyhow if I import it again, everything is skipped.
                                                 In the end multiple imports are not multiple executions.
                                                 If I use a debugger I can see that at the first import the code is executed.
                                                 Each 'def' statement (which defines a function) is a stoppable breakpoint
                                                 because it's a statement which binds code to a name (of the function)
                                                 On a next import these def will not be then stoppable breakpoints
                 >>> help (math)               # syntax to dump the exported functions of the module (its' documentation)
                                               ex of output:

                                                       | Help on module math:
                                                       |
                                                       | NAME
                                                       |     math
                                                       |
                                                       | MODULE REFERENCE
                                                       |     https://docs.python.org/3.8/library/math
                                                       |
                                                       |     The following documentation is automatically generated from the Python
                                                       |     source files.  It may be incomplete, incorrect or include features that
                                                       |     are considered implementation detail and may vary between Python
                                                       |     implementations.  When in doubt, consult the module reference at the
                                                       |     location listed above.
                                                       |
                                                       | DESCRIPTION
                                                       |     This module provides access to the mathematical functions
                                                       |     defined by the C standard.
                                                       |
                                                       | FUNCTIONS
                                                       |     acos(x, /)
                                                       |         Return the arc cosine (measured in radians) of x.
                                                       |
                                                       |     acosh(x, /)
                                                       |         Return the inverse hyperbolic cosine of x.
                                                       |
                                                       |     asin(x, /)
                                                       |         Return the arc sine (measured in radians) of x.
                                                       |
                                                       |     ...

                 >>> help (math.acos)                           # syntax to dump the help only for that module function
                 >>> from math import acos                      # syntax to import only parts (here function acos) of the module
                                                                  this allows to write directly 'acos' instead of the explicit fully qualified name: 'math.acos'
                 >>> from math import (f1, f2, f3)              # syntax to import a list of functions. The parentheses are optional
                 >>> from math import *                         # syntax to import anything
                 >>> from math import factorial as fac          # to assign an alias to the imported function (so I can just call it 'fac')

________________________________________
__name__         special var which allows to detect if the file is run as a script  (ex $ python my_file.py)
                 or is imported in another module:   import my_file

                 ex my_file.py:
                         ......
                         print (__name__)
                                                     if executed as $ python my_file.py will print "__main__"
                                                     if imported it will print "my_file"
                 so it's common to see this:

                 if __name == '__main__':
                    ....       <---------------------this code will be executed only if the file is called as a script

         N.B.  __name__ it's also an attribute of functions
               see dir() below
________________________________________
argv    (sys)
                 import sys
                 ...
                 sys.argv[1]     # the 1st arg passed
________________________________________
//                       truncate a divison to an integer
                         >>> 11 / 3
                         3.6666666666666665
                         >>> 11 // 3
                         3
________________________________________
SCALAR TYPES

               int
                                10
                                0n10             2       binary
                                0o10             8       octal
                                0x10            16       exad.
                                int(3.5)         3       construct
                                int("456")     456       string conversion
                                int("1000",3)   27       any base (here base 3)

               float            IEEE-754  double precision:
                                                    53 bits of binary precision --> 15-16 significant digits in decimal

                                3.345
                                3e8          300,000,000.0        exponential
                                float(7)                 7
                                float("1.618")       1.618        string conversion
                                float("nan")           nan
                                float("inf")           inf        infinitive
                                float("-inf")         -inf        negative "

               None             a = None
                                a is None            True

               bool             True
                                False
                                                        True                               False
                                __________________________________________________________________________________________________
                                                bool(42)                                  bool(0)
                                                bool(-1)                                  bool(0.0)
                                                bool(3.16)
                                                bool("abc")          string               bool("")         empty string
                                                bool([1,4,9])        list                 bool([])         empty list

________________________________________
COLLECTION TYPES
               str
               bytes
               list             usual array
               dict

     __________________
     str
                                sequence of Unicodes

                                "aaa"                           both quoting allowed
                                'aaa'

                                """ This is                     3 double quotes for multiline strings
                                    a multiline
                                    string"""

                                ''' This is                     3 single quotes do the same
                                    a multiline
                                    string'''

                                "111\n222\n333"                 usual \n
                                '111\n222\n333'                 same. This is unsual!

                                \\                              escape backslash
                                \'                              escape single quote
                                \"                              escape doube quote
                                \ooo                            octal num
                                \xhh                            exad  num
                                \N{name}                        Unicode by name
                                \uxxxx                          Unicode by 16-bit val
                                \Uxxxxxxxx                      Unicode by 32-bit val

                                path = r'C:\Users\Merlin\Documents\'     raw string: they have the raw value of literally whatever
                                                                         between r'     and '

                                str(496)                        string conversions
                                str(6.02e23)

                                s = 'parrot'                    notice how I can
                                s[4]        'o'                 access the single 'chars'
                                                                which anyhow are still strings (of 1):
                                                                  type(s[4])  ----> gives <class 'str'>


           concatenation        "aaa" "bbb"      aaabbb      /   also "aaa" + "bbb"

           * op                 >>> a=5*"-"              * operator  (notice it works on both sides (left/right))
                                >>> a
                                '-----'
                                >>> a="+"*5
                                >>> a
                                '+++++'



           join                 >>> a = '-'.join(['1','2','3'])  <-------- join  (it's on the separator object)
                                >>> a
                                '1-2-3'
                                >>> a = '-:.'.join(['1','2','3'])
                                >>> a
                                '1-:.2-:.3'
                                >>> a = ''.join(['1','2','3'])
                                >>> a
                                '123'

           split                >>> "1-2-3".split('-')
                                ['1', '2', '3']


                                >>> "unforgetable".partition('forget')  <------- partition
                                ('un', 'forget', 'able')
                                >>> departure, sep, arrival = "London:Edinburg".partition(':')
                                >>> departure
                                'London'
                                >>> arrival
                                'Edinburg'


           format               >>> a = "this {0} and that {1}".format(56, "abc")
                                >>> a
                                'this 56 and that abc'
                                >>> a = "....{} .... {} ....".format(a,b)        when it's clear, I can skip 0 and 1 ....
                                >>> a = "... {lat} .... {long}..".format(lat="60N", long="5E")    I can name the args
                                >>> a = "... {pos[0]} .... {pos[1]}..".format(pos=(5,6,7))        I cas address a tupla

                                import math
                                >>> a = "... {m.pi} .... {m.e}..".format(m=math)                  I cas address a module


           f-strings            val = 20
                                f'....{val}..'                         <----------- f-strings   f' ...'   or double quote too: f" ..."
                                f'....{some_function()}..'                          have been added to Python to allow
                                                                                    a quick interpolation. Syntax  f'....{..} ...'


     __________________
     bytes
                                sequence of bytes (ASCII range)

                                b'stefano'             notice the syntax of   b'......'
                                b"stefano"             I can use " instead of '

                                d = b'parrot due'
                                d[4]          'o'

                                d.split()     [b'parrot', b'due']


               str <--------> byte            encode/decode

                                                    str ---(encode)-----> byte      ex:    s = "a not ä"
                                                                                           data  = s.encode('utf8')
                                                                                           data
                                                                                           b'a not \xc3\xa4'

                                                    str <--(decode)------ byte      ex:    data =  b'a not \xc3\xa4'
                                                                                           s = s.decode('utf8')
                                                                                           s
                                                                                           "a not ä"
     __________________
     list                    usual array

                                [1, 9, 8]            note a last comma is allowed like in perl [1,9,8,]
                                []                   empty list
                                list ("apple")      ['a','p','p','l','e']       constrcutor to create a list from a collection (ex a string)

                                [-1]                last elem
                                [-2]                second last

           slices               s=[3,186,4431,55,2]
                                s[1:3]              [186,4431]    slice    (note is start:stop with start included & stop excluded)
                                s[1:-1]             [186,4431,55]
                                s[2:]               [186,4431,55,2]
                                s[:2]               [3,186]
           copy                 s[:]                this gives the whole list. It's useful to copy a list, not by reference but by value:
           (shallow)                                             r = s     this is the default by ref
                                                                 s = s[:]  this creates a separate copy
                                                    2 other ways to copy are
                                                                 r = s.copy()
                                                                 r = list(s)
                                                    NOTE: all the copies are shallow copies (not deep, just the first level)
                                                            >>> a=[[1,2], [3,4]]
                                                            >>> a[0]
                                                            [1, 2]
                                                            >>> b=a[:]
                                                            >>> b
                                                            [[1, 2], [3, 4]]
                                                            >>> a
                                                            [[1, 2], [3, 4]]
                                                            >>> a[0][1]=88
                                                            >>> a
                                                            [[1, 88], [3, 4]]
                                                            >>> b
                                                            [[1, 88], [3, 4]]

                                                    To have a full nested copy:
                                                            import copy
                                                            b=copy.deepcopy(a)


           * op                 >>> a=[[1,2]]*3   <---------- *
                                >>> a
                                [[1, 2], [1, 2], [1, 2]]   <---- be careful, the repetition again acts as a shallow copy:
                                >>> a[0][1]=88
                                >>> a
                                [[1, 88], [1, 88], [1, 88]]


           index                >>> a=['aaa','bbb','fox','ccc','fox','fox']    <----- index & count
                                >>> a.index('fox')                             <----- note: only the 1st encountered
                                2
           count                >>> a.count('fox')
                                3


           in / not in          >>> "ccc" in a
                                True
                                >>> "ccc" not in a
                                False


           del                  >>> del a[2]    <------ del by passing the index
                                >>> a
                                ['aaa', 'bbb', 'ccc', 'fox', 'fox']


           remove               >>> a=['aaa','bbb','fox','ccc','fox','fox']   <----- remove by value (not only the 1st encountered)
                                >>> a.remove('fox')
                                >>> a
                                ['aaa', 'bbb', 'ccc', 'fox', 'fox']


           insert               >>> a.insert(2,"new")
                                >>> a
                                ['aaa', 'bbb', 'new', 'ccc', 'fox', 'fox']


           extending            >>> m=[2,1,3]
                                >>> n=[4,7,11]
                        +       >>> k = m + n
                                >>> k
                                [2, 1, 3, 4, 7, 11]
                                >>> k += [18,29,47]
                                >>> k
                                [2, 1, 3, 4, 7, 11, 18, 29, 47]
                        extend  >>> k.extend([0,55])
                                >>> k
                                [2, 1, 3, 4, 7, 11, 18, 29, 47, 0, 55]


           reverse              >>> k.reverse()    <----------- note it changes in place    use z = reversed (k) to leave k unmodified
                                >>> k                                                               ^^^^^^^^
                                [55, 0, 47, 29, 18, 11, 7, 4, 3, 1, 2]

           sort                 >>> k.sort()       <----------- sane, it also changes in place. So z = sorted (k)
                                >>> k                                                                  ^^^^^^
                        <       [0, 1, 2, 3, 4, 7, 11, 18, 29, 47, 55]
                                >>> k.sort(reverse=True)
                        >       >>> k
                                [55, 47, 29, 18, 11, 7, 4, 3, 2, 1, 0]

                                >>> def stef(a,b):
                                ...    if a > b:
                                ...       return -1
                                ...    elif a == b:
                                ...       return 0
                                ...    else:
                                ...       return 1
                                ...
                                >>> stef (4,5)
                                1
                                >>> stef (4,3)
                                -1
                                >>> stef (4,4)
                                0
                                >>> k
                                [2, 1, 3, 4, 7, 11, 18, 29, 47, 0, 55]
                                >>> from functools import cmp_to_key
                                >>> stef_k = cmp_to_key(stef)
                                >>> k.sort(key=stef_k)
                                >>> k
                                [55, 47, 29, 18, 11, 7, 4, 3, 2, 1, 0]



     __________________
     dict
                                the hashes
                                a = {'k1': 'v1', 'k2':'v2'}
                                {}                        empty dict
                                b = a['k1']               [] operator like normal array
                                L = list(a)               ['k1', 'k2']   returns the keys
                                L = list(a.keys())           "    "         "      "   "
                                L = list(a.values())      ['v1', 'v2']   returns the values


           dict                 >>> a = [('k1','v1'),('k2','v2')]
                                >>> a
                                [('k1', 'v1'), ('k2', 'v2')]
                                >>> b = dict(a)   <------------------- creates a hash from a list
                                >>> b
                                {'k1': 'v1', 'k2': 'v2'}

                                >>> x = dict (a=1, b=2)                other syntax allowed
                                >>> x
                                {'a': 1, 'b': 2}

           copy                 like for lists, there are 2 ways:

                                b = a.copy()
                                b = dict (a)

           update               to extend/add/replace
                                __________________ add __________________            ____________ replace __________________
                                >>> b
                                {'k1': 'v1', 'k2': 'v2'}
                                >>> c={'k3':5, 'k4':0}                               >>> c={'k3':5, 'k2':0}
                                >>> b.update(c)                                      >>> b.update(c)
                                >>> b                                                >>> b
                                {'k1': 'v1', 'k2': 'v2', 'k3': 5, 'k4': 0}           {'k1': 'v1', 'k2': 0, 'k3': 5, 'k4': 0}


                                or even just directly:

                                >>> b['k8']=99
                                >>> b
                                {'k1': 'v1', 'k2': 0, 'k3': 5, 'k8': 99}


           items                returns both keys & values (like 'enumerate' for 'range')

                                >>> b.items()
                                dict_items([('k1', 'v1'), ('k2', 0), ('k3', 5), ('k8', 99)])

                                this is possibly used in a loop:

                                           for k, v  in b.items():
                                              ...


           in                   check if the key is/is not present:
           not in               >>> 'k1' in b
                                True

           del                  >>> b
                                {'k1': 'v1', 'k2': 0, 'k3': 5, 'k8': 99}
                                >>> del b['k8']
                                >>> b
                                {'k1': 'v1', 'k2': 0, 'k3': 5}




________________________________________
CONTROL LOOPS


              if True:                  if bool("eggs"):          if "eggs":
                     print("ok")
              else:     <----- note even the else has the ':'
              elif .... :


              while .... :


              break           <--- as usual

              cities = ["London", "New York", "Paris", "Oslo"]
              for c in cities:                                      notice if a cycle on a dict I cycle on the keys
                    print (c)
________________________________________
FUNCTIONS
             def my_fun(x):                  def is a statement which binds a code (block) to a name (of the function)
                 ...
                                    <---------- if there is no return, it returns 'None'

             def my_func(x,y,z=5)            I can specify 'default' values for arg
                                             args with defaults must stay at the end of the list, so after any other arg without default.

                                             note: as the 'def' statements are executed only once (when the module is first imported)
                                                   any default-arg is evaluated at the 1st time and then never changed.
                                                   This is usually fine, but if not considered properly can give wrong code
                                                   ex
                                                         import time
                                                         time.ctime()     # this gives 'now' time 'Sun Nov 13 19:43:48 2022'
                                                         def my_func(arg=time.ctime()):    <---- arg will not change on next calls
                                                              ....

             count = 0         <-------- this is a global var
             def my_func(c):
                 count = c     <------ this is a local var overshadowing the global

             def my_func(c):
                 global count  <--- this is how to use global var inside a func
                 count = c
________________________________________
COMMENTS
             #              <---- to the end of line
________________________________________
pass         no operation. it's like  ':' in the shell
________________________________________
_       (underscore)

        o like in Go it is the unused value
                    >>> departure, _, arrival = "London:Edinburg".partition(':')

        o can be found used as a loop var:
                    while _ < 10:
                        print(_, end = ' ')
                        _ += 1

        o separate digits (any base)
                    million = 1_000_000
                    binary = 0b_0010
                    octa = 0o_64
                    hexa = 0x_23_ab

        o may preclude module names to be used when the module is imported

                    def func():
                        ..

                    def _private_func():    <---------- this will not be accessible with a
                        ..                                       from mu_module import *
                                                        but accessible with
                                                                 import my_module
                                                                     ..
                                                                     my_module._private_func


        o REPL:   in the REPL it holds the value of the last expression
                    >>> 9+5
                    14
                    >>> _
                    14
________________________________________
docstrings
             are """ .... """ strings (so 1 or more lines text)
             immediately after a declaration  (ex after a function or immediately at the top of the module/file)
             ex:
                            def my_fun (x):
                                """ the func does
                                    something
                                    and exit """

             some tools (ex Sphinx) can parse the code and produce the usual HTML documentation.
             (note on Sphinx: The Linux kernel's documentation subsystem underwent changes in 2016.
              Starting in the 4.7 cycle, Sphinx was adopted)

             In the REPL the help() does the same, so it prints those docstrings

             Another way to see them is to use the attribute __doc__ (which is avialble everywhere as everything is an object)

             The text has its own syntax ex:
                                """ ........
                                    Args:
                                         arg1: ....
                                         arg2: ...
                                    Returns:
                                         ....
                                    """
             so that the HTML is styled.

________________________________________
OBJECTS AND TYPES           (Everything is an object)

        >>>  x = 1000
        >>>  id(x)         <-------------- id()     gives a unique reference which maps a name (var) to a value int.1000
             4301474256                             It's not to be thought as the mem address. It is just a number to identify a relationship
        >>>  y = 500
        >>>  id(y)
             4301475248
        >>>  y = x
        >>>  id(y)
             4301474256
        >>>  x is y
             True
        >>>  x is None
             False
        >>>  x += 2
        >>>  id(x)         <-------------- id()     if x maps a new int: int.1000 --> int.2, then the id() is a completely new one
             4301474272                             This highlights that id() must not be thought as a mem address


            x ---> int.5        x ---> int.5           x       int.5            int.5  & int.2 no more mapped to anything
                                         +              \                       will be garbage-collected
                                       int.2             |     int.2
                                                         |
                                                         '-->  int.7

            with this logic an equal assignment operator '='
            ex like in x = 5
            should never be thought as a copy by value but just
            a map betweeen a name and an object

            This is then actually like a copy by reference
            as shown with this

                    >>> a = [1,2,3]
                    >>> a
                    [1, 2, 3]
                    >>> b = a
                    >>> b
                    [1, 2, 3]
                    >>> b[2]=8
                    >>> a
                    [1, 2, 8]     <------- a also is changed
                                                           ---------> the same is expected when passing arg to a function
                                                                      the function receives them 'by reference' so it can
                                                                      modify the caller's vars

                                                                      even the "return" (in a function) passes back references
            a var is then not a box holding a value
            but a named reference to an object.

            This also clarifies the difference in '==' and 'is'
                    >>> a=[4,5,6]
                    >>> b=[4,5,6]
                    >>> a == b
                    True
                    >>> a is b
                    False

________________________________________
type()
          __________________________________
          >>> import xxx
          >>> type(xxx)
              <class 'module'>
          __________________________________

          >>> def my_func(x):
                ...
          >>> type(my_func)
              <class 'function'>
          __________________________________

          >>> x=8
          >>> type(x)
          <class 'int'>
          __________________________________



________________________________________
dir()     list the attributes of a type

          __________________________________
          >>> import math
          >>> dir(math)
          ['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh',
           'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'degrees',
           'dist', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum',
           'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt', 'ldexp', 'lgamma',
           'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'perm', 'pi', 'pow', 'prod', 'radians', 'remainder',
           'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']
          __________________________________

          >>> def stef(x):
                ...
          >>> dir(stef)
          ['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__',
           '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__',
           '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__',
           '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']

          >>> print (stef.__name__) <-------- __name__
          stef
          __________________________________

          >>> x=8
          >>> dir(x)
          ['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__',
           '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__',
           '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__',
           '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__',
           '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__',
           '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__',
           '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_length', 'conjugate', 'denominator',
           'from_bytes', 'imag', 'numerator', 'real', 'to_bytes']
          __________________________________



________________________________________
Bult-in COLLECTIONS
            tuple
            range
            set
     __________________
     tuple               like lists(i.e. array) but instead of [] they use ()   (which can also be omitted)

                         a = ("Norway", 4.953, 3)           ()-omitted --> a = "Norway", 4.953, 3
                         a[0]    -->  'Norway'
                         len(a)  -->  3

                         a + (6,8)      --> to concatenate/add
                         for i in a:    --> I can cycle
                         a * 3          --> to make it 3 times longer, replicating itself 3 times.

                         a = ((220, 284), ....)
                         a[0][1]   --> 284           They can be on more nested levels


                     N.B.  the difference between
                             a = (391)            a is an integer. The parenthesis are interpreted as mathematical grouping/precedence expression
                             b = (391,)           a tuple of 1

                                >>> type (a)
                                <class 'int'>
                                >>> type (b)
                                <class 'tuple'>

                         a=()    the empty tuple
                         (a, b, (c,d))) = (4,(3,(2,1)))        overcomplicated example to show that like in perl I can use a tuple to assign
                                                               more values to more vars.  This in python is called unpacking a tuple
                         (a,b) = (b,a)                         example of how to use the unpacking to swap to vars


                         tuple ([1,8,7])  --> (1,8,7)          example of usage of tuple function (a list into a tuple)
                         tuple ("abc")    --> ('a','b','c')       "                 "        "    (a string into a sequence of chars)


                         5 in     (3,5,11,4)  --> True         'in'
                         5 not in (3,5,11,4)  --> False        'not in'


     __________________
     range               they are a numerical progression of INTEGERS
                            >>> for i in range(5):
                            ...     print(i)
                            ...
                            0
                            1
                            2
                            3
                            4
           range            >>> list(range(5))
                            [0, 1, 2, 3, 4]
                            >>> list(range(5,10))
                            [5, 6, 7, 8, 9]
                            >>> list(range(5,10,2))
                            [5, 7, 9]


           enumerate        >>> t = [4,5,6]
                            >>> for p in enumerate(t):        <--------- enumerate: returns index and value
                            ...    print(p)
                            ...
                            (0, 4)
                            (1, 5)
                            (2, 6)
                            >>> for i, v in enumerate(t):
                            ...   print (f'{i} : {v}')
                            ...
                            0 : 4
                            1 : 5
                            2 : 6

     __________________
     set                 they are like hashes (using {}) but just values (not keys)
                         The values are unique

                            >>> s = {1,2,5,8}
                            >>> s
                            {8, 1, 2, 5}
                            >>> type (s)
                            <class 'set'>
                            >>> s = {1,2,5,8,8,8,8,8,8,2,2,2,5,5,5,5}    <---- note: dupliocate are removed
                            >>> s
                            {8, 1, 2, 5}


           set              >>> a=[1,2,5,8,8,8,8,8,8,2,2,2,5,5,5,5]      <---- same. Duplicates will go
                            >>> s = set(a)
                            >>> s
                            {8, 1, 2, 5}

           empty set        >>> s={}  <--------- I cannot use this syntax (already reserved for dict)
                            >>> type (s)
                            <class 'dict'>
                            >>> s=set()   <---- I use this
                            >>> type (s)
                            <class 'set'>


           in / not in      >>> 8 in s
                            True

           add              >>> s                      To add 1 elem.
                            {8, 1, 2, 5}
                            >>> s.add(88)   <--------- if I add something already in, I don't have errors
                            >>> s
                            {1, 2, 5, 8, 88}

           update           >>> s                      To add 1 or MORE  elems.
                            {8, 1, 2, 5}
                            >>> s.update([6,9,12])
                            >>> s
                            {1, 2, 5, 6, 8, 9, 12}

           remove           s.remove(8)       it errors         if the elem is NOT present
                            s.discard(8)      it DOESN'T error  "  "   "    "  "     "

           copy             s2 = s.copy()
           (shallow)


           union
           intersection
           difference
           symmetric_difference     only in 1 of the 2 sets (not both)
           issubset
           issuperset
           isdisjoint
                            >>> some_strings = {'aaa','bbb'}
                            >>> colors = {'blue', 'white', 'green', 'black', 'grey', 'yellow', 'red', 'orange', 'pink', 'brown'}
                            >>> eyes = {'green', 'brown', 'black', 'blue'}
                            >>> hairs = {'grey', 'white', 'black', 'red', 'yellow', 'brown'}
                            >>> u = eyes.union(hairs)
                            >>> u        ^^^^^
                            {'blue', 'black', 'white', 'brown', 'red', 'yellow', 'grey', 'green'}
                            >>> i = eyes.intersection(hairs)
                            >>> i        ^^^^^^^^^^^^
                            {'brown', 'black'}
                            >>> d1 = eyes.difference(hairs)
                            >>> d1        ^^^^^^^^^^
                            {'blue', 'green'}
                            >>> d2 = hairs.difference(eyes)
                            >>> d2         ^^^^^^^^^^
                            {'yellow', 'red', 'white', 'grey'}
                            >>> sd = hairs.symmetric_difference(eyes)
                            >>> sd         ^^^^^^^^^^^^^^^^^^^^
                            {'blue', 'white', 'red', 'yellow', 'grey', 'green'}
                            >>> eyes.issubset(colors)
                            True     ^^^^^^^^
                            >>> hairs.issubset(colors)
                            True      ^^^^^^^^
                            >>> colors.issuperset(eyes)
                            True       ^^^^^^^^^^
                            >>> colors.isdisjoint(some_strings)
                            True       ^^^^^^^^^^

________________________________________
PROTOCOLS                  (like the interfaces)
                           set of operations that a type must support.

                              must support                                     str    list   dict   range  tuple  set    bytes
        ________________________________________________________________________________________________________________________
        Container             item in     container                          |  Y   |  Y   |  Y   |  Y   |  Y   |  Y   |  Y   |
                              item not in container                          |      |      |      |      |      |      |      |
                                                                             |      |      |      |      |      |      |      |
        Sized                 len(..)                                        |  Y   |  Y   |  Y   |  Y   |  Y   |  Y   |  Y   |
                                                                             |      |      |      |      |      |      |      |
        Iterable              for item in iterable                           |  Y   |  Y   |  Y   |  Y   |  Y   |  Y   |  Y   |
                                                                             |      |      |      |      |      |      |      |
        Sequence              item = sequence[integer]                       |  Y   |  Y   |      |  Y   |  Y   |      |  Y   |
                              i    = sequence.index(item)                    |      |      |      |      |      |      |      |
                              c    = sequence.count(item)                    |      |      |      |      |      |      |      |
                              r    = reversed (sequence)                     |      |      |      |      |      |      |      |
                                                                             |      |      |      |      |      |      |      |
                              must also be Container / Sized / iterable      |      |      |      |      |      |      |      |
                                                                             |      |      |      |      |      |      |      |
        Mutable Sequence                                                     |      |  Y   |      |      |      |      |      |
        Mutable Set                                                          |      |      |      |      |      |  Y   |      |
        Mutable Mapping                                                      |      |      |  Y   |      |      |      |      |
                                                                             |      |      |      |      |      |      |      |
________________________________________
EXCEPTIONS
           The built-in exceptions are:

                            BaseException
                             +-- SystemExit
                             +-- KeyboardInterrupt
                             +-- GeneratorExit
                             +-- Exception
                                  +-- StopIteration
                                  +-- StopAsyncIteration
                                  +-- ArithmeticError
                                  |    +-- FloatingPointError
                                  |    +-- OverflowError
                                  |    +-- ZeroDivisionError
                                  +-- AssertionError
                                  +-- AttributeError
                                  +-- BufferError
                                  +-- EOFError
                                  +-- ImportError
                                  |    +-- ModuleNotFoundError
                                  +-- LookupError
                                  |    +-- IndexError
                                  |    +-- KeyError  <------------------- ex access a hash with a key which doesn't exist
                                  +-- MemoryError                            try:
                                  +-- NameError               (*)                ..
                                  |    +-- UnboundLocalError                 except KeyError:
                                  +-- OSError                                    ..
                                  |    +-- BlockingIOError
                                  |    +-- ChildProcessError
                                  |    +-- ConnectionError
                                  |    |    +-- BrokenPipeError
                                  |    |    +-- ConnectionAbortedError
                                  |    |    +-- ConnectionRefusedError
                                  |    |    +-- ConnectionResetError
                                  |    +-- FileExistsError
                                  |    +-- FileNotFoundError
                                  |    +-- InterruptedError
                                  |    +-- IsADirectoryError
                                  |    +-- NotADirectoryError
                                  |    +-- PermissionError
                                  |    +-- ProcessLookupError                                 (*) these kind of very high level errors
                                  |    +-- TimeoutError                                           (i.e. a syntax errors just means there are typos in the file
                                  +-- ReferenceError                                                    so they are expected to be found during the very first test)
                                  +-- RuntimeError                                                should never be caught
                                  |    +-- NotImplementedError
                                  |    +-- RecursionError
                                  +-- SyntaxError             (*)
                                  |    +-- IndentationError   (*)
                                  |         +-- TabError
                                  +-- SystemError
                                  +-- TypeError
                                  +-- ValueError
                                  |    +-- UnicodeError
                                  |         +-- UnicodeDecodeError
                                  |         +-- UnicodeEncodeError
                                  |         +-- UnicodeTranslateError
                                  +-- Warning
                                       +-- DeprecationWarning
                                       +-- PendingDeprecationWarning
                                       +-- RuntimeWarning
                                       +-- SyntaxWarning
                                       +-- UserWarning
                                       +-- FutureWarning
                                       +-- ImportWarning
                                       +-- UnicodeWarning
                                       +-- BytesWarning
                                       +-- EncodingWarning
                                       +-- ResourceWarning
        _____________________
        syntax

          try                                               try
              ..                                                ..
          except TypeError:             group               except (TypeError, KeyError, ValueError):       except (TypeError, KeyError, ValueError) as e:
              ..                  <---     +    --->            ..                                              print(f"{e!r}"                       ^^^^
          except KeyError:               exp.                                                                            |                   like an alias
              ..                                                                                                         |____________________________|
          except ValueError:



          finally:
             ..



        _____________________
        raise              to raise an exception.

                   raise   Without args:  raise
                           it forwards the same exception received (so without args it's expected to stay inside the block of 'except':
                                                             except ....:
                                                                 ..
                                                                 raise
                                                            )
                   raise eeeeee   (ex 'raise ValueError('some error happened here')') the exception specified is triggered.

        _____________________
        LBYL vs EAFP            LBYL: Look before you leap  (standard in C/Perl/... this way I list/manage a lot of error cases
                                                                                                           and I must forward errors and the caller check
                                                                                                           the return values)
                                EAFP: Easier to ask forgiviness than permission (this is the python way. I focus only on the sunny day
                                      and I intercept any error in the exception block)
                    try:
                              process_file(f)    <---------- I don't list/manage all possible errors (file non found/ file is a dir/ file content wrong ....
                    except OSError as e:           <-------- I just trap them all here.
                              print (f'Error: {e}')

        _____________________
        example   (importing/doing things     differently)

                    try:
                          import mod1       (ex we are on Windows)

                          ..
                    except ImportError:
                          import mod2       (we are on Linux)
                          ..

________________________________________
ITERATABLEs & ITERATORs

        COMPREHENSIONS  (they are the map / grep in Perl)

                    ITERATABLE:


                    ITERATOR:

________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________

