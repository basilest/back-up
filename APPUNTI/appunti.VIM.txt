------------------------------------------------------ copy to the clipboard
if the clipboard support is on:
    vim --version | grep clipboard
then I can select some text (ex. mouse or 'v' ...)
then
      "+y
now it's in the system's clipboard.

------------------------------------------------------ vimdiff excluding spaces / blanks
        set diffopt+=iwhite       <---- in ~/.vimrc
                                        or from command line:   vimdiff -c 'set diffopt+=iwhite' ...


                          To have vimdiff ignore whitespace while
                          normal vim doesn't, simply put this into your .vimrc:

                                        if &diff
                                            " diff mode
                                            set diffopt+=iwhite
                                        endif

------------------------------------------------------ refresh not working highlight

If VI doesn't paint the whole page when syntax constructs go back too far:
see
                  ":help :syn-sync".

There are 4 possibilities described there.
The only foolproof one, but also the slowest, is
                  ":syn sync fromstart"

which will backtrack from the start of the file
in order to determine how to highlight
the text visible in the current window.

:verbose setlocal syntax? filetype?        <---- this will show what is in use
                                                 (ex it shows that a bash file is instead
ex.                                               displayed as ft=conf)
    syntax=conf
    Last set from /usr/local/share/vim/vim81/syntax/syntax.vim line 32
    filetype=conf
------------------------------------------------------ Plug 'majutsushi/tagbar'
               To have with F8 a right-hand-side panel

               with the list of functions / variable / ... of the current file

               nmap <F8> :TagbarToggle<CR>
------------------------------------------------------ Plug 'wincent/command-t'
               to have files proposed as I type  (with fuzzy logic)

               <leader>t  (i.e. in my case ",t") to open the panel
               trl-s to open selected as H-split
               Ctrl-v to open selected as V-split
               Ctrl-t to open selected in new tab
------------------------------------------------------ ctags


           .  install ctags  (ie. brew install ctags)

           .  the list of available languages is:   ctags --list-languages

           .  if a language is not available it can be added (writing
              the proper regex in ~/.ctags)
              ex.
                  for GO: I add in ~/.ctags (or I create if not present)

                            --langdef=Go
                            --langmap=Go:.go
                            --regex-Go=/func([ \t]+\([^)]+\))?[ \t]+([a-zA-Z0-9_]+)/\2/d,func/
                            --regex-Go=/var[ \t]+([a-zA-Z_][a-zA-Z0-9_]+)/\1/d,var/
                            --regex-Go=/type[ \t]+([a-zA-Z_][a-zA-Z0-9_]+)/\1/d,type/

           .  In the project root-dir I run:  ctags -R .
              it will create a file ./tags

           .  In VI I add in ~/.vimrc the line
                          set tags=tags       <--- that will base on the current tags file every time




            vi −t tag     Start vi and position the cursor at the file and line where "tag" is defined.
            :ta tag       Find a tag.
            Ctrl-]        Find the tag under the cursor.
            Ctrl-t        Return to previous location before jump to tag (not widely implemented).

------------------------------------------------------ ctags
   _______________________________  F O R M A T T I N G

    :GoFmt              not necessary as it works by default on every save

   _______________________________  C O M P I L I N G

    :GoRun %         run the opened file
    :GoBuild

   _______________________________  E R R O R S   M O V I N G

   cnext and :cprevious    to jump to next previous compiling errors   (for info in quickfix panel)
   lnext                   to jump around from other (not quickfix) panels

   et g:go_list_type = "quickfix"         to have all messages from any panel, always in quickfix panel
                                          (so I can always use only :next :cprevious)

   _______________________________  T E S T

    :GoTest                   runs the test (this command is launched from inside both the  *_test.go file or from any other source .go of the same dir)
    :GoTestFunc               tests only the function under cursor (ex. TestBar)

    :GoTestCompile            checks compilation only for a Test file (maybe large file, so I don't want to wait for the test execution)

    :GoCoverage               reports coverage (showing lines green and red)
    :GoCoverageClear          resets lines colours
    :GoCoverageToggle         instead if calling in sequnce many times :GoCoverage / :GoCoverageClear

    :GoCoverageBrowse         beautifully opens directly the page in the browser

    let g:go_test_timeout = '15s'       set a timeout an waiting for Test ending (default is 10 sec)

   _______________________________  I M P O R T

    :GoImport strings         to add that import 'string' in the proper section
    :GoImport s... <tab>      <tab> autocompletes (looping through the matching values)
    :GoImports                call 'goimports' new version of gofmt

   _______________________________  F U N C T I O N   S E L E C T I O N

    if           select the body of the function --> dif delete, yif yank, vif visual, ...
    af           like <if> + also the function name line + any // comments line near the function
                 let g:go_textobj_include_function_doc = 0 <---- if I want to exclude the behaviour for the comments near the function


------------------------------------------------------ format json inside vim

:%!jq '.'
------------------------------------------------------ save vim sessions
:mksession ~/mysession.vim                       # save in that file

             to then load it:
                             1st way: :source ~/mysession.vim
                             2nd way: $ vim -S ~/mysession.vim
------------------------------------------------------
export TERM=xterm          if there are some errors like "Unknown terminal type"
                           the effect is otherwise a vi with 1 single line on screen
------------------------------------------------------
substitute something with a new line:  use \r
search for a new line : use \n

Contyrol-M

------------------------------------------------------
CtrlP - vim plugin

Note the the search provided by CtrlP is not a:
     find . -iname '*xxx*'

but is trimmed at N:
     find . -iname '*xxx*' | head -N

     (where N is the var [g:ctrlp_max_height]
      default N=10, I set to 70)

1. install with vundle
   a. add in .vimrc the line:   Plugin 'ctrlp.vim'
   b. :PluginUpdate

2. add these config in .vimrc
   a. set wildignore+=*/tmp/*,*.so,*.swp,*.zip
      (to exclude some files)
   b. let g:ctrlp_max_height=70

3. ^f: search in files (fuzzy logic in the FULL path)
   ^b: search in buffers
   ^d: search in files  (fuzzy logic in FILENAME only)

------------------------------------------------------ HELP

:set conceallevel=0              to avoid 'hidden' behaviour (ex hide the |bars| in help pages.

:hi link HelpBar Normal
:hi link HelpStar Normal


:set showmode                    to keep displaying the mode (Insert, Command, ...) while working


:help index                      to have all the commands
:help CTRL-A                     to have help on ^A (defaut is command-mode)
:help i_CTRL-A                   append the letter of the mode you want the help for that Ctrl
:help -t                         to have the help on vim command line options (here -t)
:help 'mouse'                    to have help on vim options (here mouse) ex help 'nu'
:help E37                        to have help for vim errors (here code E37)
:help xxxx + Tab                 like bash (...autocomplete)
:help xxxx + Ctrl-D              to have ALL the list of possible helps starting with xxxx
:helpgrep xxxx                   to search xxxx text INSIDE help pages. It will the jump to the 1'.
                                 I can then move between the helps as
                                      :cn         next match
                                      :cN         previous    (also :cprev)
                                      :cfirst     jump to 1st
                                      :clast      jumo to last
                                      :copen      jump to item under curson (like Ctrl-]
                                      :close      (like Ctrl-O, CTRl-T


------------------------------------------------------ GET VIM

UPDATE VIM & PLUGIN
If you have an old VIM version, then do this
1.  download the zip new version from vim.org
2.  unpack
3.  go to src dir
4.  edit Makefile uncommenting the line ‘prefix’ (a good vale could be “$HOME”)
5.  make (to compile)
6.  make install to have it in $HOME/bin
To install Vundle follow the instruction of Vundle GitHub repo/README. Anyhow they could not work
if linking at ~/.vim/bundle/ as written in the instructions.
A workaround is:
1.  link to ~/.vim/plugin/:
git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/plugin/Vundle.vim
also in .vimrc link to ~/.vim/plugin/:    set rtp+=~/.vim/plugin/Vundle.vim/
2.  execute from vi   :PluginInstall!, this will create again Vundle.vim but in ~/.vim/bundle/ and it is working, so you can rm -rf ~/.vim/plugin
3.  Add all the required plugin



------------------------------------------------------ ex
  enter ex:    :
               Q
               gQ
               vim -e
               vim -E   (extended ex)


  exit ex:     :vi     go back to vi

  p            print                       10p         # print line 10
  ,            (comma) range of lines:     10,30p

  :=           display TOT lines of file
  :.=             "    CURRENT line (also ^G)
  :/pattern/=  display FIRST found line with that pattern

  #            display specified lines     10,30p#     or only 10,30#
               ex :=

  d            delete                      :3,18d
  co   t       copy      (t  alias)        :23,29co100
  m            move                        :160,224m23

  .            current line
  $            last line                   1,$    is all the file
  %            any lines                   %d     delete all the file
                                           %t$    double the file (copy any line to the end)

               addresses can be
                 - absolute  (exact num of lines)
                 - relative (to the current line whose symbol is '.'):

  +n           for relative paths (to address n lines after)          :.,+20#      print following 20 lines
  -n                                          n lines before          :226,$m.-2   move 2 lines above, block 226-EOF
          N.B. if n = 1   can be used only + or - instead of +1  -1

  0     line 0 can be used to addrees before 1st line
        :-,+t0    move 3 linex at the beginning



  :/patter/d                     del 1st line with pattern
  :g/patter/d                    g means : in all the files --> del ALL lines with pattern
  :/patter/+d                    "   line following the 1st line with pattern
  :/pattern1/,/pattern2/d

       N.B.      in  vi    d/pattern        del from CURSOR till char before 1st pattern (leaving rest of both lines)
                 in  ex    :.,/pattern/d    del fully both lines (regardless cursor and /pattern/ position in the line)


  ;              (';' semicolon) instead of (',' comma) allows to
                 specify RANGE where the right bound is relative to left bound

                 ex    100,+5    doesn't work as expected as it says range from
                                 line 100 to +5 lines after CURRENT
                       100;+5    says properly: range from line 100 to 100+5
                                 (even if I run it from line 7)

 g/pattern       move me to the LAST occur. of pattern

 g!              NEGATE the search

 |               separate more ex cmds (like normally ';' does)
------------------------------------------------------ to get info from the bash


let @a=system("ls") to do the same, with 2 commands
"ap                 nb however that with this way instead the line below (p)
                    it can be above P

:r !ls              to insert the output of a bash cmd in the line below
:.!ls               to replace the current line with output ...
                    nb. the keysequence !$ is a shorthand for :.!
                    nb. the keysequence !! "       "         "
                        if you write a command in a line (or that line is already a command)
                        ex 'ls' or 'date' or even do it now on the following line:
                              ls -lt | awk '{print $9}' | sort
                        executing !$sh or !!sh  substitute that line
                        with the output of the command

                    nb. '.' (current line) is a special case of the general form
                        :range! where there is a range of lines, ex:
                                        :10,85!sort
                                        :%!sort

                    nb. like 5dd delete 5 lines, the same works for !!
                                    5!!sh
                                    5!!cmd

                    nb. :%!xxd     switch into binary editor
                                   (be careful that a save can damage the file if vi was
                                    not start as vi -b
                                    (which can anyhow specify now with   :set binary)
                        :%!xxd -r    rever to ascii

insert num of line in a substitution pattern match:
              :%s/----------- ok 1/\=line(".")/
              :%s/^/\=line(".")/                 <--- just add lines in front of each line


------------------------------------------------------ debug vim

--startuptime       is the option to debug vim. It works like this
                    1/2     vim --startuptime log.txt pippo.pm    # open pippo.pm logging all into file log.txt
                    2/2     :tabe log,txt                         # show log.txt

------------------------------------------------------ In Insert Mode
  :scriptnames         I see all the .vim (as also my .vimrc) that vim reads at the moment
  :set wm=10           wrapmargin
  :set hlsearch        higlight  serach
  :set relativenumber  lines num are set relative +/- to current
  :set ruler           show stat bar
                       CTRL-G                   shows stat:    "practice" line 3 of 6 --50%--

  Vim modes:           to see on status bar  which is running mode:   :set showmode (is usually already SET)
                       - Normal
                       . Insert

  u                    undo
  U                    undo on last line only
  C-R                  redo
  ------------------------------------- moving
  w                    START of next word
  e                    END   of this word

  b                    START of prev word
  ge                   END   of prev word

  W   E                skip  punctuation
  B   gE               skip  punctuation

  ^                    1st (not blank) char of a line
  _                              idem
  $                    end of line (including \n)
  g_                   end of line (without   \n)
  n|                   move at column n

  ENTER                1st char of next line
  +                     "    "      "    "
  -                               previous

  number $             end of next num lines     2$       (the same cannot work for 0 to go at prev lines
                                                           as number 0   cannot understand 0 is out)

  f t                  to serach on the same line  (to: 'to'  stop 1 char before)
  F T                  to serach on the same line  (back)

  %                    brackets
  number %             move at the percentage (line) of file (50%)
   |----------------------------------------------------- move cursor
   |
   |  20G              goto line 20   / :20
   |
   |  z ENTER          the line with the cursor goes  at top
   |  z -                                             at middle
   |  z +                                             at bottom
   |
   |  200z ENTER       line n.200 at top
   |
   |  10H              10' line after  High screen line
   |  10L              10' line before Low  screen line
   |
   |  (    )           move between sentences     N.B. possible usage with them
   |  {    }                        parag.             ex 2y}    copy 2 parag. ahead.
   |  [[   ]]                       sections
   |
   |  i(               select text inside ( braces     ex di(      delete text inside
   |  i[
   |  i{
   |
  ------------------------------------- moving

   ^B    Back    1 page
   ^F    Forward 1 page
   ^U    Half Up
   ^D    Half Down
   ^E    Scroll up
   ^Y    Scroll down

  ------------------------------------- serach / ?

  *     forward on cursor word
  #     back         idem

  N.B. 3*     go forw. for 3rd instance of cursor word.

  N.B. posible usage:
       d?stefano
       delete from where is the cursor back to 1 word stefano
  ____________________
  |  ``     (back-ap-)   move me back where I was   (a last edit or also only a find, which moved me out of there)
  |  ''                  the same, but move at that line, but also at the beginning of line.
  |
  |  ^O  move back
  |  ^I  move forw.
  |____________________________________ to see the list of marked-jumps:  :jumps

  ____________________
  |   ma    26 letters vi / vim also other 26: CAPITAL
  |  `a     move to bookmark a (at old column)
  |  'a     the same  (begin of line)
  |   "     cursor position  when last editing a file
  |   [     start of last change
  |   ]     end         idem
  |____________________________________ to see the list of marks:         :marks


------------------------------------------------------ In Insert Mode
C-R0       Paste REGISTER 0
C-W        delete current word
C-U        delete all the line
C-arrows   move
C-O        write a command while in Insert mode
C-A  C-@   redo the last input written in insert mode (C-@ then exit Insert mode)
------------------------------------------------------ ex


R                        start overwriting
yl yh                    NOT very useful: still is the way to yank 1 char (current / before)

------------------------------------------------------ buffer (here they are intended as registries)

               The are 9 DELETION (& YANKING)  BUFFERS for 'LINES' <----------- !!!!!!
               Words, or a portion of a line, are not saved in a buffer

               ex   "3p   :    print the content of buffer 3

               So remember that DELETE (d) and YANK (y) use the same buffer

:reg           to see all the registry (easy and powerfull way)
               second way:
"1pu.u.u ecc   to see all the buffers one after the other and found the right one

               The 9 buffers are said 'unnamed'.
               Using letters the buffers become other 26  (named buffers)
               Capital letters are not other 26 buffers, but they are used to
               'append' to what is already present in buffer 'lowercase'

               "d7yy    copy 7 linex to buffer named d
               "D0      append in buffer d from cursor back to start of line



------------------------------------------------------ open
vi +         f    open and go to bottom file f        | According to the POSIX standard,
vi +10       f             go to line 10              | vi should use -c command instead of +command
vi +/xxxxxxx f             go to 1st occ. of xxxxx    | For backward compatibility, both versions are accepted.


---------------------------- INSANE EDITING
   function! FreemindToTextFunction()
         silent!  set ft=
         silent!  set tw=80
         silent!  %s/^\(\s*\).*TEXT="\([^"]*\)".*$/\1- \2/
         silent!  v/^\s*-/d
         silent!  %s/&apos;/'/g
         silent!  %s/&quot;/"/g
         silent!  normal gggqG
         silent!  g/^-/s/- //
         silent!  g/^\w/t.|s/./=/g
         silent!  %s/^\s\{4}//
         silent!  %s/^-/o/
         silent!  g/^s*-/normal 0
         silent!  %s/^\s\{8}\zs-/#/
         silent!  %s/^\s\{8}\zs-/#/
    endfunction
----------------------------
:echo   "Hello, world!"
:echom  "Hello, world!"    <-- persistent
:messages                  <-- only see echom messages, the others are gone

          N.B. :echo  "foo\nbar"     print 2 lines (\n)
               :echom "foo\nbar"     print foo^@bar   (echom prints the 'exact' characters of the string
                                                       ^@ is Vim's way of saying \n)


          "                          <--- " is to start COMMENT
          !                          <-- to set a var at the opposite current value
                                         ex. set number or set nu
                                             set nonumber or set nonu change it back
                                             but I could do :set number!  (:set nu!)
          ?                          <-- to watch the current value  (:set nu? )
          :set numberwidth=4         <-- set the width of the left col for number-lines.
          :set relativenumber        <-- num lines are counted relative respect my position
          :set matchtime=5           <-- tens of seconds to show matching ( [ {

          :set nu  matchtime=3       <-- I can set more options with only 1 set command.


:map ...  oooo             ... can be a symbol (ex -) or specail char (<space> <c-d> for control d)
                           ooo can be anythig  ex. :map <space> viw   (select a word pressing space)

:q

          ex :map <F2> i bla bla bla <ESC>  :r date "+\%x" <ESC> kJ
                       ^               ^    ^
                       enter          exit  enter cmd mode
                       insert         insert
                       mode           mode


          :nmap   for normal mode       ex. :nmap \ dd     delete a line whene pressing \
          :vmap       visual                :vmap \ U      UPPERCASE the selection when pressing \
          :imap       insert                :imap <c-d> <esc>ddi  delete a line when pressing Ctrl-C
                                                                  N.B. with esc I exit 'insert' and go to 'normal'
                                                                       withoud esc I would have 2 char 'd written

          N.B. the opposite:  unmap       :unmap <space>
                             nunmap
                             vunmap       :vunmap \
                             iunmap


          One downside of the *map commands is the danger of recursing:
                     :nmap dd O<esc>jddk     <--- here the second dd enter an infinte loop

          SO TO AVOID RECURSION TROUBLE, ABOVE ALL IT COULD HAPPEN WHEN INSTALLING PLUGINS
          N E V E R  USE THE *MAP VERSIONS. ALWAYS USE THE 'NO'-'RE'CURSION VERSION: 'NORE'

                         noremap
                        nnoremap
                        vnoremap
                        inoremap

          To avodi to shadow a key with map, just choose only 1 key for all my mappings,
          and always use it plus others (ex. '-'  :nnoremap -d dd   :nnoremap -c 0Di)
          Vim calls it <leader> and  you can set it, and then refer to it, like the following:

                 :let mapleader = ","
                 :nnoremap <leader>d dd

                 :nnoremap <leader>ev :split  $MYVIMRC<cr>     now 'ev carriage-retun (ENTER) open .vimrc
                 :nnoremap <leader>sv :source $MYVIMRC<cr>     to make changes in .vimrc active sourcing it

          There is also a <localleader>  that 'lives' only inside its file (ex. .html, .java, .txt)

                 :let maplocalleader = "\\"

 <buffer>      :nnoremap <buffer> <leader>x dd    <buffer> keyword means that the mapping acts only
                                                  in this file. If I change file (buffer) it's not present.

               N.B. A local mapping hides more general ones
                    (ex. :nnoremap  Q dd
                         :nnoremap <buffer> Q x <--- this hides the above)

 :setlocal     Set only in that buffer. So in another files I can set that var in other ways
               (ex. in 1 file, :setlocal nu     in a 2nd file  :setlocal nonu)
               N.B. Not all the var has a setlocal possibility





:iabbrev ... ooo                    I can set an alias that when in insert mode, as soon as I type the word
                                    ... vim on the fly changes it to ooo.
                                    It's not exactly like map with 'inoremap' as with inoremap that change
                                    would occur as soon as the sequence ... occurs. While with iabbrev
                                    the change occurs only if ... is a detached word.

                                    ex. :iabbrev @@  basile.stef@gmail.com

                                    with <buffer> it's local to the buffer when I run the cmd
                                    :iabbrev <buffer> @@  basile.stef@gmail.com




autocommand:       With this feature vim can execute command when some events occurs, addressing for ex.
                   also the filetype o whatever else.

                   The general form is:

                       :autocmd BufNewFile * :write
                                ^          ^ ^
                                |          | |
                                |          | The command to run.
                                |          |
                                |          A "pattern" to filter the event.
                                |
                                The "event" to watch for.

                    . :help autocmd-events     list all possible events.
                    . ex:
                           :autocmd BufNewFile * :write                  this save a file as soon as created (like touch)
                           :autocmd BufNewFile *.txt :write              this only for .txt
                           :autocmd BufWritePre *.html :normal gg=G      this indent .html fils before saving
                           :autocmd BufWritePre,BufRead *.html :normal gg=G    here how to add 2 events with ','
                           :autocmd BufNewFile,BufRead *.html setlocal nowrap  here set nowrap only in .html

                           the following map the same <localleader>c to comment with correct syntax
                           javascript and python

                           :autocmd FileType javascript nnoremap <buffer> <localleader>c I//<esc>
                           :autocmd FileType python     nnoremap <buffer> <localleader>c I#<esc>

                           :filetype :filet  on  activate vim to detect filetype

                    :augroup / autocmd!
                           The problem with autcommands is that if I gave the same n-times (just
                           sourcing .vimrc n-times) vim has n autoc. equals, executing each n-times.
                           The soltion is in 2 steps.
                              1st step:
                              as name-scoping, include each autoc. in a block:

                              :augroup xxxxxx            xxxxx is a name I choose for this group of cmd
                              :   autocmd .....          here put all my autcmd
                       (1)    :   autocmd .....
                              :augroup END

                              the 2nd step is init the block with the autocmd!  (to clear this block)
                       (2)    :augroup xxxxxx
                              :   autocmd!   <--------
                              :   autocmd .....
                              :augroup END

                              without autocmd! if I would written again the same block (1) I would have it
                              double size, having all the cmd repeated.




           (number)(command)(text)      <----- text is a MOVEMENT command
                                               think that power on a command like
                                               y?stefano     copy from cursor, back to 1st occurrence of 'stefano'
                                               dn            delete up to next search  !!!!!!!!

 operator-pending      I can map a movement to some keys so that when I type a command ex. c
   (:onoremap)         and my mapped sequence than the effect is to have the command operating on my selection

                       The block of text on which vim will operate is:

                          1. if I used VISUAL to define a selection it will operate on that
                          2. otherwise FROM where is the cursor (START point) till where I stop moving (END point)

                       So the visual way 1. allows to chose a different START than where is the cursor

                       ex.  :onoremap p i(       dp will then delete text inside (
                            :onoremap p 4w       cp will then change from where I am till 4 words ahead
                            :onoremap p vw       dp will then delete the following word (having selected with 'v')
                            :onoremap in( :<c-u>normal! f(vi(<cr>
                                            ^     ^      ^^ ^  ^
                                            |     |      || |  |__ <cr> ends the normal!
                                            |     |      || |______i(   select inside ()
                                            |     |      ||________v    visual
                                            |     |      |________ go with cursor to 1st (
                                            |     |_______________ think entering normal mode
                                            |_____________________ <c-u> this will work on ALL the file


                       :onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>
                                            ^                ^  ^   ^      ^       ^
                                            |                |  |   |      |       |_ 1 line+visual+end line
                                            |                |  |   |      |__________set search hilight OFF
                                            |                |  |   |_________________\r means <c-r>
                                            |                |  |_____________________\\ escape '\'
                                            |                |________________________serach back a line with only '='
                                            |_________________________________________execute that string ""

:help statusline     to see all the options availbale. Most common are:
                     :set statusline=%f
                     :set statusline=%f\ -\ FileType:\ %y     N.B. the excaped spaces as set allow more set on the same cmd
                                                                   we could have set it like:

                                                             :set statusline=%f         " Path to the file
                                                             :set statusline+=\ -\      " Separator
                                                             :set statusline+=FileType: " Label
                                                             :set statusline+=%y        " Filetype of the file

                     %l        current line
                     %L        TOT file lines
                     %4xxxx    print the xxxx option in a num with of 4 chars  (align right)
                     %-4xxx                         idem                       (align left)
                     %F        absolute pathname
                     %.20xxx   print xxx option truncating it if exceeds 20 chars woidth
                     %=        align all the following options to the right of the statusline


:setlocal foldmethod=marke     once this command is submitted, any text block rounded by this special syntax
                               " bla bla bla ... commente ... bla bla bla ... {{{
                                   block of text
                               "}}}            will be open/close like Eclips fashion with cmd:  za

                               to have it working only on .vim filetypes, add:
                                 :autocmd FileType vim setlocal foldmethod=marker



----------------------------------------------- Variables

             M Y     V a r               V I M    O p t i o n s   (&)

             :let foo = "bar"        |   :set nowrap
             :echo foo               |   :echo &wrap  --> 0  N.B. '&' so VIM access its option instead of
                                     |                       a possible my var with the same name
             :let foo = 42           |
             :echo foo               |   :set wrap
                                     |   :echo &wrap  --> 1


             N.B.  Vim Options can be then also set with 'let'  :let &textwidth = 100
                   It's not visible, this new power from there
                   (as you could have used the shorter :set textwidth = 100)
                   but you can see when relying on power of var-usage as:
                                                       :let &textwidth = &textwidth + 10

                   let &wrap = 0            ok = 0
                   let &wrap = 1            ok = 1
                   let &wrap = 458          ok = 1
                   let &wrap = "0"          ok = 0
                   let &wrap = "1"          ok = 1
                   let &wrap = "56"         ok = 1
                   let &wrap = "56adf"      ok = 1
                   let &wrap = "a56"               NOT OK
                   let &wrap = "etyqwy"            NOT OK

                   The above example depicts like VIM manage Strings
                   "Evfmmmf"  is not considered TRUE (or 1) so neither "a10". They are both FALSE or 0
                   while "1"   "1a"  "342shdfhs"    are all TRUE

l:  b:          'l:' and 'b' prefix means local and   :let &l:xxx = ...      :let &b:xxx =
                  instead of                          :let &xxx   = ...      :let &xxx   =
                  set var xxx only for that buffer
                  There are other char besides 'l' and 'b' to define the 'scope' of a var:   :help internal-variables

@             registers can be reference as variables the syntax is:

              echo @a       echo register a
              echo @"       echo default unnamed reg. (called ") where y and d text goes
              echo @/       echo the text stored in the last find (so the current if a write 'n'

              :let @a = "hello!"   "move text in register a"

----------------------------------------------- Cmd and Conditions

|             pipe allow to put on 1 line more commands   :echom "foo" | echom "bar"

if            the syntax is
              :if 0
              :    echom "if"
              :elseif "nope!"
              :    echom "elseif"
              :else
              :    echom "finally!"
              :endif

==            :if 10 == 11                FALSE
==?           :if 10 == 10          TRUE
==#           :if "foo" == "bar"          FALSE
              :if "foo" == "FOO"     (1)   (2)              (1) if :set   ignorecase
                                                            (2) if :set noignorecase

                           SO IT'S DANGEROUS USE == AS YOUR PLUGIN WOULD NOT WORK EVERYWHERE
                           DEPENDING OF RUNNING VIM SETTINGS (:set ignorecase)
                           ==?  compares always takeing into considerations case
                           ==#  compares regardless case

                           TRY TO ALWAYS USE ==?  (it also work on numbers!!!)

           The same applies fot > <    ># >?

----------------------------------------------- Function
definition:     A L W A Y S   begin the name with UPPERCASE: otherwise Vim put you out of scope

                          1 way           |          another way
                                          |
                      :function Meow()    |     :function GetMeow()
                      :  echom "Meow!"    |     :  return "Meow String!"
                      :endfunction        |     :endfunction
                                          |
call it:              call Meow()         |     :echom GetMeow()    N.B. withuut echom, it doesn't display anything.
                                                                         The return value is thrown away

return 0              if a function doesn't return a value,
                      it implicitly returns 0. Let's use this to our advantage.

                            :function TextwidthIsTooWide()
                            :  if &l:textwidth ># 80
                            :    return 1
                            :  endif
                            :endfunction

arguments
                      :function DisplayName(name)
                      :  echom "Hello!  My name is:"
                      :  echom a:name                <--- N.B. the scope is a:  it's an argument
                      :endfunction


                      :function AssignGood(foo)
                      :  let foo_tmp = a:foo         <--- local var
                      :  let foo_tmp = "Yep"
                      :  echom foo_tmp
                      :endfunction

variable  args
                      :function Varg2(foo, ...)
                      :  echom a:foo   <--- a
                      :  echom a:0     <--- 2  (numof var args: b c)
                      :  echom a:1     <--- b
                      :  echo a:000    <--- a:000 is the list of exceeding args (here c)
                      :endfunction


                      :call Varg2  ("a", "b", "c")


numbers
                      :echom 100
                      :echom 0xff
                      :echom 017       ocatl -> 15 decimal
                      :echom 019       19 !!!! N.B. 019 cannot be octat (there is 9)
                      :echo 100.1
                      :echo 15.45e-2
                      :echo 3 / 2      1!   trunct
                      :echo 3 / 2.0    1.5


Strings
                      :echom "Hello, " . "world"   Concatenation
                      :echom 10 . "foo"            string 10foo  (int converted in String)
                      :echom 10.1 . "foo"          error: Float cannot be converted to String
                      :echom "Hello, " + "world"   '0'  (+ is a numeric operator)
                      :echom "3 mice" + "2 cats"   '5'
                      :echom 10 + "10.10"          20  (String are converted only to int)

                      :echom '\n\\'        when is used ' instead of ", the String is LITERAL so
                                           here we have literally \n\\
                                           The ONLY exception is ' itself:

                                           :echom 'That''s enough.' --> That's enough


Managing Strings
                      :echom strlen("foo")                3
                      :echom    len("foo"                 3
                      :echo split("one two three")        splits a String (default separator is <space>)into a 'List'
                      :echo split("one,two,three", ",")   specify a separator (,)
                      :echo join(["foo", "bar"], "...")   foo...bar
                      :echo join(split("foo bar"), ";")   foo;bar
                      :echom tolower("Foo")
                      :echom toupper("Foo")

Execute                evaluate a string as if it was a Vim command.


times in msec
 clock   self+sourced   self:  sourced script
 clock   elapsed:              other lines

000.006  000.006: --- VIM STARTING ---
000.141  000.135: Allocated generic buffers
000.276  000.135: locale set
000.283  000.007: window checked
001.014  000.731: inits 1
001.022  000.008: parsing arguments
001.024  000.002: expanding arguments
001.040  000.016: shell init
001.522  000.482: Termcap init
001.573  000.051: inits 2
001.775  000.202: init highlight
002.302  000.366  000.366: sourcing /usr/share/vim/vim74/debian.vim
003.021  000.406  000.406: sourcing /usr/share/vim/vim74/syntax/syncolor.vim
003.272  000.760  000.354: sourcing /usr/share/vim/vim74/syntax/synload.vim
036.077  032.702  032.702: sourcing /usr/share/vim/vim74/filetype.vim
036.148  033.743  000.281: sourcing /usr/share/vim/vim74/syntax/syntax.vim
036.186  034.338  000.229: sourcing $VIM/vimrc
036.668  000.226  000.226: sourcing /usr/share/vim/vim74/syntax/syncolor.vim
037.270  000.456  000.456: sourcing /usr/share/vim/vim74/ftoff.vim
037.947  000.278  000.278: sourcing /home/stiv/.vim/bundle/Vundle.vim/autoload/vundle.vim
038.315  000.245  000.245: sourcing /home/stiv/.vim/bundle/Vundle.vim/autoload/vundle/config.vim
061.516  021.386  021.386: sourcing /usr/share/vim/vim74/filetype.vim
061.626  000.029  000.029: sourcing /usr/share/vim/vim74/ftplugin.vim
061.716  000.024  000.024: sourcing /usr/share/vim/vim74/indent.vim
061.836  000.007  000.007: sourcing /usr/share/vim/vim74/filetype.vim
061.904  000.005  000.005: sourcing /usr/share/vim/vim74/ftplugin.vim
061.968  000.005  000.005: sourcing /usr/share/vim/vim74/indent.vim
062.033  000.005  000.005: sourcing /usr/share/vim/vim74/filetype.vim
062.248  026.004  003.338: sourcing $HOME/.vimrc
062.253  000.136: sourcing vimrc file(s)
062.678  000.083  000.083: sourcing /home/stiv/.vim/bundle/nerdtree/autoload/nerdtree.vim
063.419  000.339  000.339: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/path.vim
063.538  000.082  000.082: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim
063.655  000.085  000.085: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim
063.758  000.069  000.069: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim
063.966  000.178  000.178: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim
064.236  000.236  000.236: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim
064.530  000.260  000.260: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim
064.710  000.147  000.147: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/opener.vim
064.895  000.153  000.153: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/creator.vim
064.955  000.029  000.029: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim
065.047  000.064  000.064: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim
065.351  000.273  000.273: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/ui.vim
065.398  000.012  000.012: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/event.vim
065.449  000.023  000.023: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim
065.788  000.304  000.304: sourcing /home/stiv/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim
075.045  000.067  000.067: sourcing /home/stiv/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim
075.330  000.268  000.268: sourcing /home/stiv/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim
075.459  013.127  010.455: sourcing /home/stiv/.vim/bundle/nerdtree/plugin/NERD_tree.vim
075.584  000.081  000.081: sourcing /home/stiv/.vim/bundle/lightline.vim/plugin/lightline.vim
075.788  000.078  000.078: sourcing /home/stiv/.vim/bundle/python-mode/autoload/pymode.vim
075.862  000.007  000.007: sourcing /usr/share/vim/vim74/filetype.vim
075.932  000.005  000.005: sourcing /usr/share/vim/vim74/ftplugin.vim
076.562  000.007  000.007: sourcing /usr/share/vim/vim74/filetype.vim
076.630  000.005  000.005: sourcing /usr/share/vim/vim74/ftplugin.vim
076.713  001.057  000.955: sourcing /home/stiv/.vim/bundle/python-mode/plugin/pymode.vim
076.922  000.058  000.058: sourcing /usr/share/vim/vim74/plugin/getscriptPlugin.vim
077.099  000.163  000.163: sourcing /usr/share/vim/vim74/plugin/gzip.vim
077.263  000.150  000.150: sourcing /usr/share/vim/vim74/plugin/matchparen.vim
077.630  000.352  000.352: sourcing /usr/share/vim/vim74/plugin/netrwPlugin.vim
077.670  000.009  000.009: sourcing /usr/share/vim/vim74/plugin/rrhelper.vim
077.711  000.025  000.025: sourcing /usr/share/vim/vim74/plugin/spellfile.vim
077.863  000.134  000.134: sourcing /usr/share/vim/vim74/plugin/tarPlugin.vim
077.955  000.072  000.072: sourcing /usr/share/vim/vim74/plugin/tohtml.vim
078.089  000.117  000.117: sourcing /usr/share/vim/vim74/plugin/vimballPlugin.vim
078.265  000.156  000.156: sourcing /usr/share/vim/vim74/plugin/zipPlugin.vim
078.587  000.230  000.230: sourcing /home/stiv/.vim/bundle/indentLine/after/plugin/indentLine.vim
078.618  000.634: loading plugins
078.625  000.007: inits 3
078.756  000.131: reading viminfo
078.774  000.018: setting raw mode
078.788  000.014: start termcap
078.809  000.021: clearing screen
079.370  000.246  000.246: sourcing /home/stiv/.vim/bundle/lightline.vim/autoload/lightline.vim
079.698  000.051  000.051: sourcing /home/stiv/.vim/bundle/lightline.vim/autoload/lightline/tab.vim
080.058  000.139  000.139: sourcing /home/stiv/.vim/bundle/lightline.vim/autoload/lightline/colorscheme.vim
080.481  000.673  000.534: sourcing /home/stiv/.vim/bundle/lightline.vim/autoload/lightline/colorscheme/wombat.vim
082.685  002.906: opening buffers
082.712  000.027: BufEnter autocommands
082.713  000.001: editing files in windows
082.804  000.091: VimEnter autocommands
082.804  000.000: before starting main loop
083.436  000.632: first screen update
083.437  000.001: --- VIM STARTED ---

------------------------------------------------------ TABs
     vim -p a.txt b.txt          open vim tabbed with 2 files
     vim -c :10  a.txt           open vim and the execute an 'ex cmd' (here goto line 10)
         -c :$   a.txt                goto last line
         -c /xxx a.txt                search for xxx

     :tabs    show the list
     gt       go to tab AFTER
     gT       go to tab BEFORE
     3gt      go to tab n.3
------------------------------------------------------ BUFFERS
:ol        (list (read only) the last 100 old opened files)
:bro ol    (browse old files)
           (I can then enter 'q' a number to open that file)

:ls        (list the opened buffers
            #the same are   :files   :buffers

------------------------------------------------------ COLOR
:color| |<Tab>   (:color+1 space+ 1 Tab)
            (shows all the available color schemes)
:color desert (set the color scheme to the scheme 'desert')
            (useful if vimdiff has crazy colors)
:hi         (shows the settings of the current color scheme)
------------------------------------------------------ SYNCRONISE 2 WINDOW
to have them scrolling together (like in vimdiff mode)
        :set scb        (start scrollbinding)
        :set noscb      (stop  scrollbinding)











http://www.guckes.net/vi/doc/vi.chart


$PRINT$ JDE=DOC,END;
################################################################################
                        V I   H E L P
################################################################################

SPF commands on left, VI commands on right.  NVI-specific noted by (NVI: ).
For SPF commands, equivalent TSO Edit keystroke commands noted in upper case
by [keyname], TSO Edit command line options noted by (=>commandname),
TSO Edit line commands noted by (commandname).

© Copyright (C) 1993, 1994, 1995, 1996 Jeff Wang.
You can do whatever you want with this file, just don't charge money for it :-)
--------------------------------------------------------------------------------

********************************************************************************
SPF FILE COMMAND        | VI/NVI FILE COMMANDS EQUIVALENT
********************************************************************************
edit file               | vi file
edit file at last line  | vi + file
edit file at line n     | vi +n file
edit file after running | vi +/pattern file
   a command first      |    <edit file at first "pattern" occurrence>
                        | vi +":!grep -n pattern %" file
                        |    <edit file after displaying all occurrences of
                        |     "pattern" with line numbers; vi +":g/pattern/p"
                        |     does the same, but does not list line numbers>
                        | vi +":g/pattern/d" file
                        |    <edit file after deleting all lines with "pattern">
edit another file       | :e file2  |  :edit file2
   [F2 SPLIT]           | :e +/pattern file2
                        |    <edit second file at first line of "pattern">
   [F9 SWAP]            | :e#  |  Ctrl-^
                        |    <toggle between two files; # is symbol for the
                        |     alternate file; % is symbol for current file; when
                        |     editing more than one file, all currently saved
                        |     options, maps, buffers, search patterns, and last
                        |     edit command (. or Ctrl-@) are retained>
edit multiple files     | vi file1 file2 file3 ...
                        |    <use :n to go to next file in list or use ':e file'
                        |     to go directly to named "file"; for ':e file', the
                        |     ':args' still reflects the previous file edited;
                        |     to return to previous file, use :e#)
                        | vi prog*
                        |    <edit all filenames beginning with "prog">
                        | vi `find . -type f -print`
                        |    <edit all files in current directory and in all
                        |     subdirectories>
                        | vi `find . -name *.c -print`
                        |    <edit all files in current directory and in all
                        |     subdirectories with filename that ends in ".c">
                        | vi `grep -l "pattern" *`
                        |    <edit all files in current directory with "pattern"
                        |     in its contents>
                        | vi `egrep -l "pattern1|pattern2|pattern3" *`
                        |    <edit all files in current directory with either
                        |     "pattern1", "pattern2", or "pattern3" in contents>
                        | :n  |  :next
                        |    <move to next file; if autowrite set, each file is
                        |     saved before moving to next file; if autowrite not
                        |     set, need to :w first, or use :n! to move to next
                        |     file without saving changes to current file>
                        | :n file4 file5
                        |    <edit new set of files; current file(s) is flushed
                        |     from edit buffer>
                        | :rew  |  :rewind
                        |    <rewind pointer to first file in list; use :rew! to
                        |     not save edits made to current file>
                        | :ar  |  :args
                        |    <display current set of files being edited>
edit file after system  | vi -r
   crash [=>RECOVER ON] |    <list edit files the system saved during crash>
                        | vi -r file
                        |    <edit buffer file recovered from edit abort>
browse file             | view file  |  vi -R file
                        |    <read-only mode; or use `more` to browse file>
save and exit [F3 END]  | ZZ  |  :x  |  :wq
save file  (=>SAVE)     | :w  |  :write
save part of the file   | :130,$w file2
                        |    <save line 130 to end of file as "file2">
                        | :'a,'bw file2
                        |    <save from line marked label `a' to line marked `b'
                        |     as "file2">
                        | :/pattern1/,/pattern2/w! file2
                        |    <save from line with "pattern1" to line with
                        |     "pattern2" to "file2"; w! overwrites "file2" if it
                        |     it previously existed>
append current file to  | :w >> file2
   another file         |    <append buffer contents to "file2">
save current file under | :w file2
   different filename   |    <save current file buffer as "file2"; current file
                        |     is not saved until you :w it>
                        | :w %.new
                        |    <save current file as "file.new">
                        | :w new%.ver3
                        |    <save current file as "newfile.ver3">
rename filename without | :f newfilename  |  :file newfilename
   modifying the        |    <ZZ saves "newfilename"; no change is made to the
   original file        |     original file prior to entering :f if you have not
                        |     saved it yet>
use vi to rename or     | mvi *.dat
   delete files         |    <edit the names of all files ending in ".dat"; upon
                        |     upon exit from /tmp file created, filenames which
                        |     were changed are renamed; filenames preceded with
                        |     "D " are deleted)
[=>CANCEL] edit session | :q!
   do not save changes  |
undo any changes made   | :e!
   since last save      |

********************************************************************************
SPF CURSOR MOVEMENT     | VI MOVEMENT EQUIVALENTS
********************************************************************************
MOVE BY CHARACTER       |
--------------------------------------------------------------------------------
left  arrow             | h  |  [LeftArrow]   |  Ctrl-H
right arrow             | l  |  [RightArrow]  |  [space bar]
up    arrow             | k  |  [UpArrow]     |  Ctrl-P
down  arrow             | j  |  [DownArrow]   |  Ctrl-J  |  Ctrl-N
input mode [BackSpace]  | [BackSpace]  |  Ctrl-H
--------------------------------------------------------------------------------
MOVE BY TEXT OBJECT     |
--------------------------------------------------------------------------------
move to new line        | [Return]  |  j  |  [DownArrow]  |  Ctrl-M
move forward one word   | w  |  W <move to start of next word>
   [Alt][RightArrow]    | e  |  E <move to end   of next word>
move backward one word  | b  |  B <move to start of previous word>
   [Alt][LeftArrow]     |
move backward one word  | Ctrl-W  <move backward over newly entered text on
   during input mode    |          current line to type over the words>
move backward to start  | Ctrl-U  <move backward to start of newly entered text
   of newly entered     |          on current line to type over it; if you press
   text in input mode   |          [Escape] after this, all new text is deleted>
move to beginning of    | )  <move to start of next     sentence>
   next or previous     | (  <move to start of previous sentence>
   sentence             |    <sentence is delimited by empty line or .?!
                        |     followed by at least 2 spaces>
move to beginning of    | }  <move to start of next     paragraph>
   next or previous     | {  <move to start of previous paragraph>
   paragraph            |    <paragraph is delimited by empty line or nroff and
                        |     troff paragraph macro)
move to beginning of    | ]] <move to start of next     section>
   next or previous     | [[ <move to start of previous section>
   section              |    <section is delimited by nroff and troff section
                        |     macros or each "{" character in a C program>
--------------------------------------------------------------------------------
MOVE BY LINE            |
--------------------------------------------------------------------------------
move to start of line   | 0  <move to extreme left margin of line>
move to end   of line   | $
move to first of line   | ^  <move to first character on line>
                        | +  <move to first character of next line>
                        | -  <move to first character of previous line>
                        | n_ <move to first character (n-1) lines lower>
[Tab] during text input | <Tab>   <tabs default to 8 spaces; ':set tabstop=n' to
                        |          set tabs n spaces>
                        | Ctrl-I  <like <Tab> key during text input mode>
                        | Ctrl-T  <like <Tab> when input at start of line>
back up a shiftwidth of | Ctrl-D  <useful if shiftwidth is set to tabstop; works
   tabs in input mode   |          only if autoindent is turned on)
disable autoindent in   | ^ Ctrl-D <start edit on column 1 in input mode, resume
   text input mode      |           autoindent on next line>
                        | 0 Ctrl-D <start edit on column 1 in input mode, do not
                        |           resume autoindent until a line is manually
                        |           indented again>
go to last line         | G   |  :$
go to first line        | 1G
go to line n            | nG  |  :n  <move to line "n">
go down n lines         | nj  |  n[DownArrow]
go up   n lines         | nk  |  n[UpArrow]
move to top of current  | H
  screen  <F12 CURSOR>  | nH <move cursor to "n" lines below top line>
move to middle line of  | M
  current screen        |
move to last   line of  | L
  current screen        | nL <move cursor to "n" lines above bottom line>
mark cursor position    | mx <mark cursor position with label, where `x' is
   with mark to use as  |     alphabetic character a-z>
   line address for ex  | `x <move cursor to the character marked by `x'>
   commands (can use to | 'x <move cursor to start of line marked `x'>
   move around quickly) | `` <return cursor to previous mark or context>
                        | '' <return cursor to start of line of previous mark or
                        |     context>
--------------------------------------------------------------------------------
MOVE BY COLUMN          |
--------------------------------------------------------------------------------
go to column n          | n| <move to column "n" of current line>
move n spaces to right  | nl  |  n[RightArrow]  |  n[space bar]
move n spaces to left   | nh  |  n[LeftArrow]
--------------------------------------------------------------------------------
MOVE BY SCREEN          |
--------------------------------------------------------------------------------
scroll up one full      | Ctrl-B
   screen  [F7 UP]      | nCtrl-B <scroll backward "n" full screenfuls>
scroll up half-screen   | Ctrl-U
   [F7 UP] HALF         | nCtrl-U
   [F7 UP] n            |    <set scroll length to n lines and scroll up; other
                        |     Ctrl-U's will also scroll "n" lines)
scroll down one full    | Ctrl-F
   screen  [F8 DOWN]    | nCtrl-F <scroll forward  "n" full screenfuls>
scroll down half-screen | Ctrl-D
   [F8 DOWN] HALF       | nCtrl-D
   [F8 DOWN] n          |    <set scroll length to "n" lines and scroll down;
                        |     other Ctrl-D's will also scroll "n" lines>
scroll up   1 line      | Ctrl-Y  <leaves cursor where it is, if possible>
scroll down 1 line      | Ctrl-E  <leaves cursor where it is, if possible>
scroll screen           | z [Return]  <scroll current line to top screen>
   [F7 F8] CSR          | z. <scroll current line to center of screen>
                        | z- <scroll current line to bottom of screen>
                        | z+ <scroll line to top    of     next page>
                        | z^ <scroll line to bottom of previous page>
                        | /pattern/z  |  /pattern/z.  |  /pattern/z-
                        |    <search forward for "pattern" and place the next
                        |     occurrence of "pattern" on the top, center, or
                        |     bottom of screen>
--------------------------------------------------------------------------------
MOVE BY FINDING TEXT    |
--------------------------------------------------------------------------------
find a pattern (=>FIND) | /pattern <search forward  for "pattern">
                        | ?pattern <search backward for "pattern">
find a word             | /\<word\>
                        |    <search forward for "word", omitting "word" that is
                        |     an embedded pattern of another word>
                        | ?\<[Kk][^ <tab>]*[aeiouAEIOU]\>
                        |    <search backward for any word that begins with "K"
                        |     or "k" and ends in a vowel>
repeat find             | n <repeat find in same     direction>
   (rFIND [F5])         | N <repeat find in opposite direction>
find pattern only if it | /pattern1/;/pattern2/;/pattern3/
   occurs after another |    <find "pattern3" only if it occurs after "pattern1"
   patterns             |     and "pattern2"; search fails if either "pattern2"
                        |     occurs before "pattern1" or "pattern3" is before
                        |     "pattern1" or "pattern2">
find nth occurrence of  | I<Esc>ni/pattern[Ctrl-V][Return][Esc]l"xd0@x
   pattern              |    <"n" is number of occurrences to search forward;
                        |     keystroke sequence outputs a stream of multiple
                        |     "/pattern^M" (^M is carriage return) that is
                        |     deleted to buffer "x" and executed by entering @x
                        |     from wherever the cursor is>
                        | A.<Esc>na?pattern[Ctrl-V][Return][Esc]F.x"xd$@x
                        |    <same as above command except it searches for nth
                        |     occurrence backwards>
find character on       | fc  <search forward for character "c">
   current line         | nfc <search forward for "n"th occurrence of "c">
                        | Fc  <search backward for character "c">
                        | nFc <search backard for "n"th occurrence of "c">
                        | tc  <search forward for the character before "c">
                        | Tc  <search backward for the character after "c">
repeat character find   | ;  <repeat find in same direction as last find)
                        | ,  <repeat find in the opposite direction)
find matching bracket   | %  <if cursor is placed on open bracket (, [, {, press
   in program code      |     % to move cursor to matching closing bracket of
                        |     ), ], }; the reverse also works>
display lines having    | :g/pattern/p
   pattern              |    <display all lines having "pattern">
                        | :g!/pattern/nu  |  :v/pattern/nu
                        |    <display all lines not having "pattern" along with
                        |     their line numbers>
                        | :v/^[A-Za-z0-9]/p
                        |    <display all lines not starting with alphanumerics>

********************************************************************************
SPF EDIT LINE COMMANDS  | VI EDIT EQUIVALENTS
********************************************************************************
INSERT TEXT             |
--------------------------------------------------------------------------------
insert text    [Insert] | i  <insert text before cursor>
                        | ni <duplicate "n" copies of what is inserted>
                        | a  <append text after cursor>
                        | na <duplicate "n" copies of what is appended>
insert at start of line | I  <insert text at beginning of line>
insert at end   of line | A  <append text at ending of line>
insert new line  (I)    | o  <open a new line below the current line>
                        | O  <open a new line above the current line>
text split       (TS)   | i [Return] [Escape]
insert non-printing     | Ctrl-V
   control characters   |    <quote the next non-printing character; quoting a
                        |     newline [Return] prints out ^M, <escape> prints ^[
                        |     to quote Ctrl-V itself, press Ctrl-V twice for ^V>
return to command mode  | Esc [F11]  |  Ctrl-[
--------------------------------------------------------------------------------
CHANGE TEXT             |
--------------------------------------------------------------------------------
replace text  [overlay] | R   <type over existing text starting at cursor>
                        | nR  <insert "n" copies of text that is input>
replace a character     | r   <replace the character the cursor is on; this
                        |      command leaves you in command mode>
                        | nr  <overlay n copies of replacement character>
change a word           | cw  <change a   word  starting at cursor>
                        | ncw <change "n" words starting at cursor>
change to end   of line | C   <change text from cursor to end   of line>
change to start of line | c0  <change text from cursor to start of line>
change to sentence end  | c)  <c( changes to start of sentence>
change range of columns | cn| <change from cursor to column "n">
change to character     | cf? <change from cursor to next "?" on line>
change to text pattern  | c/pattern  <change text from cursor to next occurrence
                        |             of "pattern">
                        | c?pattern  <change text from cursor to previous
                        |             occurrence of "pattern">
change a line           | cc  <blank out current line and go into input mode>
                        | S   <same as cc, but does not blank out current line>
change n lines          | ncc <change "n" consecutive lines>
change to end   of file | cG  <change from current line to end of file>
change to start of file | c1G <change from current line to first line>
substitute a character  | s   <replace a   character  with new text>
substitute n characters | ns  <replace "n" characters with new text>
change txt1 txt2        | :s/txt1/txt2/
   (=>CHANGE txt1 txt2) |    <change first "txt1" on line to "txt2">
                        | :s/txt1/txt2/g
                        |    <change all "txt1" on line to "txt2">
                        | :6,15s/txt1/txt2/
                        |    <change first "txt1" to "txt2" on lines 6 to 15>
                        | :%s/pattern1.*pattern2/txt/g
                        |    <change pattern of text that begins with "pattern1"
                        |     and ends with "pattern2" to "txt">
repeat change           | n & <n moves cursor to next occurrence of text; &
   (rCHANGE [F6])       |      changes next occurrence of text>
                        | :&  <repeat last ex substitution command>
                        | :&g <repeat last ex substitution command on current
                        |      line>
                        | :%&g <repeat last ex substitution command for all
                        |       lines in file>
change all txt1 txt2    | :%s/txt1/txt2/g
   (=>CHANGE ALL)       |    <change all "txt1" in file to "txt2">
                        | :%s/txt1/txt2/gc
                        |    <confirm each change by entering "y" at ^^^ prompt;
                        |     enter "n" or just press <Return> to negate; Ctrl-C
                        |     cancels further changes>
                        | :g/pattern/s/old/new/g
                        |    <globally change all "old" to "new" only on lines
                        |     where "pattern" occurs>
                        | :g!/pattern/s/old/new/g  |  :v/pattern/s/old/new/g
                        |    <globally change all "old" to "new" only on lines
                        |     where "pattern" does not occur>
regular expressions for | .    <match any single character except newline>
   search patterns      | *    <match zero or more of preceding character>
   (wildcard character) | .*   <match any number of any characters>
                        | ^txt <match "txt" only at start of line>
                        | txt$ <match "txt" only at end   of line>
                        | \    <escape the meaning of the special command
                        |       character that follows, such as . * ^ $ / \ ~>
                        | [ ]  <match any character enclosed in the brackets;
                        |       e.g., [A9] matches A or 9, [A-Z] matches A to Z,
                        |       [;:0-9&] matches ; : & and numbers 0-9, ^[aeiou]
                        |       matches any lowercase vowel at start of line,
                        |       [^aeiou] matches any character that is not a
                        |       vowel; to match \ - or ] within brackets, escape
                        |       their meaning by specifying \\ \- or \] )
                        | \(   <save pattern inside \( \) in 1 of 9 buffers;
                        | \)    recall buffer in replacement text using \n
                        |       :%s/\([0-9.]*\) *\([0-9.]*\)/\2    \1/
                        |       transposes two fields in a numeric file having
                        |       only numbers and decimals>
                        | \<   <match characters at start of word; e.g., \<un
                        |       matches words starting with "un">
                        | \>   <match characters at end of word; e.g., \>es
                        |       matches words ending with "es">
                        | ~    <match whatever was last used as search pattern;
                        |       if last search was on "XGrabKey", /~board will
                        |       will search for "XGrabKeyboard"; does not work
                        |       as a pattern in substitute command, may not work
                        |       on some vi's>
regular expressions for | \    <escape the meaning of the special command
   replacement patterns |       character that follows such as . or *>
   (wildcard character) | \n   <where n is 0 to 9, replace \n with corresponding
                        |       \( \) delimited search pattern; see \( \) above>
                        | &    <replace & with whatever was used as search
                        |       pattern; e.g., :%s/In/& fact/g will replace all
                        |       "In" with "In fact">
                        | \u   <\u changes next character in replacement to be
                        | \U    uppercase; \U changes all characters after it in
                        |       replacement string to uppercase unless separated
                        |       by \e or \E>
                        | \l   <\l changes next character in replacement to be
                        | \L    lowercase; \L changes all characters after it in
                        |       replacement string to lowercase unless separated
                        |       by \e or \E>
                        | ~    <replace search pattern with whatever was last
                        |       used as replacement pattern; if :s/He is/He was/
                        |       was substituted on a line, the next substitution
                        |       substitution command of :s/She saw/~/ changes
                        |       "She saw" also to "She was">
change case of letter   | ~    <toggles between upper and lower case>
invert case of word     | ywmno<Esc>P:s/[^ ]/\~/g<Return>0"nDdd`n@n
                        |    <ywmno yanks word, marking it as `n'; P:s/[^ ]/\~/g
                        |     puts word on next line and converts to lowercase;
                        |     0"nDdd deletes tilde'd characters to buffer "n"
                        |     deletes line; `n@n moves back to original word and
                        |     executes "n" buffer; this command changes "AbC" to
                        |     "aBc"; to include punctuation, use yWmno so "Ab.C"
                        |     changes to "aB.c">
invert case of line     | !!tr '[a-z][A-Z]' '[A-Z][a-z]'
                        | :s/\([a-z]*\)\([A-Z]*\)/\U\1\L\2/g
                        |    <either the tr or substitution will work>
change to uppercase     | :%s/.*/\U&/  <change entire file to uppercase>
   (=>UPCASE ALL)       | :/do:/,/end:go/s/.*/\U&/
                        |    <change all text between first occurrence of line
                        |     having "do:" to next line having pattern "end:go"
                        |     to uppercase>
                        | :?^$?,'bs/other/\u&/g
                        |    <change all occurrences of "other" from previous
                        |     empty line to line marked `b' to "Other">
change to lowercase     | :%s/.*/\L&/  <change entire file to lowercase>
   (=>LOWCASE ALL)      | :3,8s/IN EXAMPLE/\L&\e NUMBER/g
                        |    <change all "IN EXAMPLE" patterns in lines 3 to 8
                        |     to "in example NUMBER">
                        | :,'bs/Ex/\l&/g
                        |    <change all occurrences of "Ex" from current line
                        |     to line marked `b' to "ex">
--------------------------------------------------------------------------------
DELETE / MOVE TEXT      |
--------------------------------------------------------------------------------
delete a character      | x   <delete character at     cursor>
   [delete]             | X   <delete character before cursor>
delete n characters     | nx  <delete "n" characters after  cursor>
                        | nX  <delete "n" characters before cursor>
delete word             | dw  <delete a   word  starting at cursor>
   [Alt][delete]        | ndw <delete "n" words starting at cursor>
delete to end   of line | D   <delete from cursor to end   of line>
delete to start of line | d0  <delete from cursor to start of line>
delete to sentence end  | d)  <d( deletes to start of sentence>
delete range of columns | dn| <delete from cursor to column "n">
delete line        (D)  | dd  <delete current line>
delete n lines     (DD) | ndd <delete "n" consecutive lines; e.g., 4dd is same
                        |      as D4 in SPF Edit>
                        | d'a <delete from current line to line marked `a'>
                        | :/-/d <delete next line with a "-" in it>
delete to end   of file | dG  <delete from current line to end of file>
delete to start of file | d1G <delete from current line to first line>
delete to character     | df? <delete from cursor to next "?" on current line>
delete to text pattern  | d/pattern
                        |    <delete text from cursor to next "pattern">
                        | d?pattern
                        |    <delete text from cursor to previous "pattern">
                        | :%s/pattern1.*pattern2//g
                        |    <delete pattern of text that begins with "pattern1"
                        |     and ends with "pattern2">
delete block of text    | ma mb `ad`b
                        |    <to delete an arbitrary text block (instead of
                        |     complete lines), mark start of text with label `a'
                        |     and mark the character AFTER the last character to
                        |     delete with `b'; `ad`b deletes marked text block)
move line          (M)  | dd  (p  |  P)
                        |    <dd deletes line; p or P puts deleted line below or
                        |     above cursor; unless you delete to named buffer,
                        |     you must use p/P to put text back to another spot
                        |     before doing another dd or yy move/copy>
                        | :m$
                        |    <move current line to end of file>
block move n lines (MM) | ndd  (p  |  P)
                        |    <ndd deletes "n" lines; p pastes deleted lines
                        |     below cursor, P pastes the text above cursor; e.g.
                        |     4dd p is the same as M4 in SPF Edit)
                        | :'a,'bm.
                        |    <move from line marked "a" to line marked "b" after
                        |     current line)
delete to named buffer  | "andd
                        |    <"a" is one of 26 buffers named a-z; "n" is number
                        |     of lines to delete, default of 1 line>
                        | "Andd
                        |    <delete "n" lines, append it to buffer "a" content>
delete text block to    | ma mb `a"cd`b
   named buffer         |    <to delete an arbitrary text block (instead of
                        |     complete lines to named buffer, mark start of text
                        |     with label `a' and mark character AFTER the last
                        |     character to delete with `b'; `a"cd`b deletes the
                        |     marked text block to buffer "c">
paste deleted text from | "ap  |  "aP
   named buffer         |    <paste buffer "a" contents after or before current
                        |     line>
paste from delete       | "np  |  "nP
   buffer               |    <"n" is buffer number 1-9 storing past 9 deletions;
 (restore deleted text) |     last delete is saved in buffer 1; only works for
                        |     deleted lines, not deleted strings of text>
                        | "1pu.u.u.u.u.u.u.u.u
                        |    <step through the contents of all 9 delete buffers;
                        |     useful if you accidentally deleted text recently
                        |     that you want to get back; "u" undoes each delete
                        |     buffer restoration; "." puts contents of another
                        |     delete buffer below current line>
transpose two character | xp <swap character with following character>
transpose two words     | dwwP <swap word starting at cursor with next word>
transpose two lines     | ddp  <swap position of current line with next word>
delete lines having     | :g/pattern/d
   pattern              |    <delete all lines in file with "pattern">
                        | :g!/pattern/d  |  :v/pattern/d
                        |    <delete all lines in file without "pattern">
                        | :/pattern1/,/pattern2/d
                        |    <delete from first line having "pattern1" to
                        |     next line having "pattern2">
                        | d/pattern1/;/pattern2/
                        |    <delete from first line having "pattern1" up to
                        |     (but not including) next line having "pattern2">
                        | :g/pattern/-3,-1d|+1,+2d
                        |    <for all occurrences of "pattern", delete 3 lines
                        |     above and 2 lines below it; if "pattern" at top or
                        |     bottom of file, use :4,$-2g/pattern/-3,-1d|+1,+2d
                        |     instead; to also display lines having occurrences
                        |     of "pattern", use :4,$-2g/pattern/-3,-1d|p|+1,+2d>
move lines having a     | :g/pattern/mo$
   pattern              |    <move all lines with "pattern" to end of file>
delete columns of text  | :%!colrm f l
  (=>C ALL P'=' '' f l) |    <delete all text in columns "f" through "l">
                        | :'a,.!colrm f l
                        |    <delete all text in columns "f" to "l" from line
                        |     marked `a' to current line>
                        | :2,10!colrm 1 4
                        |    <delete all text in columns 1 to 4 for lines 2
                        |     to 10; this can be use to shift text to the left>
blank out text columns  | :.,$!column f l
 (=>C ALL P'=' ' ' f l) |    <from current line to end of file, blank out
                        |     columns "f" to "l" with spaces>
                        | :'a,'b!column 20
                        |    <from line marked `a' to line `b', fill columns 20
                        |     to end of line with blank spaces>
                        | :%!column 34 55 -
                        |    <for all lines in file, fill columns 34 to 55 with
                        |     character "-">
overlay text onto other | :.!yo  (:16,26!po)
  lines of text  (C OO) |    <yank current line of text to buffer and overlay it
                        |     onto lines 16 through 26>
                        | :'a,'b!yo  (:'c,'d!po)
                        |    <yank lines marked `a' through `b' and overlay them
                        |     on block of lines marked `c' and `d'>
                        | !!yo  (:'a,.!po  |  !'a po)
                        |    <overlay line of yo-yanked text onto lines starting
                        |     from line marked `a' to current line>
--------------------------------------------------------------------------------
COPY TEXT               |
--------------------------------------------------------------------------------
copy file (=>COPY file) | :r file  |  :read file
                        |    <copy contents of "file" after current line>
                        | :r !sed -n 50,75p file
                        |    <copy lines 50 to 75 of "file" after current line;
                        |     equivalent command using awk is
                        |     :r !awk 'NR >= 50 && NR <= 75' file >
                        | :r !sed -n "/pattern1/,/pattern2/p" file
                        |    <copy after current line all text in "file" that is
                        |     between an occurrence of "pattern1" and occurrence
                        |     of "pattern2">
copy a file after all   | :g/pattern/r file
   pattern occurrences  |    <a copy of "file" is placed after every "pattern">
copy a command output   | :g/pattern/r !Unixcommand
   after every pattern  |    <"Unixcommand" output placed after every "pattern">
copy a command output   | :r !Unixcommand
   into current file    |    <copy Unix command output after current line>
copy n numbers of words | nyw  (p  |  P)
                        |    <copy "n" number of words starting at cursor and
                        |     put after or before cursor>
copy to end   of line   | y$  (p  |  P)
                        |    <copy text from cursor to end of line and put below
                        |     or above cursor>
copy to start of line   | y0  (p  |  P)
                        |    <copy text from cursor to start of line and put
                        |     below or above cursor>
copy to end of sentence | c)  (p  |  P)
                        |    <y( copies to start of sentence>
copy a range of columns | yn| (p  |  P)
                        |    <copy from cursor to column "n" and put after or
                        |     before cursor>
copy a line        (C)  | yy  (p  |  P)
                        |    <yy yanks line; p or P puts yanked line below or
                        |     above cursor; unless you yank to named buffer, you
                        |     must use p/P to put the text back to another spot
                        |     before doing another dd or yy move/copy>
block copy n lines (CC) | nyy (p  |  P)
                        |    <yank "n" consecutive lines; p or P pastes yanked
                        |     lines; e.g., 4yy is same as C4 in SPF Edit>
                        | y'a (p  |  P)
                        |    <yank from current line to line marked `a'; p or P
                        |     pastes the yanked text>
                        | :'a,'by  (p  |  P)
                        |    <yank from line marked `a' to line `b'>
                        | :'a,'bco.
                        |    <copy from line marked `a' to line marked `b' after
                        |     current line>
copy a text block       | ma mb `ay`b  (p  |  P)
                        |    <to yank an arbitrary text block (instead of
                        |     complete lines), mark start of text with label `a'
                        |     and mark the character AFTER the last character to
                        |     to yank with label `b'; `ay`b yanks marked text
                        |     block; p or P pastes it back>
repeat a line       (R) | yy  (p  |  P)
                        |    <yank line, paste back below or above current line>
repeat line n times (Rn)| :1,ng/^/'aco'a
                        |    <to repeat line "n" times, either yy yank and then
                        |     use p "n" number of times, or mark the line as `a'
                        |     and :1,ng/^/'aco'a will duplicate "n" copies of
                        |     that line; e.g., :1,34g/^/'aco'a  will add 34 more
                        |     copies of line marked `a'; "n" must be no greater
                        |     than the number of lines in the file>
repeat text block  (RR) | :'a,'bco'b
                        |    <repeat the text block marked `a' on first line and
                        |     `b' on last line; the repeated block is placed
                        |     beneath original text block>
                   (RRn)| :1,ng/^/'a,'bco'b
                        |    <repeath the text block marked `a' on first line
                        |     and `b' on last line "n" number of times; "n"
                        |     "n" copies of repeated text block will be appended
                        |     appended below original text block; "n" be no
                        |     greater than the number of lines in the file>
yank to buffer (=>COPY1)| "anyy
 (copy to named buffer) |    <"a" is one of 26 buffers named a-z; "n" is number
                        |     of lines to yank, default of 1 line>
                        | "Anyy
                        |    <yank "n" lines, append it to buffer "a" contents>
yank a text block to    | ma mb `a"cy`b
   named buffer         |    <to yank an arbitrary text block (instead of
                        |     complete lines to named buffer, mark start of text
                        |     with label `a' and mark character AFTER the last
                        |     character to yank with label `b'; `a"cy`b yanks
                        |     marked text block to buffer "c">
paste yanked text from  | "ap  |  "aP
 named buffer (=>COPY1) |    <put contents of buffer `a' after or before current
                        |     line>
yank lines having       | :g/pattern/y a
   pattern              |    <yank all lines having "pattern" and store in
                        |     buffer "a">
                        | :g/pattern/y A
                        |    <yank all lines having "pattern" and append to
                        |     buffer "a">
store often-used ex     | "add @a  |  "ayy @a
   command into buffer  |    <"add deletes line containing a vi or ex command
   and execute buffer   |     sequence and stores it in buffer "a" (or a-z); @a
   whenever the command |     executes stored command in command mode; can
   is needed            |     restore delete buffer with "ap if command needs
                        |     changing; when using "ayy, enter command on last
                        |     line and use 1,$-1 as line address to avoid
                        |     running the command on itself; @ buffer commands
                        |     may not be more than 512 characters long>
                        | :*a <equivalent ex execution of buffer "a">
repeat last @ command   | @@
--------------------------------------------------------------------------------
REFORMAT TEXT           |
--------------------------------------------------------------------------------
concatenate text lines  | J  <join next line to end of current line>
                        | nJ <join "n" consecutive lines into one line>
                        | :j n   |  :join n
                        |    <join "n" consecutive lines into one line>
                        | :j! n  |  :join! n
                        |    <like :j, but whitespace is not eliminated>
text flow       (TFnn)  | !a}fmt -nn
                        |    <"a" is number of paragraphs to format; "nn" is
                        |     maximum allowed line length; format only a few
                        |     paragraphs at a time>
justify and block text  | :%!format -b -w72
                        |    <format all lines both left and right justified and
                        |     72-columns wide>
                        | :'a,'b!format -i4 -w68 -l
                        |    <format text between lines `a' and `b' to be 68-
                        |     columns wide, indented 4 spaces (for right margin
                        |     of 72 columns), and left justified>
                        | :1,7!format -c -w80
                        |    <format lines 1 to 7 so they are centered within
                        |     80-column wide lines>
                        | :%!perl -pe 'print " " x int((81-length())/2)'
                        |    <center all lines down the middle between columns 1
                        |     and 80>
                        | :,8!perl -pe 'print " " x int((73-length())/2)'
                        |    <center from current line to line 8 down the middle
                        |     between between columns 1 and 72>
shift lines left/right  | << >>   <each shift is 8 spaces; use :set shiftwidth=n
   (  or  )             |          to shift line n spaces>
                        | .       <repeat previous << or >> shift>
block shift n lines     | n<< n>> <shift n consecutive lines>
   ((  or  ))           | .       <repeat previous << or >> shift>
                        | >'a     <shift current line to line marked `a' to the
                        |          right>
                        | :8,12s/^/   /g
                        |         <shift lines 8 to 12 to left 3 spaces>
insert empty line       | :%s/$/Ctrl-V[Return]/
   between every line   |    <Ctrl-V/[Return] generates "^M" on substitution>
split text up so a new  | :%s/Example:/Example:Ctrl-V[Return]/g
   line is made at every|    <Ctrl-V/[Return] generates "^M" on substitution;
   occurrence of pattern|     text is split after all occurrences of "Example:">
split text up so each   | :%s/[[Space][Tab]][[Space][Tab]]*/Ctrl-V[Return]/g
   line has only one    |    <for all lines, substitute any tabs or blanks for
   left-justified word  |     newline breaks; if no tabs exist, you can use:
                        |     Q :%s/  */Ctrl-V[Return]/g
delete leading spaces   | :%s/^ *\(.*\)/\1/  |  :%s/^[ [Tab]]*//
   on every line in the |    <^ * searches for one or more spaces at start of
   file  (=>CRUNCH)     |     line; \(.*\)/\1 restores rest of line without any
                        |     leading spaces; can use this to prepare text for
                        |     embedding of nroff-troff commands)
delete spaces and tabs  | :%s/[[Space][Tab]]*$//
   at ends of lines and |    <remove blanks or tabs at ends of all lines; blank
   on blank lines       |     lines with invisible blanks or tabs also trimmed>
delete all blank lines  | :g/^$/d  |  :v/./d
                        |    <delete all blank lines which are empty>
                        | :g/^[ [Tab]]*$/d
                        |    <delete all blank or white-space-only lines>
change multiple blank   | :%s/[[Space][Tab]]*$//  :%!cat -s
   lines to single blank|    <substitution first compresses blank lines having
   lines                |     spaces to empty lines; `cat` command then squeezes
                        |     out all multiple blank lines>
convert single text     | !}pr -4t
   column into 4 columns|    <if needed, use !}expand -8 to align columns>
switch columns of data  | :'a,'b!awk '{print $2"  "$1"  "$3"  "$5"  "$4}'
   in a column-oriented |    <from lines marked `a' to `b', move 2nd field to
   table                |     1st column of so that 1st field is now 2nd filed,
                        |     and swap the 4th and 5th fields; assumes 5 fields,
                        |     each separated by 2 blanks>
                        | :%!awk '{printf "\%10s\%10s\%20s\n", $3, $2, $1}'
                        |    <for all lines containing 3 fields separated by
                        |     blanks, reverse the order of entries, printing in
                        |     order 3rd, 2nd, and 1st fields right-justified in
                        |     formatted columns of 10, 10, and 20 spaces wide>
                        | :%s/\(...\)\(.......\)\(....\)\(.....\)/\4\3\2\1/
                        |    <for all lines in file with four columns of data
                        |     3, 7, 4, and 5 columns wide, rearrange the columns
                        |     such that 4th and 1st columns are swapped and 2nd
                        |     and 3rd columns are swapped; unlike awk examples
                        |     above, this swaps exact columns (with spaces).>
reverse order of lines  | :g/^/mo0
   in file  (=>FLIP)    |
sort the lines in file  | :%!sort     <sort file in ascending order>
                        | :%!sort -r  <sort file in descending order>
                        | :'a,'b!sort +2
                        |    <sort 3rd field between the lines marked `a'/`b'.>
                        | :%!perl -00 -e 'print sort <>'
                        |    <sort entire file by paragraphs>
add line numbers to     | :%!nl  |  :%!cat -n
   start of each line   |    <inserts line numbers in columns 1-6 followed by a
                        |     tab character; remove numbers using :%!colrm 1 7>
                        | :%!pr -t -n
                        |    <inserts line numbers in columns 1-5 followed by a
                        |     tab character; remove numbers with :%!colrm 1 6>
add line numbers to end | 1G
   of each line         | !Gawk '{printf "\%s\%8d\n", $0, NR}'
                        |    <1G first moves to start of file; awk adds line
                        |     numbers to end of each line; if spacing of numbers
                        |     is not okay, "u" undo, and execute command again
                        |     using some spacing other than "%8")
transpose matrix of     | :%!transpose
   values               |    <transpose entire file contents (matrix of values);
                        |     8x5 matrix becomes 5x8 matrix>
translate characters to | :%!tr A-Za-z N-ZA-Mn-za-m
   other characters     |    <encrypts all lines to ROT13 format>
                        | :%!tr N-ZA-Mn-za-m A-Za-z
                        |    <translates all lines with ROT13 encryption>
                        | tr '\015' '\012' < file > file1
                        |    <translate all carriage returns to line feeds;
                        |     useful if "file" is too long for vi to accept as a
                        |     single line; run in Unix and output to "file1">
regularize spacing and  | :%s/\([.?!]\) *\([a-zA-Z0-9]\)/\1  \U\2/g
   case of sentences    |    <change any . ? ! punctuation followed by at least
                        |     one space followed by an alphanumeric character to
                        |     uniform two spaces between sentences, capitalizing
                        |     any lowercase letter that begins a sentence; this,
                        |     however, will not capitalize letters at the start
                        |     of a line that should be capitalized>
                        | :%s/\([^.?!]\)  *\([^.?!]\)/\1 \2/g
                        |    <change spacing between any character that is not a
                        |     . ? ! punctuation and any non[.?!] character to a
                        |     uniform one space separation>
run spelling checker on | :w            <save file first>
   the file             | :$r !spell %  <append mispelled words at bottom>
--------------------------------------------------------------------------------
SPF EDIT LINE OPERATION |
--------------------------------------------------------------------------------
draw a ruler     (COLS) | map _ o^[i----+----1----+----2----+----3----+----4 \
                        | ----+----5----+----6----+----7-^V|--+----8^[0
                        |    <place this in your .exrc file to draw an SPF-EDIT
                        |    COLS-styled ruler below the current line when you
                        |    press "_" in command mode; "^[" is Escape character
                        |    and "^V" is made by entering Ctrl-V twice>
--------------------------------------------------------------------------------
exclude text block (XX) | :'a,'b!exclude  (!!exclude)
   from current file    |    <exclude from line marked label `a' to line marked
                        |     `b' and then enter !!exclude on the folded text
                        |     to expand it back out again; warning: text must be
                        |     expanded prior to exiting current edit session>

********************************************************************************
COMMANDS FOR PROCESSING | VI EDIT EQUIVALENTS
********************************************************************************
comment IBM JCL lines   | :,$s/^/\/\/\* /
                        |    <insert a "//* " in front of current line to the
                        |     last line to comment IBM JCL>
                        | :/&END/+1,/EXEC DUMP/s/^\/\/\* //
                        |    <uncomment previously commented lines of IBM JCL
                        |     starting from line after the next occurrence of
                        |     "&END" to next occurrence of "EXEC DUMP">

********************************************************************************
SPF EDIT KEYS/COMMANDS  | VI OR EX COMMAND EQUIVALENTS
********************************************************************************
repeat last edit/insert | .
   command  [RETRIEVE]  |    <repeat last modification command issued; command
                        |     may be o/O, d, c, i, a, etc...>
                        | 4. <repeat last modification command 4 times>
                        | Ctrl-@
                        |    <in input mode, repeat the text that was last
                        |     inserted if input as the first character of the
                        |     new insertion; returns to command mode; only 128
                        |     characters are saved from previous insert; will
                        |     not work if >128 characters were last input>
[reset]                 | Escape key   (usually [F11] on DECs)
                        |    <in input mode, return from input mode to command
                        |     mode; in command mode, cancel a partially formed
                        |     command, such as "z" or "d", when no followup
                        |     character has been given>
display current line #  | :.=
display total number of | :=
   lines in the file    | :/pattern/=
                        |    <show line number of first line with "pattern">
display lines with      | :number  |  :nu  | :#
   their line numbers   |    (address)number(count)
                        |    <display current line with line number; if preceded
                        |     with address or followed by count, displays range
                        |     of lines and their numbers>
display lines showing   | :list  |  :l
   tabs and end-of-lines|    (address)list(count)
                        |    <display current line with tabs shown as "^I" and
                        |     end-of-lines marked "$"; if preceded with address
                        |     or followed by count, displays range of lines>
display filename, line  | Ctrl-G  |  :f
   number, total lines  |
undo previous change    | u  <undo last change made>
   (=>UNDO)             | U  <undo all changes made to a line; cursor must not
                        |     have moved off of that line>
                        | :e! <undo all changes to file since last save>
cancel current partial  | Ctrl-U <Backspace>
   ex/search command    |
screen refresh [Dup PA1]| Ctrl-L  |  Ctrl-R
                        |    <refresh the screen; useful if mail message changes
                        |     screen during edit session>
quit vi, invoke ex      | Q
quit ex, return to vi   | :vi
run command             | :!Unixcommand
   (=>TSO COMMAND)      |    <special characters used in "Unixcommand" may need
                        |     to be preceded with \ to escape the normal shell
                        |     meaning, including...
                        |     ! & | % + - * ? / ^ > < ( ) && || << >> # ; $
                        | :!!
                        |    <execute most recent shell escape command>
                        | :!! arguments
                        |    <repeat last shell command, appending supplied
                        |     "arguments" to command>
filter text through Unix| :.!Unixcommand
   command as standard  |    <filter current line through Unix command; the line
   input, replacing the |     addresses given are replaced by standard output of
   text with command's  |     the Unix command>
   standard output      | !!Unixcommand
                        |    <filter current line through Unix command and
                        |     replace with it with command output; may want to
                        |     open up a new line first to insert command output>
                        | n!!Unixcommand
                        |    <filter "n" consecutive lines starting with current
                        |     line through Unix command; the "n" lines are
                        |     replaced with command output>
                        | !!!Unixcommand
                        |    <filter current line through the last Unix command
                        |     used and replace with command output>
                        | !}Unixcommand
                        |    <filter paragraph of text through Unix command;
                        |     general form is !(times)(textblock) where "times"
                        |     is number of "textblocks" to process, "textblock"
                        |     is {} () [[ ]] + - G `"label", '"label", H, M, L
                        | :'a,'b!Unixcommand1 | Unixcommand2 | Unixcommand3
                        |    <filter text block from line marked `a' to `b'
                        |     through three different Unix commands; text block
                        |     is replaced with output from "command3">
                        | :map key
                        | 1G/pattern<CR>!/pattern/<CR>command<CR><key>
                        |    <recursively map "key" to filter all occurrences of
                        |     "pattern" in file through Unix command>
send file contents to   | :w ! Unixcommand
   standard input of    |    <can input file contents to script or C program>
   Unix command         |
define a string as an   | :ab string replace_text
   abbreviation to be   |    <abbreviate "replace_text" as "string"; "string"
   translated to other  |     changes to "replace_text" after a non-alphanumeric
   text                 |     character is entered unless character is quoted
                        |     with Ctrl-V; [Return] or [Esc] will trigger the
                        |     conversion; "replace_text" cannot end as "string">
                        | :una string
                        |    <cancel "string" as an abbreviated text string>
change working directory| :cd directory  |  :chdir directory  |  :chd directory
                        |    <change current working directory that vi writes to
                        |     using :w or read from using :e; if no directory
                        |     argument is specified, new directory is $HOME>
copy lines using ex     | :co  |  :copy  |  :t
                        |    (address)co(destination)
                        | :.,.+4co28  <copy current line to 4th line below
                        |              current line after line 28>
                        | :'a+2,$-4t. <copy 2nd line after line marked as `a'
                        |              through 4th line before last line in file
                        |              after current line>
                        | :%co$       <copy entire buffer file after last line
                        |              of file; same as Unix "cat file >> file">
delete lines using ex   | :d  |  :delete
                        |    (address)d(bufferletter)
                        | :d b 4  <delete 4 consecutive lines, store in
                        |          buffer "b">
                        | :'a,'bd <delete all lines between the line marked `a'
                        |          to line marked `b'>
                        | :%d     <delete all lines in file>
display saved buffers   | :display buffers  |  :di b
                        |    <NVI: display all buffers (named/unnamed/numeric)>
display all background  | :display screens  |  :di s
   screens              |    <NVI: display filenames of all background screens>
display the tags stack  | :display tags  |  :di t
                        |    <NVI: display the tags stack>
display ex help info    | :exusage [ex command]  |  :exu [ex command]
                        |    <NVI: display usage info for a ex command, if given
                        |     as argument; otherwise, display all ex usage info>
display vi help info    | :viusage [vi command]  |  :viu [vi command]
                        |    <NVI: display usage info for a vi command, if given
                        |     as argument; otherwise, display all vi usage info>
display short help line | :help  |  :he
                        |    <NVI: display brief help message>
map a key to commands   | :map [k] command
map a key to commands   | :map [k] command
   to be executed in    |    <map key [k] to commands in command mode; "command"
   command mode         |     cannot use "k" in its definition and cannot be
                        |     more than 100 characters>
                        | :unmap [k]   |  :unm [k]
                        |    <cancel key [k] that was previously mapped>
map a key to commands   | :map! <k> replacementcommand
   to be executed in    |    <map key <k> to commands in input mode; "command"
   input mode           |     cannot use "k" in its definition and cannot be
                        |     more than 100 characters; do not make input-mode
                        |     keymaps recursive>
                        | :unmap! <k>  |  :unm! <k>
                        |    <cancel key <k> that was previously mapped>
mark current line with  | :ma x  |  :mark x  |  :k x
   an letter label      |    <assign marker `x' (single lowercase letter) to a
                        |     line to use as command address; go to this line
                        |     using `x or 'x>
move lines using ex     | :m  |  :move
                        |    (address)m(destination)
                        |    <same as copy with delete or delete with put>
                        | :m 'a    <move current line to line marked a>
                        | :2 m 15  <move line 2 to below line 15>
                        | :.,.+4m0 <move current line through 4th line after
                        |           current line to top of file>
create exrc file from   | :mkexrc exrc_file  |  :mk exrc_file
   currently set maps,  |    <NVI: write all current maps, abbreviations, and
   abbreviations, and   |     options to "exrc_file" in form source'able by ex;
   options              |     if "exrc_file" exists, mkexrc will fail unless "!"
                        |     is appended to command to override>
preserve current buffer | :pre  |  :preserve
  in case of write error|    <use "vi -r filename" to recover later on>
edit previous file from | :prev  |  :previous
  argument list         |    <NVI: edit previous file from argument list
display lines using ex  | :p  |  :P  |  :print
                        |    (address)p(count)
restore previously      | :pu  |  :put
   deleted or yanked    |    (address)pu(buffername)
   text                 |    <if (buffername) is deleted, the last deleted or
                        |     yanked text is restored>
recover file from system| :rec  |  :recover
   save area after      |    <use after system crash or after using :pre;
   aborted edit session |     equivalent to starting vi with "vi -r file">
create a new shell from | :!sh  |  :!csh  |  :!ksh
   vi                   | exit  |  Ctrl-D  <to quit shell and resume editing
                        |                   current file>
exit from vi to current | Ctrl-Z  |  :stop  |  :st  |  :suspend  |  :su  (fg)
   shell                |    <temporarily suspend vi and return to Unix prompt
                        |     of current shell; enter "fg" at prompt to resume
                        |     vi; if autowrite set and file was changed, a file
                        |     save is done unless :stop! or :suspend! is used>
execute ex commands     | Q :so filename  |  Q :source filename
   stored in file       |    <enter :vi to return to vi mode; may be used to
                        |     initiate additional maps stored in a file>
split current screen in | :E [files...]
   two [F2 SPLIT]       |    <NVI: split the current screen into two equal-sized
                        |     screens; if "files" are specified, the new screen
                        |     begins editing these; without file arguments, the
                        |     current file is edited by both screens. Use Ctrl-W
                        |     to switch between screens, moving to next lower
                        |     screen in window.
background current split| :bg
   screen               |    <NVI: background current screen; it is replaced by
                        |     neighboring screen; cannot background your only
                        |     screen in the window>
foreground a screen that| :fg [file]
   was backgrounded     |    <NVI: foreground the first screen in the list of
                        |     backgrounded screens; with a file argument, the
                        |     requested file screen replaces the current screen,
                        |     which is in turn backgrounded>
resize split screens    | :resize +/-size  |  :res +/-size
                        |    <NVI: resize split screens by increasing/decreasing
                        |     number of rows when using "+/-" (e.g. :res +10
                        |     increases current screen by 10 lines) or setting
                        |     absolute number of rows (e.g. :res 30 sets current
                        |     screen to 30 lines, if window is large enough).
create a ctags file for | ctags prog*
   use later by vi      |    <create a file "tag" in current directory with
                        |     pointers to segments of code in all programs whose
                        |     names start with "prog">
                        | ctags *.c *.h ~/lib/*.h
                        |    <create file "tag" with pointers to all program
                        |     segments in all C and header files in current
                        |     directory along with all header files in "lib">
edit tagged program     | :ta Segmentnametag  |  :tag Segmentnametag
   segment (very quick  |    <ctags must have been run to make tags file>
   way to hop around in | :vi -tSegmentname
   up to three different|    <start vi in file with the tagged code segment>
   segments of code that| Ctrl-]
   may be in other files|    <if cursor is placed on first character of a tagged
   or even other        |     program function name, pressing Ctrl-] will open
   directories)         |     up the file containing that tagged code segment;
                        |     :rew returns to original place you were editing
                        |     prior to Ctrl-]; if you use Ctrl-] on a function
                        |     name from the file that the first Ctrl-] placed
                        |     you in, you may be placed into yet a third file;
                        |     Ctrl-^ will toggle back and forth between this
                        |     file and the one opened by the first Ctrl-]; :rew
                        |     :rew will return you back to original edit spot>
undo all changes made by| :u  |  :undo
   last editing command |    <equivalent to vi "u" undo command>
print vi program version| :ver  |  :version
yank lines using ex     | :ya  |  :yank  |  :y
                        |    (address)ya(bufferletter)
                        | :y a 4  <yank 4 consecutive lines, store in buffer a>
                        | :12,19 y  <yank lines 12-19 to general buffer>
shift lines left/right  | :(address)<(count)  |  :(address)>(count)
   in ex                | :>   <shift current line one shiftwidth to right>
                        | :<8  <shift 8 consecutive lines one shiftwidth to the
                        |       left>
line address of ex      | none    <execute ex command on current line only>
   commands             | $       <last    line in file>
                        | .       <current line in file>
                        | -       <line above current line of cursor>
                        | ---     <three lines above current line of cursor>
                        | +       <line below current line of cursor>
                        | ++      <two lines below current line of cursor>
                        | n       <nth line in file>
                        | %       <all lines in file; same as 1,$>
                        | g       <global or all lines in file; same as %>
                        | .-n     <nth line before the current line>
                        | .+n     <nth line after  the current line>
                        | 'a      <line previously marked as "a">
                        | ''      <line of previous context where cursor was>
                        | /pattern/ <first line in forward search direction
                        |            having "pattern">
                        | ?pattern? <first line in backward search direction
                        |            having "pattern">
                        | a,b     <all lines from line a to line b>
                        | 'a,'b   <all lines from line marked `a' to line marked
                        |          `b'; label `b' must not precede label `a'>
                        | a+n,a-n <"n" lines after or before "a" where "a" is
                        |          any address described above; second address
                        |          must not precede first address>

********************************************************************************
VI/NVI OPTION SETTINGS  | DESCRIPTION
********************************************************************************
All toggle flag options can be disabled by adding prefix 'no' to option name
Options may also be specified using the abbreviations shown in brackets.
--------------------------------------------------------------------------------
:set all                | Display all current option settings.
:set                    | Display only options changed from default setting.
:set option             | Set specified "option".
:set option?            | Display set value of specified "option".
:set altwerase          | NVI: Change how words are erased during input. Text is
                        |    broken into clases: alphanumerics and underscore,
                        |    other nonblank characters, and blank characters.
                        |    Def: noaltwerase.
:set autoindent   (ai)  | Good for programming; indent next line same distance
                        |    distance as previous line; Ctrl-T or Ctrl-D (input
                        |    mode) add or remove indent levels based on tabstop
                        |    setting.  Def: noai.
:set autoprint    (ap)  | Display changes after each editor command.  Def: ap.
:set autowrite    (aw)  | Automatically write file if changed before opening
                        |    another file with :n or before giving Unix command
                        |    with :!.  Useful when editing two or more files
                        |    simultaneously.  Def: noaw.
:set beautify     (bf)  | Ignore control characters during input (except tabs,
                        |    newlines, and formfeeds).  Def: nobf.
:set cdpath=":"         | NVI: Specify colon-separated list of directories used
                        |    as path prefixes for relative pathnames used in the
                        |    ':cd' command.  Def: CDPATH variable if set, or
                        |    current directory. To reference current directory,
                        |    use either empty string or "." in CDPATH variable.
:set columns=??   (co)  | NVI: Number of columns in screen; setting causes ex/vi
                        |    to reset COLUMNS variable:  Def: co=80.
:set comment            | NVI: If first non-empty line of file begins with "/*",
                        |    nvi skips to end of that C comment block before
                        |    displaying file.  Def: nocomment.
:set directory=?  (dir) | Store buffer files in specified directory.  Def: /tmp.
:set digraph      (dir) | NVI:
:set edcompatible       | Use ed-like features on substitute commands.  Def:
                        |    noedcompatible.
:set errorbells   (eb)  | Sound bell when error occurs.  Def: errorbells.
:set exrc         (ex)  | NVI: If 'noexrc' is set in the system or $HOME .*exrc
                        |    files, local .*exrc files are never read (unless
                        |    they are the same as the system or $HOME .*exrc
                        |    files). Setting 'exrc' on has no effect; the normal
                        |    local .*exrc files checks are done.  Def: noexrc
:set extended           | NVI: Regular expressions are extended (i.e. egrep)
                        |    format.  Def: noextended.
:set flash              | NVI: Flash screen instead of beep keyboard on error.
                        |    Def: flash.
:se hardtabs=?    (ht)  | Define boundaries for terminal hardware tabs.  Def:
                        |    ht=8.
:set ignorecase   (ic)  | Disregard case of characters in searches.  Def: noic.
:set keytime=?          | NVI: 10th's of a second ex/vi waits for full keymap
                        |    sequence.  Def: keytime=6.
:set leftright          | NVI: Scroll screen left-right for long lines instead
                        |    of folding lines at right margin. Def: noleftright.
:set lines=?      (li)  | NVI: Number of lines in screen.  Setting this causes
                        |    ex/vi to reset LINES variable.  Def: li=24.
:set lisp               | Insert indents in appropriate lisp format. Def: nolisp
:set list               | Display tabs as ^I and ends of lines as $. Def: nolist
:set magic              | Wildcard characters . * [] ~ have special meaning when
                        |    used in patterns.  Def: magic.
:set matchtime=?        | NVI: 10th's of a second ex/vi pauses on matching
                        |    character when showmatch set.  Def: matchtime=7.
:set mesg               | Permit system messages to display on terminal while
                        |    editing, which may disrupt display; use Ctrl-L to
                        |    restore screen display.  Def: mesg.
:set modeline           | After vi reads EXINIT variable and .exrc file, first
                        |    and last 5 lines of edit file are read for extra ex
                        |    commands; embedded commands must begin with "ex:"
                        |    or "vi:" and must be valid ex editor commands;
                        |    separate multiple commands with "|"; each line must
                        |    be terminated with :.  Def: nomodeline.
:set number       (nu)  | Display line numbers left of screen.  Def: nonu.
:set octal              | NVI: Display unknown characters as octal numbers,
                        |    instead of default hexidecimal.  Def: nooctal.
:set open               | Allow entry to open or visual mode from ex. Def: open.
:set optimize     (opt) | Abolish carriage returns at end of lines when printing
                        |    many lines; speeds output on dumb terminals when
                        |    displaying lines with leading white spaces (blanks
                        |    or tabs).  Def: noopt.
:set paragraphs=???     | Define paragraph delimiters for movement by {}.  Pair
                  (para)|    of characters used in value are nroff/troff macros
                        |    that begin paragraphs.
:set prompt             | Display ex prompt (:) when vi Q command given.  Def:
                        |    prompt.
:set readonly     (ro)  | Any file writes will fail unless ! is used after the
                        |    write (using w, ZZ, or autowrite).  Def: noro.
:set redraw       (re)  | Redraw screen whenever edits are made. Noredraw useful
                        |    on slow dumb terminals; deleted lines show up as @
                        |    and inserted text appears to overwrite existing
                        |    text until [Esc] pressed.  Def: depends on line
                        |    speed and terminal.
:set remap              | Allow nested map sequences.  Def: remap.
:set report=?           | Display message on prompt line whenever edit is made
                        |    that affects at least a certain number of lines.
                        |    Def: report=5.
:set ruler              | NVI: Display row/column on command line. Def: noruler.
:set scroll=??          | Amount of lines to scroll.  Def: half of window.
:set sections=?? ??     | Define section delimiters for movement by [[ ]].  Pair
                        |    of characters used in value are nroff/troff macros
                        |    that begin sections.
:set shell=????   (sh)  | Define pathname of shell used for shell escape ':!'
                        |    and shell command ':sh'.  Def: path derived from
                        |    existing shell environment.  Def: SHELL variable.
:set shiftwidth=? (sw)  | Define number of spaces for backward tabs when
                        |    autoindenting or shifting lines with <</>> command.
                        |    Def: sw=8.
:set showdirty          | NVI: Display asterisk on command line if file has been
                        |    modified.  Def: noshowdirty.
:set showmatch    (sm)  | Good for programming; when ) or } is entered, cursor
                        |    moves briefly to matching ( or {; if no match made,
                        |    error bell rings.  Def: nosm.
:set showmode           | NVI: Display current edit mode on command line.  Def:
                        |    noshowmode.
:set sidescroll=??      | NVI: Set number of columns shift to left-right when
                        |    using leftright scrolling and left-right margin is
                        |    crossed.  Def: sidescroll=16.
:set slowopen    (slow) | Hold off display during insert.  Def: depends on line
                        |    speed and terminal type.
:set sourceany          | Start vi using other person's startup files; security
                        |    risk, so do not use!  Def: nosourceany.
:set tabstop=?    (ts)  | Define number spaces <Tab> spaces.  Def: ts=8.
:set taglength=?  (tl)  | Define number of characters significant for tags. Def:
                        |    tl=0, all characters significant.
:set tags=?? ???        | Define pathname of files containing tags.  Def: system
                        |    searches /usr/lib/tags and file "tag" in current
                        |    directory.
:set term=vt???         | Define terminal type.
:set terse              | Display shorter error messages.  Def: noterse.
:set tildeop            | NVI: Modify ~ command to take associated motion.  Def:
                        |    notildeop.
:set timeout      (to)  | Time out a keyboard map after 1 second; useful for vi
                        |    versions that allow mapping a keystroke sequence.
                        |    Def: to.
:set ttywerase          | NVI: Change how words are erased during input.  Option
                        |    breaks text into two classes, blanks and non-blank
                        |    characters.  Def: nottywerase
:set ttytype=vt???      | Define the terminal type.
:set verbose            | NVI: Display error message on command line instead of
                        |    ringing bell for all errors.  Def: noverbose.
:set warn               | Display warning "No write since last change".  Def:
                        |    warn.
:set window=??    (w)   | Display specified number of lines on screen.  Def:
                        |    depends on line speed and terminal type.
:set wrapmargin=? (wm)  | Define right margin as n number of spaces from end of
                        |    line; automatically inserts carriage returns to
                        |    break lines.  Def: wm=0.
:set wrapscan     (ws)  | Continue search around either end of a file.  Def: ws.
:set writeany     (wa)  | Allow saving to any file.  Def: nowa.

********************************************************************************
OTHER NOTES ABOUT VI
********************************************************************************

Some vi commands have opposite lowercase and uppercase meanings.  Usually,
lowercase means to execute the command after or below the current cursor or
line location; uppercase means to execute the command before or above the
current cursor or line location.  Thus, the vi paste command (P or p) is
case-sensitive to have the same effect for copy and move commands as 'b' or 'a'
have to denote before or after a specific line number in SPF Edit.

Edit commands c (change), d (delete), y (yank) can have a movement command as a
suffix to modify the meaning.  cc, dd, yy operate on an entire line.  But c^
will change text from beginning of line to cursor position, cb will change a
word from its beginning up to cursor postion, d$ (or D) will delete from cursor
position to end of line, de will delete a word from cursor position to end of
word, y$ will yank text to buffer from cursor position to end of line and p
will paste the yanked text after the new cursor position, y3w will yank to
buffer 3 consecutive words starting from cursor position and P will paste those
3 yanked words before the new cursor position, etc, etc.  Thus, change, delete,
and yank have the general format (number)(command)(movement) where (number) is
the number of occurrences, (command) is either c, d, or y, and (movement) is a
movement command.  vi also distinguishes between "line" and "character" moves.
If change, delete, or yank are used with ex line addresses, entire lines are
acted upon.  If those commands are used with / or ? being the (movement)
command, only the text starting from the current cursor position the character
pattern searched for is acted upon.

Most vi commands can also have a numeric count as a prefix.  Thus, 5w will
move the cursor ahead by 5 words, 2( will move the cursor back 2 sentences.

vi toggles between the command mode and text input mode by pressing the
<escape> key (usually F11).  Most keys have a function in command mode.  If you
are new to vi, and are not sure if you are in command or input mode, or if you
think you may have typed a key by mistake, press <escape> until your terminal
beeps to get back to command mode.  If you typed a key by accident and changed
your file, enter 'u' to undo whatever last change was made to the file.  The vi
commands that enter input mode are : i, a, I, A, o, O, c, C, s, S, R.  The last
line of the display is always saved for reading input from : (for ex and shell
commands), / (forward search command), ? (backward search command), or ! (shell
command to filter a text object through).

EX commands have format :(line_address)(command)(parameters)(count)(flags)
where (line_address) defines lines to be affected, (command) defines type of
operation, (parameters) define arguments or options, (count) defines optional
or required number of lines affected by command, and (flags) define actions to
be taken upon completion of command (e.g., p to print line after executing the
command; l to print line along with EOL and tabs, c to confirm each change
before making it, g to globally repeat command across the line; only g and c
are usually needed in vi mode invoking of ex).  The EX line_address is usually
input in pairs separated by "," or ";".  If no beginning address is given, the
current line is assumed ".".  If ";" is used as a separator, the address before
the semicolon becomes the current line address relative to the next address
reference.

An input mode keymap can be used like the :ab abbreviation facility with the
following key differences.  The abbreviation mechanism waits to see what the
NEXT character after the abbreviation is going to be before deciding whether to
make a substitution, and if the sequence was not preceded by a non-alphanumeric
character (or by the top of the file), the abbreviation mechanism doesn't start
working at all.  By contrast, an input mode keymap mechanism instead starts a
per-character timer that begins whenever you type the first character of a
remapped sequence.  If there is an input mode keymap corresponding to multiple
characters, when you type the first character of that string, nothing will be
echoed to your screen unless you type some character other than the second
character of the keymap, or unless you type nothing at all within the set vi
"timeout" period, typically about two seconds long.

In short, vi watches to see if you have typed the beginning of an input mode
keymap sequence, and if the sequence is longer than a single character, vi
waits to see if you will type the complete sequence, in which case vi will
supply whatever remapping you have specified for the sequence you've just
typed.  This will happen regardless of what follows the remapped sequence.

To negate the expansion of a set abbreviation, enter Ctrl-V right after you
have typed the abbreviated sequence (to tell vi that you want to use the
character string literal as opposed to having it expand out as an
abbreviation).  To negate the execution of a set input mode keymap, enter
Ctrl-V before you have typed the keymapped sequence.

Abbreviations (:ab) must be activated in input mode, but command and input mode
keymaps, once they have been activated from their respective modes, may hop
back and forth between command and input modes during the keymap sequence.

If you do a yank from within a macro into a named buffer, vi may tell you that
you cannot yank from inside a macro, or put inside a macro.  This is sometimes
untrue (the message may come up due to a bug in the program logic).  You may be
able to get around this by making the yank the first thing that happens in the
macro.

--
>> Jeff Wang  / jeffw@advance.com / jeffw@jeffw.com / nnnnoise@interramp.com <<
>> Landmark Graphics Corporation      #====}==) Ext: 3409          (=={====# <<
>> Advance Products Group              #===(==} Fon: (303)779-8080  {==)===# <<
>> 7409 South Alton Court, Suite 100  #====}==) Fax: (303)796-0807 (=={====# <<
>> Englewood, Colorado 80112           #===(==} Tlx: 984254(AGC UD) {==)===# <<

