
------------------------------------------------------ TABs in VIM
     vim -p a.txt b.txt          open vim tabbed with 2 files
     vim -c :10  a.txt           open vim and the execute an 'ex cmd' (here goto line 10)
         -c :$   a.txt                goto last line
         -c /xxx a.txt                search for xxx

     :tabs    show the list
     gt       go to tab AFTER    
     gT       go to tab BEFORE    
     3gt      go to tab n.3
------------------------------------------------------ 
------------------------------------------------------ 







:set conceallevel=0              to avoid 'hidden' behaviour (ex hide the |bars| in help pages.

:hi link HelpBar Normal
:hi link HelpStar Normal


:set showmode                    to keep displaying the mode (Insert, Command, ...) while working


:help index                      to have all the commands
:help CTRL-A                     to have help on ^A (defaut is command-mode)
:help i_CTRL-A                   append the letter of the mode you want the help for that Ctrl
:help -t                         to have the help on vim command line options (here -t)
:help 'mouse'                    to have help on vim options (here mouse) ex help 'nu'
:help E37                        to have help for vim errors (here code E37)
:help xxxx + Tab                 like bash (...autocomplete)
:help xxxx + Ctrl-D              to have ALL the list of possible helps starting with xxxx
:help E37                        to have help for vim errors (here code E37)
:helpgrep xxxx                   to search xxxx text INSIDE help pages. It will the jump to the 1st.
                                 I can then move between the helps as 
                                      :cn         next match
                                      :cN         previous    (also :cprev)
                                      :cfirst     jump to 1st
                                      :clast      jumo to last
                                      :copen      jump to item under curson (like Ctrl-]
                                      :close      (like Ctrl-O, CTRl-T















------------------------------------------------------ GET VIM

UPDATE VIM & PLUGIN
If you have an old VIM version, then do this
1.  download the zip new version from vim.org
2.  unpack 
3.  go to src dir
4.  edit Makefile uncommenting the line ‘prefix’ (a good vale could be “$HOME”)
5.  make (to compile)
6.  make install to have it in $HOME/bin
To install Vundle follow the instruction of Vundle GitHub repo/README. Anyhow they could not work 
if linking at ~/.vim/bundle/ as written in the instructions.
A workaround is:
1.  link to ~/.vim/plugin/:
git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/plugin/Vundle.vim
also in .vimrc link to ~/.vim/plugin/:    set rtp+=~/.vim/plugin/Vundle.vim/
2.  execute from vi   :PluginInstall!, this will create again Vundle.vim but in ~/.vim/bundle/ and it is working, so you can rm -rf ~/.vim/plugin
3.  Add all the required plugin



------------------------------------------------------ ex
  enter ex:    :
               Q   
               gQ
               vim -e
               vim -E   (extended ex)

               
  exit ex:     :vi     go back to vi
  
  p            print                       10p         # print line 10
  ,            range of lines:             10,30p  

  #            line number                  10,30p#     or only 10,30#

  d            delete                      :3,18d
  co   t       copy      (t  alias)        :23,29co100
  m            move                        :160,224m23 

  .            current line        
  $            last line                   1,$    is all the file
  %            any lines                   %d     delete all the file        
                                           %t$    double the file (copy any line to the end)
  
  +n           for relative paths (to address n lines after)          :.,+20#      print following 20 lines
  -n                                          n lines before          :226,$m.-2   move 2 lines above, block 226-EOF
          N.B. if n = 1   can be used only + or - instead of +1  -1
  
  0     line 0 can be used to addrees before 1st line
        :-,+t0    move 3 linex at the beginning
  
  
  
  :/patter/d                     del 1st line with pattern
  :g/patter/d                    g means : in all the files --> del ALL lines with pattern
  :/patter/+d                    "   line following the 1st line with pattern
  :/pattern1/,/pattern2/d
  
       N.B.      in  vi    d/pattern        del from CURSOR till char before 1st pattern
                 in  ex    :.,/pattern/d    del ALL the linex (where is the curso) up and including where is the 1st pattern
  
  
  ;              to separate cmd.   ex.   :100;+5p     print 5 linex after 100.
  
  
------------------------------------------------------ to get info from the bash


let @a=system("ls") to do the same, with 2 commands 
"ap                 nb however that with this way instead the line below (p)
                    it can be above P

:r !ls              to insert the output of a bash cmd in the line below
:.!ls               to replace the current line with output ...   
                    nb. the keysequence !$ is a shorthand for :.!
                    nb. the keysequence !! "       "         "
                        if you write a command in a line (or that line is already a command)
                        ex 'ls' or 'date' or even do it now on the following line: 
                              ls -lt | awk '{print $9}' | sort 
                        executing !$sh or !!sh  substitute that line
                        with the output of the command
  
                    nb. '.' (current line) is a special case of the general form
                        :range! where there is a range of lines, ex:
                                        :10,85!sort  
                                        :%!sort

                    nb. like 5dd delete 5 lines, the same works for !!
                                    5!!sh    
                                    5!!cmd
                        
                    nb. :%!xxd     switch into binary editor
                                   (be careful that a save can damage the file if vi was
                                    not start as vi -b 
                                    (which can anyhow specify now with   :set binary)
                        :%!xxd -r    rever to ascii 
                                    
insert num of line in a substitution pattern match:
              :%s/----------- ok 1/\=line(".")/
              :%s/^/\=line(".")/                 <--- just add lines in front of each line


------------------------------------------------------ debug vim

--startuptime       is the option to debug vim. It works like this
                    1/2     vim --startuptime log.txt pippo.pm    # open pippo.pm logging all into file log.txt
                    2/2     :tabe log,txt                         # show log.txt

------------------------------------------------------ In Insert Mode
  :scriptnames         I see all the .vim (as also my .vimrc) that vim reads at the moment
  :set wm=10           wrapmargin
  :set hlsearch        higlight  serach  
  :set relativenumber  lines num are set relative +/- to current
  :set ruler           show stat bar
                       CTRL-G                   shows stat:    "practice" line 3 of 6 --50%--

  Vim modes:           to see on status bar  which is running mode:   :set showmode (is usually already SET)
                       - Normal           
                       . Insert

  u                    undo
  U                    undo on last line only
  C-R                  redo
  ------------------------------------- moving
  w                    START of next word
  e                    END   of this word
  
  b                    START of prev word
  ge                   END   of prev word

  W   E                skip  punctuation 
  B   gE               skip  punctuation 
  
  ^                    1st (not blank) char of a line 
  _                              idem
  $                    end of line (including \n)
  g_                   end of line (without   \n)
  n|                   move at column n

  ENTER                1st char of next line
  +                     "    "      "    "
  -                               previous
  
  number $             end of next num lines     2$       (the same cannot work for 0 to go at prev lines
                                                           as number 0   cannot understand 0 is out)

  f t                  to serach on the same line  (to: 'to'  stop 1 char before)
  F T                  to serach on the same line  (back)

  %                    brackets
  number %             move at the percentage (line) of file (50%)
   |----------------------------------------------------- move cursor
   |  
   |  20G              goto line 20   / :20
   |  
   |  z ENTER          the line with the cursor goes  at top
   |  z -                                             at middle
   |  z +                                             at bottom
   |  
   |  200z ENTER       line n.200 at top
   |  
   |  
   |  (    )           move between sentences     N.B. possible usage with them
   |  {    }                        parag.             ex 2y}    copy 2 parag. ahead.
   |  [[   ]]                       sections
   |  
   |  i(               select text inside ( braces     ex di(      delete text inside
   |  i[
   |  i{
   |  
  ------------------------------------- moving

   CTRL-B    Back    1 page
   CTRL-F    Forward 1 page
   CTRL-U    Half Up
   CTRL-D    Half Down
   CTRL-E    Scroll up
   CTRL-Y    Scroll down

  ------------------------------------- serach / ?

  *     forward on cursor word  
  #     back         idem

  N.B. 3*     go forw. for 3rd instance of cursor word.
  
  N.B. posible usage:
       d?stefano
       delete from where is the cursor back to 1 word stefano
  ____________________
  |  ``     (back-ap-)   move me back where I was   (a last edit or also only a find, which moved me out of there)
  |  ''                  the same, but move at that line, but also at the beginning of line.
  |
  |  CTRL-O  move back
  |  CTRL-I  move forw.
  |____________________________________ to see the list of marked-jumps:  :jumps
  
  ____________________
  |   ma    26 letters vi / vim also other 26: CAPITAL 
  |  `a     move to bookmark a (at old column)    
  |  'a     the same  (begin of line)
  |   "     cursor position  when last editing a file
  |   [     start of last change
  |   ]     end         idem
  |____________________________________ to see the list of marks:         :marks

  

  ------------------------------------- moving
  ------------------------------------- moving
  ------------------------------------- moving
  ------------------------------------- moving
  ------------------------------------- moving
  ------------------------------------- moving
  ------------------------------------- moving
  ------------------------------------- moving
  ------------------------------------- moving
  ------------------------------------- moving
  ------------------------------------- moving
  ------------------------------------- moving
  ------------------------------------- moving
  ------------------------------------- moving
  ------------------------------------- moving
  ------------------------------------- moving



------------------------------------------------------ In Insert Mode
C-R0       Paste REGISTER 0
C-W        delete current word
C-U        delete all the line
C-arrows   move
C-O        write a command while in Insert mode
C-A  C-@   redo the last input written in insert mode (C-@ then exit Insert mode)
------------------------------------------------------ ex


R                        start overwriting
yl yh                    NOT very useful: still is the way to yank 1 char (current / before)

------------------------------------------------------ buffer

               The are 9 DELETION (& YANKING)  BUFFERS for 'LINES' <----------- !!!!!!
               Words, or a portion of a line, are not saved in a buffer

               ex   "3p   :    print the content of buffer 3

               So remember that DELETE (d) and YANK (y) use the same buffer

"1pu.u.u ecc   to see all the buffers one after the other and found the right one

               The 9 buffers are said 'unnamed'.
               Using letters the buffers become other 26  (named buffers)
               Capital letters are not other 26 buffers, but they are used to
               'append' to what is already present in buffer 'lowercase'

               "d7yy    copy 7 linex to buffer named d
               "D0      append in buffer d from cursor back to start of line



------------------------------------------------------ open 
vi +              open and go to bottom file          | According to the POSIX standard, 
vi +10                     go to line 10              | vi should use -c command instead of +command 
vi +/xxxxxxx               go to 1st occ. of xxxxx    | For backward compatibility, both versions are accepted.


---------------------------- INSANE EDITING
   function! FreemindToTextFunction()
         silent!  set ft=
         silent!  set tw=80
         silent!  %s/^\(\s*\).*TEXT="\([^"]*\)".*$/\1- \2/
         silent!  v/^\s*-/d
         silent!  %s/&apos;/'/g
         silent!  %s/&quot;/"/g
         silent!  normal gggqG
         silent!  g/^-/s/- //
         silent!  g/^\w/t.|s/./=/g
         silent!  %s/^\s\{4}//
         silent!  %s/^-/o/
         silent!  g/^s*-/normal 0
         silent!  %s/^\s\{8}\zs-/#/
         silent!  %s/^\s\{8}\zs-/#/
    endfunction
---------------------------- 
:echo   "Hello, world!"
:echom  "Hello, world!"    <-- persistent
:messages                  <-- only see echom messages, the others are gone

          N.B. :echo  "foo\nbar"     print 2 lines (\n)
               :echom "foo\nbar"     print foo^@bar   (echom prints the 'exact' characters of the string
                                                       ^@ is Vim's way of saying \n)


          "                          <--- " is to start COMMENT
          !                          <-- to set a var at the opposite current value
                                         ex. set number or set nu
                                             set nonumber or set nonu change it back
                                             but I could do :set number!  (:set nu!)
          ?                          <-- to watch the current value  (:set nu? )
          :set numberwidth=4         <-- set the width of the left col for number-lines.
          :set relativenumber        <-- num lines are counted relative respect my position
          :set matchtime=5           <-- tens of seconds to show matching ( [ { 

          :set nu  matchtime=3       <-- I can set more options with only 1 set command.


:map ...  oooo             ... can be a symbol (ex -) or specail char (<space> <c-d> for control d)
                           ooo can be anythig  ex. :map <space> viw   (select a word pressing space)

:q

          ex :map <F2> i bla bla bla <ESC>  :r date "+\%x" <ESC> kJ
                       ^               ^    ^
                       enter          exit  enter cmd mode
                       insert         insert
                       mode           mode

          
          :nmap   for normal mode       ex. :nmap \ dd     delete a line whene pressing \ 
          :vmap       visual                :vmap \ U      UPPERCASE the selection when pressing \
          :imap       insert                :imap <c-d> <esc>ddi  delete a line when pressing Ctrl-C
                                                                  N.B. with esc I exit 'insert' and go to 'normal'
                                                                       withoud esc I would have 2 char 'd written

          N.B. the opposite:  unmap       :unmap <space>
                             nunmap       
                             vunmap       :vunmap \
                             iunmap


          One downside of the *map commands is the danger of recursing:  
                     :nmap dd O<esc>jddk     <--- here the second dd enter an infinte loop

          SO TO AVOID RECURSION TROUBLE, ABOVE ALL IT COULD HAPPEN WHEN INSTALLING PLUGINS
          N E V E R  USE THE *MAP VERSIONS. ALWAYS USE THE 'NO'-'RE'CURSION VERSION: 'NORE'

                         noremap
                        nnoremap
                        vnoremap
                        inoremap

          To avodi to shadow a key with map, just choose only 1 key for all my mappings,
          and always use it plus others (ex. '-'  :nnoremap -d dd   :nnoremap -c 0Di)
          Vim calls it <leader> and  you can set it, and then refer to it, like the following:

                 :let mapleader = ","
                 :nnoremap <leader>d dd

                 :nnoremap <leader>ev :split  $MYVIMRC<cr>     now 'ev carriage-retun (ENTER) open .vimrc
                 :nnoremap <leader>sv :source $MYVIMRC<cr>     to make changes in .vimrc active sourcing it

          There is also a <localleader>  that 'lives' only inside its file (ex. .html, .java, .txt)

                 :let maplocalleader = "\\"

 <buffer>      :nnoremap <buffer> <leader>x dd    <buffer> keyword means that the mapping acts only 
                                                  in this file. If I change file (buffer) it's not present.

               N.B. A local mapping hides more general ones 
                    (ex. :nnoremap  Q dd 
                         :nnoremap <buffer> Q x <--- this hides the above)

 :setlocal     Set only in that buffer. So in another files I can set that var in other ways
               (ex. in 1 file, :setlocal nu     in a 2nd file  :setlocal nonu)
               N.B. Not all the var has a setlocal possibility





:iabbrev ... ooo                    I can set an alias that when in insert mode, as soon as I type the word
                                    ... vim on the fly changes it to ooo.
                                    It's not exactly like map with 'inoremap' as with inoremap that change
                                    would occur as soon as the sequence ... occurs. While with iabbrev
                                    the change occurs only if ... is a detached word.

                                    ex. :iabbrev @@  basile.stef@gmail.com 

                                    with <buffer> it's local to the buffer when I run the cmd
                                    :iabbrev <buffer> @@  basile.stef@gmail.com




autocommand:       With this feature vim can execute command when some events occurs, addressing for ex.
                   also the filetype o whatever else.

                   The general form is:

                       :autocmd BufNewFile * :write
                                ^          ^ ^
                                |          | |
                                |          | The command to run.
                                |          |
                                |          A "pattern" to filter the event.
                                |
                                The "event" to watch for.

                    . :help autocmd-events     list all possible events.
                    . ex:
                           :autocmd BufNewFile * :write                  this save a file as soon as created (like touch)
                           :autocmd BufNewFile *.txt :write              this only for .txt
                           :autocmd BufWritePre *.html :normal gg=G      this indent .html fils before saving
                           :autocmd BufWritePre,BufRead *.html :normal gg=G    here how to add 2 events with ','
                           :autocmd BufNewFile,BufRead *.html setlocal nowrap  here set nowrap only in .html

                           the following map the same <localleader>c to comment with correct syntax 
                           javascript and python

                           :autocmd FileType javascript nnoremap <buffer> <localleader>c I//<esc>
                           :autocmd FileType python     nnoremap <buffer> <localleader>c I#<esc>

                           :filetype :filet  on  activate vim to detect filetype

                    :augroup / autocmd!
                           The problem with autcommands is that if I gave the same n-times (just
                           sourcing .vimrc n-times) vim has n autoc. equals, executing each n-times.
                           The soltion is in 2 steps.
                              1st step:
                              as name-scoping, include each autoc. in a block:

                              :augroup xxxxxx            xxxxx is a name I choose for this group of cmd
                              :   autocmd .....          here put all my autcmd  
                       (1)    :   autocmd .....
                              :augroup END

                              the 2nd step is init the block with the autocmd!  (to clear this block)
                       (2)    :augroup xxxxxx            
                              :   autocmd!   <-------- 
                              :   autocmd .....
                              :augroup END

                              without autocmd! if I would written again the same block (1) I would have it
                              double size, having all the cmd repeated.




           (number)(command)(text)      <----- text is a MOVEMENT command
                                               think that power on a command like
                                               y?stefano     copy from cursor, back to 1st occurrence of 'stefano'
                                               dn            delete up to next search  !!!!!!!!

 operator-pending      I can map a movement to some keys so that when I type a command ex. c
   (:onoremap)         and my mapped sequence than the effect is to have the command operating on my selection

                       The block of text on which vim will operate is:
                          
                          1. if I used VISUAL to define a selection it will operate on that
                          2. otherwise FROM where is the cursor (START point) till where I stop moving (END point)

                       So the visual way 1. allows to chose a different START than where is the cursor

                       ex.  :onoremap p i(       dp will then delete text inside (
                            :onoremap p 4w       cp will then change from where I am till 4 words ahead
                            :onoremap p vw       dp will then delete the following word (having selected with 'v')
                            :onoremap in( :<c-u>normal! f(vi(<cr>
                                            ^     ^      ^^ ^  ^
                                            |     |      || |  |__ <cr> ends the normal!
                                            |     |      || |______i(   select inside ()
                                            |     |      ||________v    visual
                                            |     |      |________ go with cursor to 1st (
                                            |     |_______________ think entering normal mode
                                            |_____________________ <c-u> this will work on ALL the file
                                                               

                       :onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>
                                            ^                ^  ^   ^      ^       ^
                                            |                |  |   |      |       |_ 1 line+visual+end line
                                            |                |  |   |      |__________set search hilight OFF
                                            |                |  |   |_________________\r means <c-r>
                                            |                |  |_____________________\\ escape '\'
                                            |                |________________________serach back a line with only '='
                                            |_________________________________________execute that string ""

:help statusline     to see all the options availbale. Most common are:
                     :set statusline=%f
                     :set statusline=%f\ -\ FileType:\ %y     N.B. the excaped spaces as set allow more set on the same cmd
                                                                   we could have set it like:

                                                             :set statusline=%f         " Path to the file
                                                             :set statusline+=\ -\      " Separator
                                                             :set statusline+=FileType: " Label
                                                             :set statusline+=%y        " Filetype of the file
 
                     %l        current line
                     %L        TOT file lines
                     %4xxxx    print the xxxx option in a num with of 4 chars  (align right)
                     %-4xxx                         idem                       (align left)
                     %F        absolute pathname
                     %.20xxx   print xxx option truncating it if exceeds 20 chars woidth
                     %=        align all the following options to the right of the statusline

                                    
:setlocal foldmethod=marke     once this command is submitted, any text block rounded by this special syntax
                               " bla bla bla ... commente ... bla bla bla ... {{{
                                   block of text
                               "}}}            will be open/close like Eclips fashion with cmd:  za
                               
                               to have it working only on .vim filetypes, add:
                                 :autocmd FileType vim setlocal foldmethod=marker



----------------------------------------------- Variables

             M Y     V a r               V I M    O p t i o n s   (&)

             :let foo = "bar"        |   :set nowrap
             :echo foo               |   :echo &wrap  --> 0  N.B. '&' so VIM access its option instead of
                                     |                       a possible my var with the same name
             :let foo = 42           |   
             :echo foo               |   :set wrap
                                     |   :echo &wrap  --> 1 


             N.B.  Vim Options can be then also set with 'let'  :let &textwidth = 100
                   It's not visible, this new power from there 
                   (as you could have used the shorter :set textwidth = 100)
                   but you can see when relying on power of var-usage as: 
                                                       :let &textwidth = &textwidth + 10

                   let &wrap = 0            ok = 0
                   let &wrap = 1            ok = 1
                   let &wrap = 458          ok = 1
                   let &wrap = "0"          ok = 0
                   let &wrap = "1"          ok = 1
                   let &wrap = "56"         ok = 1
                   let &wrap = "56adf"      ok = 1
                   let &wrap = "a56"               NOT OK
                   let &wrap = "etyqwy"            NOT OK

                   The above example depicts like VIM manage Strings
                   "Evfmmmf"  is not considered TRUE (or 1) so neither "a10". They are both FALSE or 0
                   while "1"   "1a"  "342shdfhs"    are all TRUE

l:  b:          'l:' and 'b' prefix means local and   :let &l:xxx = ...      :let &b:xxx = 
                  instead of                          :let &xxx   = ...      :let &xxx   =
                  set var xxx only for that buffer  
                  There are other char besides 'l' and 'b' to define the 'scope' of a var:   :help internal-variables

@             registers can be reference as variables the syntax is:

              echo @a       echo register a
              echo @"       echo default unnamed reg. (called ") where y and d text goes
              echo @/       echo the text stored in the last find (so the current if a write 'n'

              :let @a = "hello!"   "move text in register a"

----------------------------------------------- Cmd and Conditions

|             pipe allow to put on 1 line more commands   :echom "foo" | echom "bar"

if            the syntax is
              :if 0
              :    echom "if"
              :elseif "nope!"
              :    echom "elseif"
              :else
              :    echom "finally!"
              :endif

==            :if 10 == 11                FALSE
==?           :if 10 == 10          TRUE
==#           :if "foo" == "bar"          FALSE
              :if "foo" == "FOO"     (1)   (2)              (1) if :set   ignorecase
                                                            (2) if :set noignorecase 

                           SO IT'S DANGEROUS USE == AS YOUR PLUGIN WOULD NOT WORK EVERYWHERE
                           DEPENDING OF RUNNING VIM SETTINGS (:set ignorecase)
                           ==?  compares always takeing into considerations case
                           ==#  compares regardless case

                           TRY TO ALWAYS USE ==?  (it also work on numbers!!!)

           The same applies fot > <    ># >? 

----------------------------------------------- Function
definition:     A L W A Y S   begin the name with UPPERCASE: otherwise Vim put you out of scope

                          1 way           |          another way
                                          |
                      :function Meow()    |     :function GetMeow()
                      :  echom "Meow!"    |     :  return "Meow String!"
                      :endfunction        |     :endfunction
                                          |     
call it:              call Meow()         |     :echom GetMeow()    N.B. withuut echom, it doesn't display anything. 
                                                                         The return value is thrown away 

return 0              if a function doesn't return a value, 
                      it implicitly returns 0. Let's use this to our advantage. 

                            :function TextwidthIsTooWide()
                            :  if &l:textwidth ># 80
                            :    return 1
                            :  endif
                            :endfunction

arguments             
                      :function DisplayName(name)
                      :  echom "Hello!  My name is:"
                      :  echom a:name                <--- N.B. the scope is a:  it's an argument
                      :endfunction


                      :function AssignGood(foo)
                      :  let foo_tmp = a:foo         <--- local var
                      :  let foo_tmp = "Yep"
                      :  echom foo_tmp
                      :endfunction

variable  args       
                      :function Varg2(foo, ...)
                      :  echom a:foo   <--- a
                      :  echom a:0     <--- 2  (numof var args: b c)
                      :  echom a:1     <--- b
                      :  echo a:000    <--- a:000 is the list of exceeding args (here c)
                      :endfunction


                      :call Varg2  ("a", "b", "c")


numbers
                      :echom 100
                      :echom 0xff    
                      :echom 017       ocatl -> 15 decimal
                      :echom 019       19 !!!! N.B. 019 cannot be octat (there is 9)
                      :echo 100.1
                      :echo 15.45e-2
                      :echo 3 / 2      1!   trunct
                      :echo 3 / 2.0    1.5


Strings
                      :echom "Hello, " . "world"   Concatenation 
                      :echom 10 . "foo"            string 10foo  (int converted in String)
                      :echom 10.1 . "foo"          error: Float cannot be converted to String
                      :echom "Hello, " + "world"   '0'  (+ is a numeric operator)
                      :echom "3 mice" + "2 cats"   '5'
                      :echom 10 + "10.10"          20  (String are converted only to int)

                      :echom '\n\\'        when is used ' instead of ", the String is LITERAL so
                                           here we have literally \n\\
                                           The ONLY exception is ' itself:

                                           :echom 'That''s enough.' --> That's enough


Managing Strings
                      :echom strlen("foo")                3
                      :echom    len("foo"                 3
                      :echo split("one two three")        splits a String (default separator is <space>)into a 'List'
                      :echo split("one,two,three", ",")   specify a separator (,)
                      :echo join(["foo", "bar"], "...")   foo...bar
                      :echo join(split("foo bar"), ";")   foo;bar
                      :echom tolower("Foo")
                      :echom toupper("Foo")

Execute                evaluate a string as if it was a Vim command. 


times in msec
 clock   self+sourced   self:  sourced script
 clock   elapsed:              other lines

000.006  000.006: --- VIM STARTING ---
000.141  000.135: Allocated generic buffers
000.276  000.135: locale set
000.283  000.007: window checked
001.014  000.731: inits 1
001.022  000.008: parsing arguments
001.024  000.002: expanding arguments
001.040  000.016: shell init
001.522  000.482: Termcap init
001.573  000.051: inits 2
001.775  000.202: init highlight
002.302  000.366  000.366: sourcing /usr/share/vim/vim74/debian.vim
003.021  000.406  000.406: sourcing /usr/share/vim/vim74/syntax/syncolor.vim
003.272  000.760  000.354: sourcing /usr/share/vim/vim74/syntax/synload.vim
036.077  032.702  032.702: sourcing /usr/share/vim/vim74/filetype.vim
036.148  033.743  000.281: sourcing /usr/share/vim/vim74/syntax/syntax.vim
036.186  034.338  000.229: sourcing $VIM/vimrc
036.668  000.226  000.226: sourcing /usr/share/vim/vim74/syntax/syncolor.vim
037.270  000.456  000.456: sourcing /usr/share/vim/vim74/ftoff.vim
037.947  000.278  000.278: sourcing /home/stiv/.vim/bundle/Vundle.vim/autoload/vundle.vim
038.315  000.245  000.245: sourcing /home/stiv/.vim/bundle/Vundle.vim/autoload/vundle/config.vim
061.516  021.386  021.386: sourcing /usr/share/vim/vim74/filetype.vim
061.626  000.029  000.029: sourcing /usr/share/vim/vim74/ftplugin.vim
061.716  000.024  000.024: sourcing /usr/share/vim/vim74/indent.vim
061.836  000.007  000.007: sourcing /usr/share/vim/vim74/filetype.vim
061.904  000.005  000.005: sourcing /usr/share/vim/vim74/ftplugin.vim
061.968  000.005  000.005: sourcing /usr/share/vim/vim74/indent.vim
062.033  000.005  000.005: sourcing /usr/share/vim/vim74/filetype.vim
062.248  026.004  003.338: sourcing $HOME/.vimrc
062.253  000.136: sourcing vimrc file(s)
062.678  000.083  000.083: sourcing /home/stiv/.vim/bundle/nerdtree/autoload/nerdtree.vim
063.419  000.339  000.339: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/path.vim
063.538  000.082  000.082: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim
063.655  000.085  000.085: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim
063.758  000.069  000.069: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim
063.966  000.178  000.178: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim
064.236  000.236  000.236: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim
064.530  000.260  000.260: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim
064.710  000.147  000.147: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/opener.vim
064.895  000.153  000.153: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/creator.vim
064.955  000.029  000.029: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim
065.047  000.064  000.064: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim
065.351  000.273  000.273: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/ui.vim
065.398  000.012  000.012: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/event.vim
065.449  000.023  000.023: sourcing /home/stiv/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim
065.788  000.304  000.304: sourcing /home/stiv/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim
075.045  000.067  000.067: sourcing /home/stiv/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim
075.330  000.268  000.268: sourcing /home/stiv/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim
075.459  013.127  010.455: sourcing /home/stiv/.vim/bundle/nerdtree/plugin/NERD_tree.vim
075.584  000.081  000.081: sourcing /home/stiv/.vim/bundle/lightline.vim/plugin/lightline.vim
075.788  000.078  000.078: sourcing /home/stiv/.vim/bundle/python-mode/autoload/pymode.vim
075.862  000.007  000.007: sourcing /usr/share/vim/vim74/filetype.vim
075.932  000.005  000.005: sourcing /usr/share/vim/vim74/ftplugin.vim
076.562  000.007  000.007: sourcing /usr/share/vim/vim74/filetype.vim
076.630  000.005  000.005: sourcing /usr/share/vim/vim74/ftplugin.vim
076.713  001.057  000.955: sourcing /home/stiv/.vim/bundle/python-mode/plugin/pymode.vim
076.922  000.058  000.058: sourcing /usr/share/vim/vim74/plugin/getscriptPlugin.vim
077.099  000.163  000.163: sourcing /usr/share/vim/vim74/plugin/gzip.vim
077.263  000.150  000.150: sourcing /usr/share/vim/vim74/plugin/matchparen.vim
077.630  000.352  000.352: sourcing /usr/share/vim/vim74/plugin/netrwPlugin.vim
077.670  000.009  000.009: sourcing /usr/share/vim/vim74/plugin/rrhelper.vim
077.711  000.025  000.025: sourcing /usr/share/vim/vim74/plugin/spellfile.vim
077.863  000.134  000.134: sourcing /usr/share/vim/vim74/plugin/tarPlugin.vim
077.955  000.072  000.072: sourcing /usr/share/vim/vim74/plugin/tohtml.vim
078.089  000.117  000.117: sourcing /usr/share/vim/vim74/plugin/vimballPlugin.vim
078.265  000.156  000.156: sourcing /usr/share/vim/vim74/plugin/zipPlugin.vim
078.587  000.230  000.230: sourcing /home/stiv/.vim/bundle/indentLine/after/plugin/indentLine.vim
078.618  000.634: loading plugins
078.625  000.007: inits 3
078.756  000.131: reading viminfo
078.774  000.018: setting raw mode
078.788  000.014: start termcap
078.809  000.021: clearing screen
079.370  000.246  000.246: sourcing /home/stiv/.vim/bundle/lightline.vim/autoload/lightline.vim
079.698  000.051  000.051: sourcing /home/stiv/.vim/bundle/lightline.vim/autoload/lightline/tab.vim
080.058  000.139  000.139: sourcing /home/stiv/.vim/bundle/lightline.vim/autoload/lightline/colorscheme.vim
080.481  000.673  000.534: sourcing /home/stiv/.vim/bundle/lightline.vim/autoload/lightline/colorscheme/wombat.vim
082.685  002.906: opening buffers
082.712  000.027: BufEnter autocommands
082.713  000.001: editing files in windows
082.804  000.091: VimEnter autocommands
082.804  000.000: before starting main loop
083.436  000.632: first screen update
083.437  000.001: --- VIM STARTED ---
