             INFRASTRUCTE AS CODE = IAC

             binary: $ terraform        it comes as a single zip (to put in a dir found by $PATH)

             this is the 1st compnent of Terraform, the executable
             Terraform is 4 components:

                    1. the exe     (eg /usr/local/bin/terraform)
                           - terraform is an exacutable (written in go). 1 single file with no other libraries to put around

                    2. the providers  (executable plugins which could extend the functionalities, ex 'aws')
                           - terraform providers/plugins: they extend/implement the different features of terraform

                    3. config files
                           - terraform files (.cfg) they contain the variables/configuration to deploy

                    4. state file
                           - terraform state: it contains the current state of my target

-------------------------------------------------------------------


             |  Usage: terraform [-version] [-help] <command> [args]
             |
             |  The available commands for execution are listed below.
             |  The most common, useful commands are shown first, followed by
             |  less common or more advanced commands. If you're just getting
             |  started with Terraform, stick with the common commands. For the
             |  other commands, please read the help and docs before usage.
             |
             |  Common commands:
           1 |      apply              Builds or changes infrastructure
           2 |      console            Interactive console for Terraform interpolations
           3 |      destroy            Destroy Terraform-managed infrastructure
           4 |      env                Workspace management                          <---- deprecated use (19) workspace
           5 |      fmt                Rewrites config files to canonical format     <----------------- cool, to format all the tf files in cur dir
           6 |      get                Download and install modules for the configuration
           7 |      graph              Create a visual graph of Terraform resources
           8 |      import             Import existing infrastructure into Terraform <==== very cool!!! It imports stuf in terraform STATE so that
             |                                                                            it stops erroring that something exists
           9 |      init               Initialize a Terraform working directory
          10 |      output             Read an output from a state file              <----- to dump state file
          11 |      plan               Generate and show an execution plan
          12 |      providers          Prints a tree of the providers used in the configuration
          13 |      refresh            Update local state file against real resources
          14 |      show               Inspect Terraform state or plan               <----- to dump state file
          15 |      taint              Manually mark a resource for recreation
          16 |      untaint            Manually unmark a resource as tainted
          17 |      validate           Validates the Terraform filesA                <----- to intercept potential mistakes
          18 |      version            Prints the Terraform version
          19 |      workspace          Workspace management
             |
             |  All other commands:
             |      0.12upgrade        Rewrites pre-0.12 module source code for v0.12
             |      debug              Debug output management (experimental)
             |      force-unlock       Manually unlock the terraform state
             |      push               Obsolete command for Terraform Enterprise legacy (v1)
             |      state              Advanced state management


-------------------------------------------------------------------
  brew install terraform   <--------- NO !   this doesn't install the latest version but it installs 1.5.1 (when the latest
                                             might be 1.10.1) because it's when Terraform decided (Aug 10 2023)
                                             to switch the licence from
                                                "Mozilla Public License v2.0 (MPL 2.0)"
                                             to
                                               "Business Source License (BUSL)"
                                             abd brew doesn't accept BUSL.

  brew tap hashicorp/tap               |
  brew install hashicorp/tap/terraform |     this would bypass brew rule
                                             but anyhow the best way is to use a version switcher like
                                             tfenv or chtf

-------------------------------------------------------------------
  tfenv                              To Manage more terraform versions (like chtf but more common)

             . brew install tfenv
             . tfenv install <version>
                                         ex:
                                               tfenv install 1.5.0
                                               tfenv install 1.3.9
             . tfenv use <version>
             . tfenv list
             . tfenv uninstall <version>
             . .terraform-version              this is a cool feature.
                                               If a specify a version in this "hidden" file
                                               then when I enter that dir (which presumably is the "root" of a terraform project)
                                               tfenv will automatically switch on that specific version
                                               ex:
                                                   echo "1.5.0" > .terraform-version
       NOTE:
             the binary is always the same
                 > which terraform
                   /opt/homebrew/bin/terraform
             but it's a link to where tfenv puts the installed versions:

                   ls -l /opt/homebrew/bin/terraform
                         /opt/homebrew/bin/terraform -> ../Cellar/tfenv/3.0.0/bin/terraform

                   ╰─ ls -l /opt/homebrew/bin/../Cellar/tfenv/3.0.0/versions/
                        total 0
                        drwxr-xr-x  4 sbasile  admin  128  9 Dec 19:45 1.10.1
                        drwxr-xr-x  3 sbasile  admin   96  9 Dec 19:44 1.5.7


-------------------------------------------------------------------
  chtf                               Terraform version switcher   (brew install yleisradio/terraforms/chtf)

                                     for bash/zsh add this in the profile files:

                                                if [[ -f /opt/homebrew/share/chtf/chtf.sh ]]; then      <------ this path can change
                                                    source /opt/homebrew/share/chtf/chtf.sh
                                                fi

                                     to install/switch multiple Terraform versions (since 0.6.6) at the same time,
                                     [chtf installs the specified version automatically if needed].

                                     chtf                 with no args shows all the versions
                                     chtf -V --version
                                     chtf system          switch to OS version



                                     ╰─ chtf
                                        0.11.11
                                        0.11.7
                                        0.11.8
                                        0.12.19
                                        0.12.7
                                        0.12.9
                                        0.13.3
                                        0.8.8

                                                         ╰─ chtf system

                                                         ╰─ terraform --version
                                                         Terraform v1.0.4
                                                         on darwin_amd64

                                                         ╰─ which terraform
                                                         /usr/local/bin/terraform

                                                         ╰─ chtf 0.11.8

                                                         ╰─ which terraform
                                                         /usr/local/Caskroom/terraform-0.11.8/0.11.8/terraform
-------------------------------------------------------------------

      PROVISION INFRASTRUCTURE THROUGH CODE

                      execution plan
                      Infrastructure as code             high-level configuration syntax
                      graph                              Terraform builds a graph of all your resources
                                                         This means that when running 'terraform apply'
                                                         terraform takes care of usual problem of finding the

                                                                 1. dependencies between resources
                                                                 2. order to execute


                       - benefit:
                                 . predictable envs
                                   (they are PREDICTABLE on what I'll get)
                                 . automate deployment  (manual processes are the enemy)
                                 . repeatable process
                                 . reusable components (don't repeat yourself)
                                 . document architecture



      CORE CONCEPTS:
                        1. Defined in CODE
                        2. Stored in Source Code:   (gitHub) / contribute in parallel
                        3. Declarative (not  Imperative)


          Imperative:                                  Declarative

          #make me a taco                               #make me a taco

          #retrieve 1st what you need                   I case use a CONFIGURATION language
             get shell
             get beans                                     ____ of type 'food'____ I give the name "bean-taco"
             get chees                                    /                  /
             get lettuce                                food  taco  "bean-taco"    {
             get salsa                                          \___ of subtype taco

          #2nd instruct how to proceed                       ingredients = [
                                                                "beans", "cheese", "lettuce", "salsa"
             put beans in shell                              ]
             put cheese on beans
             put lettuce on cheese                      }
             put salsa on lettuce

                                                                In the Declarative I don't specify
                                                                the procedures to
                                                                           - get
                                                                           - and assemble
                                                                because I rely on a provisioner
                                                                which knows how to do through a default way.
                                                                I can change/customise the default
                                                                adding more parameters in the configuration

                        4. Idempotent + Consistent : Idempotent: every time I do something the result will be the same
                                                     Consistent: if I already have what I wanted
                                                                 then Terraform will do nothing

                                                                 ex. I ask "make me a taco" a 2nd time
                                                                     Terraform will answer: no change you already have 1.



                        5. Push vs Pull  :
                                           - Terraform is a PUSH type: I push the configuration down to the target

                                           - PULL ways: the target pulls down from me the configuration
                                             (ex. an agent on a server pulls down the configuration on a regular basis)
-------------------------------------------------------------------
    1st RULE OF TERRAFORM

           manage always with Terraform

           (never change manually)
-------------------------------------------------------------------
    "terraform {"             the terraform-block
                                terraform {
                                }
                              in a file "terraform.tf" adds config
                              like which version of terraform is required, ...
                                 # =, >, <, =>, =<,   ~>     the only strange is ~> which means ony the rightmost number increments

     terraform {
          required_version = "...."

          required_providers = {

              provider_name = {
                     source = "...."
                     version = "..."
          }
     }
                     E X A M P L E :
                                                           terraform {
                                                                required_version = ">= 1.0, < 2.0:

                                                                required_providers = {

                                                                    aws = {
                                                                           source = "hashicorp/aws"
                                                                           version = "~>4.0"          like regex /4\.[0-9]+/
                                                                }
                                                           }


-------------------------------------------------------------------
    TERRAFORM STATE      (./terraform.tfstate)


        terraform.tfstate                   This state file is extremely important;
                                            it keeps track of the IDs of created resources so that
                                            Terraform knows.
                                            This file must be saved and distributed to anyone who might run Terraform.



         . a file which stores the state ('resource' mappings and metadata)
         . this file can be local or remote:
                         . Local (by default)
                         . Remote (AWS / Azure/ NFS/ Terraform Cloud)
         . the format is JSON  (do not edit)
         . It can be 'Locked' by Terraform while an operation is ongoing

           > terraform state list         # show all resources inside the json file and their addresses (ids)
                                            ex. ❯ terraform state list
                                                data.aws_ssm_parameter.amzn2_linux
                                                aws_instance.nginx1
                                                aws_internet_gateway.app
                                                aws_route_table.app
                                                aws_route_table_association.app_subnet1
                                                aws_security_group.nginx_sg
                                                aws_subnet.public_su

           > terraform show address       # show a specific resource (like git show)
           > terraform rm   address       # remove 1 resource from the state file


    . Workspaces:  every Workspace has its own separate STATE file.
                   If I switch the 'context' terraform will use that specific state file.



    TERRAFORM STATE JSON FORMAT:

    {
        "version": 4,                          # of the state file
        "terraform_version": "0.12.5",         # to not use with older versions
        "serial":30,                           # incremented on every change of the STATE file. Ex of its usage:
                                                 a terraform plan -out xxx will be later applied
                                                 (with a terraform apply xxx) only if the "serial" saved by terraform in the xxx plan
                                                 still matches the one in the state file.
        "lineage":"",
        "outputs:{},                           # info when apply completed
        "resouces":[]
    }

                                    ╰─ terraform state list                                 .------>  ╰─ terraform state show aws_vpc.app
                                                                                            |
                                    data.aws_availability_zones.available                   |         # aws_vpc.app:
                                    data.aws_ssm_parameter.amzn2_linux                      |         resource "aws_vpc" "app" {
                                    aws_instance.nginx1                                     |             arn                                  = "arn:aws:ec2:eu-west-2:450865997890:vpc/vpc-0c2b6835244d1ac7f"
                                    aws_instance.nginx2                                     |             assign_generated_ipv6_cidr_block     = false
                                    aws_internet_gateway.app                                |             cidr_block                           = "10.0.0.0/16"
                                    aws_lb.nginx                                            |             default_network_acl_id               = "acl-0941daa1e88a971e6"
                                    aws_lb_listener.nginx                                   |             default_route_table_id               = "rtb-0d3cd44f78597de09"
                                    aws_lb_target_group.nginx                               |             default_security_group_id            = "sg-06a9b967c25284735"
                                    aws_lb_target_group_attachment.nginx1                   |             dhcp_options_id                      = "dopt-20446c48"
                                    aws_lb_target_group_attachment.nginx2                   |             enable_dns_hostnames                 = true
                                    aws_route_table.app                                     |             enable_dns_support                   = true
                                    aws_route_table_association.app_public_subnet1          |             enable_network_address_usage_metrics = false
                                    aws_route_table_association.app_public_subnet2          |             id                                   = "vpc-0c2b6835244d1ac7f"
                                    aws_security_group.alb_sg                               |             instance_tenancy                     = "default"
                                    aws_security_group.nginx_sg                             |             ipv6_association_id                  = null
                                    aws_subnet.public_subnet1                               |             ipv6_cidr_block                      = null
                                    aws_subnet.public_subnet2                               |             ipv6_cidr_block_network_border_group = null
                                    aws_vpc.app --------------------------------------------'             ipv6_ipam_pool_id                    = null
                                                                                                          ipv6_netmask_length                  = 0
                                                                                                          main_route_table_id                  = "rtb-0d3cd44f78597de09"
                                                                                                          owner_id                             = "450865997890"
                                                                                                          tags                                 = {
                                                                                                              "billing_code" = "innov1"
                                                                                                              "company"      = "Globomantics"
                                                                                                              "project"      = "Globomantics-load2"
                                                                                                          }
                                                                                                          tags_all                             = {
                                                                                                              "billing_code" = "innov1"
                                                                                                              "company"      = "Globomantics"
                                                                                                              "project"      = "Globomantics-load2"
                                                                                                          }
                                                                                                      }
-------------------------------------------------------------------
    TERRAFORM SYNTAX
           HashiCorp    configuration language

           - makes what isn't possible with just JSON / YAML
           - supports conditionals / functions / reusable templates


  Configuration files                extension: *.tf   (or .tf.json when using JSON)
                                     structure: tree of modules.
                                                A root module, where evaluation begins,
                                                Child modules created when one module calls another.

                                          - module: ALL .tf/.tf.json files in a dir
                                          - a ROOT module: all .tf/.tf.json files in the CURRENT dir

                                          SIMPLEST CONFIG: 1 .tf file in cur dir

                                     format: its own configuration language (default)  or JSON.
                                             (Infrastructure as code: the proprietary language
                                                                      is then more powerful than JSON)
                                     format specs:
           - BLOCKS
                        . basic:            type    label1    label2          ex resource "aws_vpc"  "vpc"  {}


                                       <BLOCK TYPE> "<BLOCK LABEL>"... "<BLOCK LABEL>" {    like     int i  <--"TYPE" & "name" var
                                         # Block body
                                         <IDENTIFIER> = <EXPRESSION> # Argument
                                       }
                                                        _________________________________________
                                     example:          /                                         |
                                            provider "aws" {                                     |
             ~/.aws/credentials  ------->     profile    = "default"              # BLOCK 1      |
                                              region     = "us-east-1"                           |
                                            }                                                    |
                                                        ____ format xxx _ nnnn  (xxx name of provider)
                                                       /
                                            resource "aws_instance" "example" {   # BLOCK 2
                                              ami           = "ami-2757f631"
                                              instance_type = "t2.micro"
                                            }


                                            The "name" is used to refer to this resource from elsewhere in the same Terraform module,
                                            but has no meaning outside of the module.
                                            Remember a module is the set of .tf/tf.json files in a dir

           - KEY VALUE PAIRS (inside the BLOCKS)
                        .  resource "aws_vpc"  "vpc"  {
                               key = value   <------------------------- this
                           }


           - EMBEDDED BLOCKS   (inside the normal blocks)
                        .  resource "aws_vpc"  "vpc"  {
                               key = value

                               embedded_bloc {   <------------------------- this
                               }
                           }

           - TYPES
                the key pair vars can be of different types:

                    string = "taco"
                    number = 5     (or also 5.670)
                    bool   = true
                    list   = ["beans" "peases"]                                    # used then as list[2]
                    map    = { name = "Ned",  age = 42,  loves_tacos = true }      # used then as map["age"]

                    any    = ex. list(any)  when I'm general
                    null   = ex of usage of a default


           - REFERENCES  (usual dot '.' notation)                                 variable "aws_instance_types" {
                    var.taco_day                                                       type = map (string)
                    aws_instance.taco_truck.name                                       description= " ... "
                    local.taco_toppings.cheese                                         default = {
                    module.taco_hut.loactions                                            small = "t3.micro"   <--- ex. I can refer to 'map' types in 2 ways:
                                                                                         medium = "m4.large"                      var.aws_instance_types.small
                    INTERPOLATION     taco_name = "neds-${var.taco_day}                  .....                                                          ^^^^^^
                                                                                                                                  var.aws_instance_types["small"]
                    * -->  aws_subnet.subnet[*].id   <----- the * in an array returns a list of all the entries                                         ^^^^^^^^^
                                             ^

------------------------------------------------------------------- main  K E Y W O R D S
    1  variable   "aws_access_key"    {
    2  provider   "aws"               {
    3  data       "aws_ami" "alx"     {   THEY ARE BLOCKS USED TO GATHER/COLLECT INFO THAT I CAN THEN REFERENCE (THEY ARE USED AT RUNTIME NOT SAVED IN THE STATE)
    4  resource   "aws_instance" "ex" {   THEY ARE THE INFRASTRUCTURE COMPONENTS CREATED BY MY TERRAFORM SCRIPT
    5  output     "aws_public_ip"     {
-------------------------------------------------------------------
    1  variables   these are vars passed as INPUT to the script
                   'variables' is a misleading name and should be called 'inputs'
                   because ALL 'variables' must have a value passed with input configs
                   via one of many ways ( ENV terraform.tfvars | terraform.tfvars.json xxx.auto.tfvars  | xxx.auto.tfvars.json -var-file -var)
                   and if at execution time terraform doesn't have values for all the vars it asks those values at prompt

                   The real variables, in the normal sense of programming languages,
                   or internal vars which I can freely define and use across my terraform code
                   are then the  'locals'
                                                                                                                __________ locals are "variable" that I define INSIDE my script.
                                                                                                               /          ^^^^^^^^   They don't come from outside
                             variable "aws_access_key" {}        # note 'variable' is a keyword              locals {                           I can refer to them as local.instance_prefix
                             variable "aws_secret_key" {}       _______________________________                   instance_prefix = "globo"                            ^^^^^
                                                                                                                  common_tags = {                          EVEN 'locals' & 'local' are keywords
                             variable "aws_region" {                                                                      company = "Some Name LTD"
                                     default = "us-east-1"                                                                region = var.aws_region
                             }                                                                                    }
                                                                                                             }        # locals can stay in any file, but usually they are put in a "locals.tf"


                          ________ 'variable' is a keyword            variables stay in  file  ./terraform.tfvars  (or variables.tf)
                         /
                      variable "region" {
                         type = string   <---------- if I submit an integer terraform will then trigger an error
                         description = "......."      <--- for documentation
                         default = "us-east-1"        <--- a default always useful.    If during exection terraform doesn't have a value for this var (no -var / TF_VAR_xxx/ default) it will prompt for a value
                         sensitive = true | false             # if 'true' not shown in logs
                      }

                      ------------------------------
                      provider "aws" {
                         region     = var.region       <--- usage   ('var' is a keyword)
                      }

                      ___________________
                                 note then that a var definition has
                                   an optional "type"
                                   an optional "default"

                                 ex:
                                      variable "cidr" {
                                          type = map(string)   <--- a map of strings
                                          default = {
                                                development = "10/0.0.0/16"
                                                staging     = "10.1.0.0/16"
                                                live        = "10.2.0.0/16"
                                          }
                                      }
                      ___________________


          - file terraform.tfvars      ex. region = "us-east-2"      files automatically sourced if present:  terraform.tfvars / terraform.tfvars.json
                 (default name)                                                                                xxx.auto.tfvars  / xxx.auto.tfvars.json
                                                                                                                   ^^^^^^^^^^^        ^^^^^^^^^^^^^^^^   <--- files with these EXTENSIONS

          - Command-line flags         ex. terraform apply  -var 'region=us-east-2'
                                                            ^^^^
                                       ex. terraform apply  -var-file=dddd/dddd/fff.tf
                                                            ^^^^^^^^^
                                                                    (when not using default terraform.tfvars | xxx.auto.tfvars)

          - ENV vars                   ex. TF_VAR_nnnnn   TF_VAR_ +  name of the ENV var
                                           (ex. TF_VAR_HOME)

          - PRECEDENCE OF VARS:

                            (  -               ENV
                            important)         terraform.tfvars | terraform.tfvars.json
                                                xxx.auto.tfvars |  xxx.auto.tfvars.json
                            (  +               -var-file
                            important)         -var

          - UI on apply                running 'apply' with missing variables, they will be asked interactively.

                                       Only supported for STRING variables.
                                       LIST and MAP vars must be populated via one of the other mechanisms.




          Primitive type:            Collection (all SAME TYPES)           Strictural (MIXED TYPES)
                   . String                 . List                              . Tuple
                   . number                 . Map                               . Object
                   . bool                   . Set
                   . any   ex. list(any)
                   . null  ex for default





          LIST VARs                    variable "cidrs" { default = [] }     # implicit assign.  ex   cidrs = [ "10.0.0.0/16", "10.1.0.0/16" ]
                                       variable "cidrs" { type = list }      # explicit      /  list(string)  / list(number) / list(bool) / ...


          MAP VARs                     hash (like a normal json with '=' instead of ':')      /  map(string)  / map(number) / map(bool) / ...
                                       variable "amis" {                                resource "aws_instance" "example" {
                                          type = "map"                                    ami        = var.amis[var.region]
                                          default = {                                     inst_type  = "t2.micro" ^^^^^^^^
                                            "us-east-1" = "ami-b374d5a5"                }
                                            "us-west-2" = "ami-4b32be2b"
                                          }
                                       }

                                      I can use MAP also on the command line style:
                                      ex.    terraform apply -var 'amis={ us-east-1 = "foo", us-west-2 = "bar" }'




          OUTPUT VARs                  I can decide what to log (OUTPUT vars) of the hundreds I have.
                                       These values are logged when running "terraform apply"

                                       They can also be QUERIED with the command

                                       "terraform output"

                                       they are defined in the shape:

                                                    ______ "output" is a keyword
                                                   /
                                                output "ip" {
                                                  value = aws_eip.ip.public_ip     # also "value" is expected.
                                                }                                    which is usually in the 'interpolation' format
                                                                                     being a value known at runtime



-------------------------------------------------------------------
    2  providers/plugins       they are the plugins I can use.
                               they are open source and written in Go

                             provider "aws" {
                                   access_key = "var.access_key"   <---------I use variables here    # note 'var.' is a keyword
                                   access_key = "var.secret_key"
                                   region = "var.aws_region"
                             }


             . here I'm using the provider/plugin "aws"
             . to use a certain provider/plugin  I must set its parameters
             . providers use semantyc versioning:  major . minor . patch
             . I can have more than 1 version for the same provider
               (ex more AWS, to control different regions with a different version if needed)
               so I can define ALIASES for providers

file: providers.tf   <------ this is the standard file where I can configure my required/ used providers

    provider "aws" {
       alias = "west"
       ...
    }                               H E R E   H O W   A   R E S O U R C E   C A N    S P E C I F Y   I T S   U S E D   P R O V I D E R :

                                    resource "aws_instance"  "web_server" {
                                        provider = aws.west
                                        ....
                                    }

-------------------------------------------------------------------
    3  Data source       THEY ARE BLOCKS USED TO GATHER/COLLECT INFO THAT I CAN THEN REFERENCE (THEY ARE USED AT RUNTIME NOT SAVED IN THE STATE)

                             data "aws_ami" "alx"  {             # note 'data' is a keyword
                                most_recent = true
                                owners = ["amazon"]
                                filter  {
                                         name = "name"
                                         values = ["amzn-ami-hvm*"]
                                }

                                filter  {
                                         name = "virtualization-type"
                                         values = ["hvm"]
                                }
                             }



-------------------------------------------------------------------
    4  Resource          THEY ARE THE INFRASTRUCTURE COMPONENTS CREATED BY MY TERRAFORM SCRIPT
                         If the infrastr. is already deployed (meaning I have a state file)
                         I can see the list of resources used as:

                                         terraform state list
                         Otherwise, if I'm missing the state file, just
                                         grep -rw "resource" /path/to/terraform/directory/*.tf
                         Or
                                         terraform plan

           Each 'provider' (i.e. aws)
           has many possible 'resources' (i.e. ec2, s3, vpc, ...)
           which I can use, and which are named as
                    PROVIDER_XXX
           ex
                    aws_instance


                             resource "aws_instance" "ex" {      # note 'resource' is a keyword
                                ami = "data.aws_ami.alx.id"
                                       ^^^^                     <----- note: I'm referencing/using a data source
                                instance_type = "t2.micro"                   'data.' is a keyword
                             }

           resource "aws_vpc"   "vpc"  {      <-----------.
             ....                                         |
           }                                              |
           resource "aws_route_table"  "rtb"  {           |
               vpc_id = aws_vpc.vpc.id                    |
                        ^^^^^^^ ^^^                       |
           }                 \./__________________ here used

    ---------------------------------
    TAINTED resources     Are the resources failed during the provisioning.
                          Terraform detroys/removes these resources
                          but it doesn't rollback (as it will be against the PLAN
                          where there isn't written anything about DESTROYing)



    ---------------------------------
    RESOURCE ARGUMENTS (bultin types)

    ____________________________________________________
    count                                                # to parameterize a bunch of resources
                 resource "aws_instance"  "tacos" {
                      count = 2

                      tags {
                           Name = "customer-${count.index}"   <---- I'll have 2 resources customer-0  / customer-1    NOTE: start from '0'
                      }                       ^^^^^
                 }

                           aws_instance.tacos[1].name      I refer to the 2nd instance
                           aws_instance.tacos[*].name      I get ALL ('*')
    ____________________________________________________
    depends_on                                           # to help to create a dependency graph
                 resource "aws_instance"  "tacos" {

                      ....
                      depends_on = [aws_iam_role_policy.allow_s3]
                 }    ^^^^^^^^^^
    ____________________________________________________
    for_each                                             # to loop through a map
                 resource "aws_instance"  "tacos" {
                      for_each = {
                           food = "public_read"
                           cash = "private"
                      }
                      bucket = "${each.key}-${var.bucket_suffix}"
                                 ^^^^^^^^^ <--------------------------- food / cash
                      acl = each.value     <------- public_read / private
                 }          ^^^^^^^^^^
-------------------------------------------------------------------
    5  Output
                       'output' is like an echo or printf
                       is a way to dump formatted output
                       output stay usually in a file called 'output.tf'

                             output "aws_public_ip" {            # note 'output' is a keyword
                                value = "https://${aws_instance.ex.public_dns}"   <---- output, like here, can be like a common shell echo "....${}.."
                                description = ....                                      where I can interpolate strings & vars
                                sensitive = true | false
                             }

                       with 'output' I can log values OUT of terraform (in the logs)
                       but also to pass values from 1 module to another

               Interestingly 'outputs' are stored in the state file
               and can be seen anytime just running
               > terraform output

--------------------------------------
    PROVISIONERS

             HashiCorp doesn't like them and hope they are used as last resort.
             Ex if provisioning an EC2, terraform doesn't know the internal status
             so it must fully trust the whole block.

                      Provisioners are mainly run when a resource is CREATED.
                      They are not a replacement for configuration management
                      and are instead just meant as a way to bootstrap a server.

                      Other Provisioners are run when a resource is DESTROYED
                      to clean up.


             Provisioners can anyhow be
                 - Local   the provisioner runs on the local computer
                 - Remote  the provisioner runs on the target host


             ex. the "file" provisioner


             provisioner "file" {
                connection {
                     type = "ssh"
                     user = "root"
                     private_key = var.private_key    <--- even "password = ..." is supported
                     host = var.hostname
                }
                source = "/local/path/to/file.txt"
                destination  = "/path/to/file.txt"
             }

             provisioner "file" {            <----- file supports even here-doc syntax
                content = <<EOF
                aaaaaa
                bbbbbb
                cccccc   <---- note, inside this here-doc I can also use interpolated values ex: ${var.....}
                EOF


             ex. the "local-exec" provisioner   (to run local cmd)

             provisioner "local-exec" {
                     command = "local cmd here"
             }



             ex. the "remote-exec" provisioner   (to run local cmd)                          resource "aws_instance" "example" {
                                                                                                 ami           = "ami-b374d5a5"
             provisioner "local-exec" {                                                          instance_type = "t2.micro"
                     scripts = ["list", "of", "local", "scripts"]
             }                                                                                   provisioner "local-exec" {   # run cmds on local host
                                                                                                   command = "echo ${aws_instance.example.public_ip} > ip_address.txt"
             provisioner "local-exec" {                                                          }
                     inline = ["sudo yum install ....",                                      }
                               "sudo cp .....",
                                sudo yum ......
                                ...
                                }
             }



-------------------------------------------------------------------
    terraform init
                                     the 1st command to run
                                     . will automatically download and install all the required providers.
                                       (telling also the version of each:
                                            ex:   provider.aws: version = "~> 2.22"
                                       )

                                    note: it’s safe to run init multiple times (the command is idempotent).



                                            ❯ ls -lrta
                                                                total 8
                                                                drwxr-xr-x  16 sbasile  staff   512 Mar 22 10:55 ..
                                                                drwxr-xr-x   3 sbasile  staff    96 Mar 22 10:56 .
                                                                -rw-r--r--   1 sbasile  staff  3653 Mar 22 10:56 main.tf
                                            ❯ terraform init

                                                                Initializing the backend...

                                                                Initializing provider plugins...
                                                                - Finding latest version of hashicorp/aws...
                                                                - Installing hashicorp/aws v5.42.0...
                                                                - Installed hashicorp/aws v5.42.0 (signed by HashiCorp)
                                                                 ...
                                                                 ...
                                            ❯ ls -lrta
                                                                total 16
                                                                drwxr-xr-x  16 sbasile  staff   512 Mar 22 10:55 ..
                                                                -rw-r--r--   1 sbasile  staff  3653 Mar 22 10:56 main.tf
                                                                drwxr-xr-x   3 sbasile  staff    96 Mar 22 11:56 .terraform
                                                                -rw-r--r--   1 sbasile  staff  1377 Mar 22 11:56 .terraform.lock.hcl
                                                                drwxr-xr-x   5 sbasile  staff   160 Mar 22 11:56 .
                                            ❯ cat .*.hcl
                                                                # This file is maintained automatically by "terraform init".
                                                                # Manual edits may be lost in future updates.

                                                                provider "registry.terraform.io/hashicorp/aws" {
                                                                  version = "5.42.0"
                                                                  hashes = [
                                                                    "h1:0lkSSlK45Qil9fO1kFy8RXVC/k6qfC4LDZIaCKnWcUc=",
                                                                    "zh:0fb12bd56a3ad777b29f957c56dd2119776dbc01b6074458f597990e368c82de",
                                                                    "zh:16e99c13bef6e3777f67c240c916f57c01c9c142254cfb2720e08281ff906447",
                                                                    "zh:218268f5fe73bcb19e9a996f781ab66df0da9e333d1c60612e3c51ad28a5105f",
                                                                    "zh:220b17f7053d11548f35136669687d30ef1f1036e15393275325fd2b9654c715",
                                                                    "zh:2256cfd74988ce05eada76b42efffc6fe2bf4d60b61f57e4db4fcf65ced4c666",
                                                                    "zh:52da19f531e0cb9828f73bca620e30264e63a494bd7f9ce826aabcf010d3a241",
                                                                    "zh:56069ce08d720280ba39aaf2fdd40c4357ffb54262c80e4d39c4e540a38e76af",
                                                                    "zh:82c81398e68324029167f813fbb7c54fa3d233e99fa05001d85cbce8bdd08bb3",
                                                                    "zh:82d6eaa87f5ab318959064e6c89adc2baabaf70b13f2f7de866f62416de05352",
                                                                    "zh:9b12af85486a96aedd8d7984b0ff811a4b42e3d88dad1a3fb4c0b580d04fa425",
                                                                    "zh:ade8490cfdd8de8b9a82986588595b67e0ad1048d9e2d3a6f5164320179c2cd0",
                                                                    "zh:b094ef56ae9bfffd586f46d4f7fb0097798738df758a8f3c51578ee163495c7e",
                                                                    "zh:bd5e68e1e454bae0f8d73cff8448e814a35855a561c33b745e1b8b525fb06c9f",
                                                                    "zh:c111c6a854bf121facca1642d528bfa80fb4214554ac6c33e4a59c86bc605b71",
                                                                    "zh:e04df69a557adbcdf8efc77eb45be748f0acbe800ccede1e0895393c87722a0f",
                                                                  ]
                                                                }
                                            ❯ find .terraform
                                                                .terraform
                                                                .terraform/providers
                                                                .terraform/providers/registry.terraform.io
                                                                .terraform/providers/registry.terraform.io/hashicorp
                                                                .terraform/providers/registry.terraform.io/hashicorp/aws
                                                                .terraform/providers/registry.terraform.io/hashicorp/aws/5.42.0
                                                                .terraform/providers/registry.terraform.io/hashicorp/aws/5.42.0/darwin_amd64
                                                                .terraform/providers/registry.terraform.io/hashicorp/aws/5.42.0/darwin_amd64/terraform-provider-aws_v5.42.0_x5

    terraform show                      to see current state.


    terraform plan -out  here.myplan

    terraform apply                     to apply changes   (I must type 'yes') so if I don't type 'yes' the apply doesn't change
    terraform apply here.myplan

    terraform destroy                            # will destroy all the 'resources'


    terraform console                            # if I run in a dir with terraform config files, it will source them first
                                                  this can give errors if the "providers" listed there were downloaded already
                                                  so I can just do a
                                                             $ terraform init
                                                  to pull them.
                    ╰─ terraform console
                    > min(4,6,89)
                    4
                    > lower("TACOS")
                    tacos
                    > 5 + 3
                    8
                    >


                    ╰─ cat test.tf
                    variable "region" {
                       default = "us-east-1"
                    }

                    ╰─ terraform console -var-file="test.tf"
                    > var.region
                    us-east-1
                    >

    terraform fmt                  format & check for SYNTAX-only errors
                                                    -check       doesn't change the files, just Exit status will be 0 if all ok
                                                    -recursive   (goes on subdirs)
    terraform check
    terraform validate             check for syntax & logic errors


    terraform graph                shows the dependency in the DOT language description format.
                                    digraph {
                                            compound = "true"
                                            newrank = "true"
                                            subgraph "root" {
                                                    "[root] aws_instance.example1 (expand)" [label = "aws_instance.example1", shape = "box"]
                                                    "[root] aws_security_group.schiro45 (expand)" [label = "aws_security_group.schiro45", shape = "box"]
                                                    "[root] provider[\"registry.terraform.io/hashicorp/aws\"]" [label = "provider[\"registry.terraform.io/hashicorp/aws\"]", shape = "diamond"]
                                                    "[root] aws_instance.example1 (expand)" -> "[root] aws_security_group.schiro45 (expand)"
                                                    "[root] aws_security_group.schiro45 (expand)" -> "[root] provider[\"registry.terraform.io/hashicorp/aws\"]"
                                                    "[root] provider[\"registry.terraform.io/hashicorp/aws\"] (close)" -> "[root] aws_instance.example1 (expand)"
                                                    "[root] root" -> "[root] provider[\"registry.terraform.io/hashicorp/aws\"] (close)"
                                            }
                                    }
                                    I can copy paste this into something like: http://dreampuf.github.io/GraphvizOnline/
                                    for visualisation




-------------------------------------------------------------------

Terraform Cloud           Is the commercial solution to store my 'Terraform state' file in a remote space (called "backend")
                          shared with other team's members. (to do, versioning, audit, peer review....)


                          terraform {                                        when running  "terraform init"
                                  backend "remote" {                ----->   and answering "yes"
                                    organization = "Cloud-Org"               the state is copied to Terraform Cloud

                                    workspaces {                             "terraform apply"  will check (like git pull)
                                      name = "Dev-QA"                        the remote and if there is nothing to do
                                    }                                        will output
                                  }                                              No changes. Infrastructure is up-to-date.
                                }
                                                                             REMOVING THE "backend" BLOCK FROM THE CONFIG FILE
                                                                             AND RUNNING "terraform init" IT WILL BE
                                                                             MOVED BACK LOCALLY FROM Terraform Cloud










-------------------------------------------------------------------
Terraform language

          Code style:
                       1.  run "terraform fmt" &
                               "terraform validate"
                       2.  run linter  (ex. (third party) TFLint -->  https://github.com/terraform-linters/tflint)
                       3.  use under_score_s  (for long_name_words)
                       4.  for every var:
                                 "type"        = ....
                                 "description" = ....
                                 "default"     = ....  <---- only if var is OPTIONAL
                                 "sensitive"   = true/false <--- remember that sensitive vars are saved as plain text in the STATE file
                                 validation {
                                 }

                                 example:

                                    variable "web_instance_count" {
                                      type        = number
                                      description = "Number of web instances to deploy. (at least 2)."

                                      validation {
                                        condition     = var.web_instance_count > 1
                                        error_message = "This application requires at least two web instances."
                                      }
                                    }
                       5.  indentation: 2 spaces for each nesting level
-------------------------------------------------------------------
    Ex. Deploy a VPC

           resource "aws_vpc"                     "vpc"  {}
           resource "aws_internet_gateway"        "igw"  {}
           resource "aws_subnet"                  "subnet1"  {}
           resource "aws_route_table"             "rtb"  {}
           resource "aws_route_table_association" "rta-subnet1"  {}
-------------------------------------------------------------------
    PATH EXPRESSION
         . ${path.root}          ROOT     module            ex.  ... source = "${path.root}/${each.value}"
         . ${path.module}        CURRENT    "
         . ${path.cwd}           CURRENT working dir
-------------------------------------------------------------------
    TERRAFORM FUNCTIONS


             groupped by categories.
             ex.
                 - Numeric            min (42,13,7)        ---> 7
                 - String             lower ("TACOS")      ---> tacos
                 - Collection
                            - lists
                            - maps    merge (map1,map2)   ---> (map1,map2)
                 - Filesystem         file (path)
                 - IP network         cidrsubnet()
                 - Date/time          timestamp()         ---> current time



       ex
               variable network_info { default = "10.1.0.0/16" }

               cidr_block = cidrsubnet (var.network_info, 8, 0)   ---> 10.1.0.0/24

               host_ip = cidrhost (var.network_info, 5)           ---> 10.1.0.5



       ex
               variable "amis" {
                   type = "map"

                   default = {
                       us-east-1 = "ami-1234"
                       us-east-2 = "ami-5678"
                   }
               }

               ami = lookup (var.amis, "us-east-1", "error")



-------------------------------------------------------------------
apply
                aws_vpc.app: Creating...
                aws_vpc.app: Still creating... [10s elapsed]
             1  aws_vpc.app: Creation complete after 13s [id=vpc-0d7c0c18d08684de2]
                aws_internet_gateway.app: Creating...
                aws_subnet.public_subnet1: Creating...
                aws_security_group.nginx_sg: Creating...
             2  aws_internet_gateway.app: Creation complete after 2s [id=igw-0e28ddbb0b789e10b]
                aws_route_table.app: Creating...
             3  aws_route_table.app: Creation complete after 2s [id=rtb-0c8335495b90bf813]
             4  aws_security_group.nginx_sg: Creation complete after 4s [id=sg-03cc3030e5f8b5269]
                aws_subnet.public_subnet1: Still creating... [10s elapsed]
             5  aws_subnet.public_subnet1: Creation complete after 12s [id=subnet-07d33827fac2bbfcd]
                aws_route_table_association.app_public_subnet1: Creating...
                aws_instance.nginx1: Creating...
             6  aws_route_table_association.app_public_subnet1: Creation complete after 1s [id=rtbassoc-02a928530f121c57a]
                aws_instance.nginx1: Still creating... [10s elapsed]
             7  aws_instance.nginx1: Creation complete after 14s [id=i-029d84576048bc357]

    Apply complete! Resources: 7 added, 0 changed, 0 destroyed.

destroy
                aws_route_table_association.app_public_subnet1: Destroying... [id=rtbassoc-02a928530f121c57a]
                aws_instance.nginx1: Destroying... [id=i-029d84576048bc357]
             1  aws_route_table_association.app_public_subnet1: Destruction complete after 0s
                aws_route_table.app: Destroying... [id=rtb-0c8335495b90bf813]
             2  aws_route_table.app: Destruction complete after 1s
                aws_internet_gateway.app: Destroying... [id=igw-0e28ddbb0b789e10b]
                aws_instance.nginx1: Still destroying... [id=i-029d84576048bc357, 10s elapsed]
                aws_internet_gateway.app: Still destroying... [id=igw-0e28ddbb0b789e10b, 10s elapsed]
                aws_instance.nginx1: Still destroying... [id=i-029d84576048bc357, 20s elapsed]
                aws_internet_gateway.app: Still destroying... [id=igw-0e28ddbb0b789e10b, 20s elapsed]
                aws_instance.nginx1: Still destroying... [id=i-029d84576048bc357, 30s elapsed]
                aws_internet_gateway.app: Still destroying... [id=igw-0e28ddbb0b789e10b, 30s elapsed]
                aws_instance.nginx1: Still destroying... [id=i-029d84576048bc357, 40s elapsed]
             3  aws_internet_gateway.app: Destruction complete after 39s
                aws_instance.nginx1: Still destroying... [id=i-029d84576048bc357, 50s elapsed]
             4  aws_instance.nginx1: Destruction complete after 51s
                aws_subnet.public_subnet1: Destroying... [id=subnet-07d33827fac2bbfcd]
                aws_security_group.nginx_sg: Destroying... [id=sg-03cc3030e5f8b5269]
             5  aws_subnet.public_subnet1: Destruction complete after 1s
                aws_security_group.nginx_sg: Destruction complete after 2s
             6  aws_vpc.app: Destroying... [id=vpc-0d7c0c18d08684de2]
             7  aws_vpc.app: Destruction complete after 1s

    Destroy complete! Resources: 7 destroyed.
-------------------------------------------------------------------
Terraform - Getting Started                  By Ned Bellavance   4h 36m
Terraform Deep Dive                          By Ned Bellavance   3h 50m
Managing Infrastructure with Terraform       path               18h 34m
HashiCorp Certified: Terraform Associate                        11h 44m
