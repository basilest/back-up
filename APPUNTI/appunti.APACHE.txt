  
'httpd'          The httpd web server was developed by the 
                 Centre d'Etudes et de Recherche Nucléaires (CERN) in Geneva, Switzerland
                 When CERN stopped funding the development of httpd, 
                 it was taken over by the Software Development Group of the 
                 National Center for Supercomputing Applications (NCSA). 
                 The NCSA also produced Mosaic, the first web browser, 
                 (later Netscape).

                 1. at the origin only static documents. Mosaic retrieved them from httpd
                 2. Rewritten to allow dynamic data (ex. submitted by the user in a form)
                    NCSA developed the Common Gateway Interface (CGI) specification. 

httpd     it receives args (stop, start, reload, restart)
          it read the a conf file (usually  /etc/httpd/conf/httpd.conf)
          it writes in a log file (usually   /var/log/httpd/error_log)

_________________________ static / dynamic

           httpd is the APACHE executable

           it can 
           - be compiled static (old way)
           - dynamic (DSO: Dinamyc Shared Object) 
             it loads runtime the required modules.

_________________________  

[sbasile@wswebdev1 ~]$ httpd -v
Server version: Apache/2.2.8 (Unix)
Server built:   Feb 26 2009 22:38:17

[sbasile@wswebdev1 ~]$ httpd -h
Usage: httpd [-D name] [-d directory] [-f file]
             [-C "directive"] [-c "directive"]
             [-k start|restart|graceful|graceful-stop|stop]
             [-v] [-V] [-h] [-l] [-L] [-t] [-S]
Options:
  -D name            : define a name for use in <IfDefine name> directives
  -d directory       : specify an alternate initial ServerRoot
  -f file            : specify an alternate ServerConfigFile
  -C "directive"     : process directive before reading config files
  -c "directive"     : process directive after reading config files
  -e level           : show startup errors of level (see LogLevel)
  -E file            : log startup errors to file
  -v                 : show version number          <--------------------- -v
  -V                 : show compile settings
  -h                 : list available command line options (this page)
  -l                 : list compiled in modules          <---------------- -l
  -L                 : list available configuration directives <---------- -L 
  -t -D DUMP_VHOSTS  : show parsed settings (currently only vhost settings)
  -S                 : a synonym for -t -D DUMP_VHOSTS
  -t -D DUMP_MODULES : show all loaded modules <-------------------------- -t -D DUMP_MODULES
  -M                 : a synonym for -t -D DUMP_MODULES <-----------------  -M     
  -t                 : run syntax check for config files

_________________________  httpd -l

httpd -l   lists the static compiled modules.
           If there is mod_so.c
           it's in the DSO version.
           so it can be extended runtime.
      with the -M (added from Apache version 2.2) I can see 
      all the mod for my configuration (no only the 'compiled'
      but also the loaded dynamically through the 'mod_so' command).

_________________________  mod_perl

           with httpd -l 
           I can also see it mod_perl is already compiled
           inside or not.
           The module name is mod_perl.c


DSO (Dinamyc Shared Object) - mod_so.c. 
          httpd is built by compiled static modules. (you can see them
          with httpd -l).
          But from version 1.3, it can be dynamically extended (DSO modules).
          This means some modules are loaded also at runtime.
          So with the same httpd, I can sometime launch a version with 
          will load mod_perl, so specific for Perl CGI, while some other times
          I can run it loading some PHP specific modules, making the server
          optimized for PHP.
          In both cases the unix process running is httpd.
          mod_so.c is the module which allow the DSO feature. See with
          http -l, if it's present so, if your static httpd can be dynamically customized.

          TO LOAD A MODULE: use mod_so

          TO CUSTOMIZE httpd : use http.conf, with the sections <IfModule> ex:

                               <IfModule mod_perl.c>
                                  .....
                               </IfModule>
                               
                               the instructions inside, are executed only if 
                               that module is loaded (static or dynamic).


------------------------ APACHE MAIN DIRECTIVES


ServerRoot     (ex  ServerRoot "/etc/httpd")
                the top-level directory containing website content.
                Other command can speify absolute paths or relative (which
                are the relative to 'ServerRoot' value)

PidFile        (ex PidFile /tmp/sbasile.pid)
               the file where the server records its process ID (PID

Timeout        (ex Timeout 120) 
               the time (in seconds) the servers wait answers.

KeepAlive      (ex KeepAlive Off)
               if the server allows more than 1 request per connection
               Witn 'ON' the server becomes very busy
               and can quickly spawn the maximum number of childs

MaxKeepAliveRequests  (ex MaxKeepAliveRequests 100)
                maximum number of requests allowed per persistent connection

KeepAliveTimeout      (ex KeepAliveTimeout 15)
                num of sec staying alive after having served a request.

<IfModule> .. </IfModule>     (            <IfModule prefork.c>
                              (or negated: <IfModule !prefork.c> )
                To wrap instructions depending on the fact that the module with the
                name spcified, has been loaded (or ! not loaded)
                The main instructions included in each <IfModule> block are:

                StartServers     (ex StartServers 2)
                                 num of server processes created upon startup.
                                 The server starts with this value, then adds
                                 or removes further proc as they are required.

                MaxRequestsPerChild     (ex MaxRequestsPerChild 4000)
                                  number of requests each child serves before dies.

                MaxClients       (ex MaxClients 256)
                                 num of max client browsers at the same time.

                ThreadsPerChild  (ex ThreadsPerChild 25)
                                 the maxnum of treads per child.

                MinSpareServers /MaxSpareServers (ex Min.. 1 Max.. 2)
                                 Defines the range. The num of running servers
                                 waiting for an answer should be inside this range.
                                 If is more, some of the running servers are killed.
                                 If it's less, some new server are created.

                MinSpareThreads /MaxSpareThreads (ex Min.. 25 Max.. 75)
                                 the same as above, referribg to the server treads.

Listen          (ex Listen 192.168.60.201:4055)
                addr &  the ports on which accept incoming requests
                default port is 80  for non-secure Web communication
                                443 for secure     Web communications. 
                port under 1024, only the root user can start it

Include         (ex Include /home/sbasile/apache2/conf.d/*.conf)
                allows other configuration files to be included at runtime.
                path can be absolute or relative to the ServerRoot

LoadModule      (ex LoadModule perl_module modules/mod_perl.so)
                 to load in Dynamic Shared Object (DSO) modules.
                 The order of the modules is no longer important with Apache 2.0.

IfDefine        (ex <IfDefine PERLDB> ..</IfDefine>)
                 to wrap isntructions if a certain tag is defined

User            (User sbasile)
                 pass to the server the same rights this user has on files
                 So the server is not allowed to manage files that this user 
                 is not allowed to manage.

Group           (ex Group devel)
                 the same as User, but for the group.

ServerAdmin      (ex ServerAdmin root@localhost)
                 the email of the Web server admin.

ServerName      (ex ServerName wswebdev1.orctel.internal:4055)
                 a valid DNS name, with hostname+port (with port matching 'Listen')
                 No need to match the machine's actual hostname.

UseCanonicalName (ex UseCanonicalName Off)
                 If Off the server references itself using the value in clients request
                 If On  "               "       "            " ServerName

DocumentRoot    (ex DocumentRoot "/home/sbasile/htdocs/")
                 Is considered the root from where the path in request is 'appended'
                 request: http://example.com/foo.html
                 path in request: foo.html
                 file to locate: /home/sbasile/htdocs/ + foo.html

<Directory /path/to/directory> .. </Directory>      (ex <Directory "/home/sbasile/htdocs/">)
                 to wrap instructions that refer to that dir + subdir
                 Usually options start with restricted values on /
                 and where required (specific dirs) they are lightened.
                 Ex in dirs where there are CGI scripts other than specified 
                 with 'ScriptAlias' its commond to give them the +ExecCGI options.

                 <Directory /home/my_cgi_directory>
                     Options +ExecCGI
                 </Directory>

Options         (ex Options FollowSymLinks)
                 to give specific feature to a directory.
                 Indexes        allows the server to generate a directory listing 
                 FollowSymLinks allows the server to follow symbolic links in that directory. 
                 AllowOverride  allows to override options with values 
                                coming from files .htaccess present in that dir.
                 Allow          "all", a domain name, an IP address, a partial IP, ...
                                specifies who can access that dir
                 Deny           opposite of Allow
                 Order          specify which of Allow and Deny is evaluated first.

UserDir         (ex UserDir "public_html")
                 it's the name of a sub-dir that in the case a request specifying a username
                 (ex. http://example.com/~username/foo.html)
                 is appended to the user home (/home/username):
                 /home/username/   +   public_html/   +  foo.html
                      711                   755            644
                       ^                     ^              ^   <-----the permissions
                 
DirectoryIndex  (ex DirectoryIndex index.html index.html.var)
                 a list of default files (the first that is found) to return
                 when a request is received requesting a dir (ending with /
                 ex. http://example/this_directory/          )

AccessFileName  (ex AccessFileName .htaccess)
                 The name for the files which extend control on the Options.
                 After this, there is usually an instruction:
                             <Files ~ "^\.ht"> 
                                    Order allow,deny
                                    Deny from all
                             </Files>
                 which applies access control to any file beginning with .ht

TypesConfig     (ex TypesConfig /etc/mime.types)
                 to specify the file containing the list of MIME types.

AddType         (ex AddType application/x-tar .tgz)
                 to override a MIME type & extension

DefaultType     (ex DefaultType text/plain)
                 to redirect on a default type any unmatched MIME.

HostnameLookups (ex HostnameLookups Off)
                 on    the server automatically resolves the IP address for each connection
                       This adds overhead for the extra DNS request
                 double  a double-reverse DNS look up adding even more processing overhead. 
                 off   (default) 

ErrorLog        (ex /var/log/httpd/sbasile_error_log)

LogLevel        (ex LogLevel warn)
                 To specify the verbosity in ErrorLog: emerg, alert, crit, error, warn, notice, info, debug

LogFormat       (ex LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"" combined
                    LogFormat "%h %l %u %t \"%r\" %>s %b" common
                    LogFormat "%{Referer}i -> %U" referer
                    LogFormat "%{User-agent}i" agent
                 To specify the format in log files (bot error_log and  /var/log/httpd/access_log)
                             %h   remote IP
                             %u   authenticated user. Usually, not used, so a hyphen [-] appears for this field. 
                             %t   date
                             %r   request string exactly as it came from the browser or client
                             %s   status code which was returned to the client host. 
                             %b   size (bytes) of the document.
                             %\"%{Referer}i\" (referrer)    the URL the client referred to the server
                             %\"%{User-Agent}i\" (user-agent)  the type of browser 

      (ex LoadModule perl_module modules/mod_perl.so)
                 to load in Dynamic Shared Object (DSO) modules.

Alias           (ex Alias /images/ "/home/sbasile/htdocs/efiling/images/")
                 allows dir outside the DocumentRoot to be accessible.
                 Any URL ending in the alias automatically resolves to the alias' path. 
                 That dir can be accessed by the Web server, even if it's not in the DocumentRoot. 

ScriptAlias      (ex ScriptAlias /cgi-bin/ "/var/www/cgi-bin/")
                 Generally, it is not good practice to leave CGI scripts within the DocumentRoot
                 (as they can potentially be viewed as text documents).
                 This dir so (outside DocumentRoot) addresses those CGI scripts.

Redirect        (ex Redirect /foo http://www.example.com/bar)
                 to map the file location to a new URL.
                 For more advanced redirection techniques, use the mod_rewrite module.

IndexOptions    (ex IndexOptions FancyIndexing VersionSort NameWidth=*)
                 to decide how an index should be displaied
                    FancyIndexing   allows to resort clicking on column header
AddDescription   (ex. AddDescription "GZIP compressed tar archive" .tgz)
                 adds a short description to files, when a dir index must be returned. 

AddIconByEncoding (ex AddIconByEncoding (CMP,/icons/compressed.gif) x-compress x-gzip)
AddIconByType     (ex AddIconByType (TXT,/icons/text.gif) text/*)
                 to associate icons to some MIME types. 
                 They will be used if a dir index must be returned.

AddIcon         (ex AddIcon /icons/binary.gif .bin .exe)
                 the same as AddIconBy.. but on file extension instead of MIME type.

DefaultIcon      (ex DefaultIcon /icons/unknown.gif)
                 to associate an icon when no other has been found.

ReadmeName      (ex ReadmeName README.html)
                 the path to a file whose content (in HTML first, otherwise plain text)
                 that will be added when building an index to return.

HeaderName      (ex HeaderName HEADER.html)
                 the path to a file whose content (in HTML first, otherwise plain text)
                 that will be prepended when building an index to return.

IndexIgnore     (ex .??* *~ *# HEADER* README* RCS CVS *,v *,t)
                 file extensions, (wildcard allowed)  or full filenames. to exlude
                 when building an index to return.

AddLanguage     (ex AddLanguage de .de)
                 associates file name extensions with specific languages.

LanguagePriority(ex LanguagePriority en ca cs da de el eo es et fr he hr it ja ko ltz nl nn no pl pt pt-BR ru sv zh-CN zh-TW)
                 sets precedence for different languages in case the client browser has no preference set. 

AddHandler      (ex AddHandler cgi-script .cgi)
                 maps file extensions to specific handlers.

Action          (ex Action media/type /cgi-script/location)
                  specifies a pair MIME type / CGI script, 
                  so that whenever a file of that type is requested, 
                  a particular CGI script is executed. 

ErrorDocument   (ex ErrorDocument 400 /error/HTTP_BAD_REQUEST.html.var)
                 associates an HTTP response code with 
                           a message ( must be enclosed in "")
                           an URL 
                           a file
                 to be sent back to the client.

BrowserMatch    (ex BrowserMatch "^WebDAVFS/1.[012]" redirect-carefully)
                 take appropriate actions based on the User-Agent HTTP header

<Location> .. </Location>   (ex. <Location /perl-status>)
                 wraps instructions (normally access control)
                 based on an URL. (so if the url is http://..../perl_status)
                                   that block is activated.

ProxyRequests   (ex ProxyRequests On)
                 To configure the Apache HTTP Server to function as a proxy server,

Proxy           (ex  <Proxy *> 
                       Order deny,allow 
                       Deny from all
                       from .example.com 
                      </Proxy>
                 Many directives which are allowed within <Directory> may also be used

ProxyVia        (ex ProxyVia On)
                 Controls the HTTP header called 'Via'
                 On    shows the hostname
                 Full  shows the hostname + Apache version
                 Off   lines unchanged
                 Block lines removed

<VirtualHost> .. </VirtualHost> (ex <VirtualHost *:4055>)
                 to wrap a virtualhost configuration
                 It must be specified an IP addr and port num.
                 Then, inside the block <VirtualHost> ...</>
                 it must be set a "ServerName" tag
                 (ex ServerName wswebdev1.orctel.internal:4055)


NameVirtualHost (ex NameVirtualHost *:4055)
                 associates an IP and port number, for any name-based virtual hosts.

------------------------ 11 PHASES
When Apache receives a request, it processes it in 11 phases.
Each has an handler. You can overwrite/extend this standard handler with any Perl code.

   1. Post-read-request   : all data from request has been read. HTTP parsing is over
   2. URI translation     : resolve the url to the file on the server (if static) otherwise creates it on the fly
   3. Header parsing      : the header of the request is examined
   4. Access control      : checks the rights to acess the resources (ex IP address)
   5. Authentication      : checks the user (ex with a login form)
   6. Authorization       : authenticated users, can now access all or only some of the available services
   7. MIME type checking  : is used to figure out which handler to activate
   8. Fixup               : is the last phase to still order things before the handler is started
   9. Response            : is the phase of the real work to build the response file
                            is where mod_cgi, Apache::Registry or other content handler run.
  10. Logging             : writes the configured logs (ex. error_log)
  11. Cleanup             : is the phase where modules are allowed to perfrom clean up code.

                    
                 wait   __ 1
                       /      2
                      /  .       3
               11    /  .          4
                    / .              5     Each phase logs
                  _/               6
               10 __________     7
                            \ 8
                           9
    Apache itself is a small core of functions. 
    It's then extended by MODULES (both static and dynamic)
    each of which can be enable at runtime.
    Each MODULE can subsrcibe its handlers, to one or more phases.
    Apache is written in C. Once mod_perl (also written ijn C)
    is loaded, it can accept that some handlers inside mod_perl
    are written in Perl.
    When any of this Perl handler is registered to a phase,
    it will be triggered by mod_perl when Apache says to
    mod_perl that it's the time for that phase.
    mod_perl translates any Perl API into the C API of Apache.

    mod_perl handlers are not limited to the Response phase (called "content generation")
    as mod_cgi or Apache::Registry but can be linked to any phase.
    
------------------------ 

to tun APACHE, execute the script "apachectl" with (start|stop)
nb. if the port to listen on, is the default 80, 
    (or any other under 1024) "apachectl" must be run as root.

The dir wher APACHE is installed (ex /usr/local/apache), 
must be the value "ServerRoot" in httpd.conf
Many directives (like ErrorLog : logs/error_log) have relative path on it:
error_log absolute path: /usr/local/apache/ + logs/error_log


mod_perl in httpd.conf:  It is possible to place mod_perl’s con-
                         figuration directives anywhere in httpd.conf, 
                         but adding them at the end seems to
                         work best in practice.


                        Alias /perl/ /home/ste/modperl/    <---- any Url starting with /perl 
                        PerlModule Apache::Registry              will be managed by scripts 
                        <Location /perl/>                        in /home/ste/modperl
                            SetHandler perl-script
                            PerlHandler Apache::Registry
                            Options +ExecCGI
                            PerlSendHeader On
                            Allow from all
                        </Location>

mod_perl and '#!'     the line #!/usr/bin/perl 
                      can be skipped in Perl files executed 
                      by mod_perl has handlers.








------------------------ MOD_PERL_CONFIG <START>
mod_perl: 1996 Doug MacEachern (from Apache Software Foundation).
          Integrates a PERL intrpreter inside APACHE server.

          - This allows to write new APACHE modules in Perl besides C.
          - I can include Perl code in http.conf
            in the sections <Perl></Perl>.
            Te format is:
               <Perl>
                 #!perl
                 ...      <----- any kind of perl code here
                 __END__                   ^
              </Perl>                      |
                             to test that this perl code is ok
                             I can call the perl interpreter directly on http.conf
                             as:
                                 >perl -cx http.conf

                             -x   ignore any line #!perl
                             -c   acts a syntax check (compilation only with no execution-interpretation)
                                  The __END__ allows to stop 
              
        

CGI:             A CGI program can be written in virtually any language that can read from 
                 STDIN and write to STDOUT, regardless of whether 
                             it is interpreted (e.g., the Unix shell), 
                             compiled (e.g., C or C++), 
                             a combination of both (e.g., Perl). 
                 The first CGI programs were written in C and needed to be compiled into binary executables. 
                 For this reason, the directory from which the compiled CGI programs were executed was named cgi-bin, 
                 and the source files directory was named cgi-src. 
                 Nowadays most servers come with a preconfigured directory cgi-bin. (Ubuntu /usr/lib/cgi-bin/)

HTTP             Interaction between the browser and the server is governed by the HyperText Transfer Protocol (HTTP)
                 standard maintained by the World Wide Web Consortium (W3C)

                 a simple request/response model: Requests and responses takes the form of 'messages'

                 A message is a simple sequence of text LINES, structured as

                 HEADERS     BLANK_LINE     BODY

                 First come the headers, which hold descriptive information in a set of key-value pair.
                 There are various types of headers (their contents are fully specified by the HTTP protocol) 
                 Headers are followed by a blank line, then by the message body.
                 The body is the actual content of the message, such as an HTML page or a GIF image. 
                 It's not HTTP to specify the standard for the body but each header describes its body structure.

                 HTTP is a stateless protocol. This means that requests are not related to each other. 
                 This makes life simple for CGI programs: they need worry about only the current request.
                 
                 .---------------------------------------.
                 | #!/usr/bin/perl -Tw                   | -w (enable warning) -T (enable some checks)
        a.pl     |                                       |
                 | print "Content-type: text/plain\n\n"; |<--- 2 \n, as 1 is the blank line to start the body
                 | print "Hello world!\n";               |
                 '---------------------------------------'

                   1.  text/plain is a Multipurpose Internet Mail Extensions (MIME) type. 
                       Other examples of MIME types are 
                                       text/html  (text in HTML format) 
                                       video/mpeg (a MPEG stream).
                   2.  mv a.pl into a cgi-bin dir
                   3.  chmod +x
                   4.  go to http://localhost/cgi-bin/a.pl

PASS DATA:        http://localhost/cgi-bin/a.pl?username=Doug  <-------- GET (passing it in the URI)   GET-URI
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^
                          PATH to the SCRIPT         QUERY_STRING


                  <form action="/cgi-bin/a.pl" method="GET">  <---- GET  in a form  GET-form
                  <form action="/cgi-bin/a.pl" method="POST"> <---- POST in a form
                  <input type="text" name="username">
                  <input type="submit">
                  </form>

                  GET: the GET method at the end always passes params in the
                  URI. Even if HTTP does not specify a limit, Apache and some
                  client do (8K: 8192 char). Older version and WAP phones even less: 255
                  Larger size needs a POST.

CGI.pm :         The most widely used CGI library is the CGI.pm module.
                 it provides an easy API to generate the HTML response.
                 
                   #!/usr/bin/perl
                     
                   use CGI qw(:standard);  <------------------------    importing a group of functions called :standard
                   my $username = param('username') || "unknown";  <--  We use its param () function to retrieve the value of the key: username.
                                                                        (It retrieves whichever of the methos was used to pass the data:
                   print "Content-type: text/plain\n\n";                 GET-URI, GET-form, POST-form)
                   print "Hello $username!\n";                   
                   
                 So the script can think to print plain text, not HTML

                   print header("text/plain");    can be used instead of  print "Content-type: text/plain\n\n";
                   
& ,             More params can be separated by both & and , 
                ex.
                     http://           ...                 ?a=foo&b=bar&c=foobar
                CGI.pm (as well as mod_perl and Apache::Request) can manage both.
                Take only care when the values in the param contain those chars.
                    A fast way to get could be:

                  for my $key ( param () ) {
                         print "$key => ", param($key), "\n";
                   }

mod_cgi        Apache server processes CGI scripts via a module mod_cgi 
               (built by default with the Apache core)
                the installation procedure also preconfigures a cgi-bin directory 
                and populates it with a few sample CGI scripts. 

               In Apache it could be configured as:

               ScriptAlias /cgi-bin/ /home/httpd/cgi-bin/   <--- the association with the real path 

               <Directory /home/httpd/cgi-bin>
                   Options FollowSymLinks  
                   Order allow,deny         
                   Allow from all         
               </Directory>

%ENV           mod_cgi can access server vars by ENV var.
               ex. 
                 for (keys %ENV) {
                       print "$_ => $ENV{$_}\n";
                 }
                which produces:
                
                NLS_LANG => ENGLISH_UNITED KINGDOM.UTF8
         -----> SCRIPT_NAME => /bin/vars.pl
                ORACLE_HOME => /usr/local/oracle/product/10.2.0
         -----> REQUEST_METHOD => GET
                HTTP_ACCEPT => text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
         -----> SCRIPT_FILENAME => /home/sbasile/htdocs/efiling/handlers/bin/vars.pl
                LC_ALL => en_GB.UTF-8
         -----> SERVER_SOFTWARE => Apache/2.0.52 (Red Hat)
                SESSION_TOKEN => DummyToken
                QUERY_STRING => 
                REMOTE_PORT => 54075
                HTTP_USER_AGENT => Mozilla/5.0 (Windows NT 6.1; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0
                SERVER_SIGNATURE => <address>Apache/2.0.52 (Red Hat) Server at wswebdev1.orctel.internal Port 4055</address>
                
                HTTP_ACCEPT_LANGUAGE => en-GB,en;q=0.5
         -----> PATH => /usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/opt/CollabNet_Subversion/bin/:/usr/local/oracle/product/10.2.0/bin:/home/sbasile/bin
                MOD_PERL_API_VERSION => 2
         -----> GATEWAY_INTERFACE => CGI/1.1   <-----------------   when running under mod_perl the value is "CGI-Perl/1.1"
         -----> SCRIPT_URL => /bin/vars.pl
         -----> DOCUMENT_ROOT => /home/sbasile/htdocs/efiling/
                SERVER_NAME => wswebdev1.orctel.internal
                HTTP_ACCEPT_ENCODING => gzip, deflate
         -----> SERVER_ADMIN => sbasile@companieshouse.gov.uk
         -----> SESSION_COOKIES => 1
                HTTP_CONNECTION => keep-alive
                SCRIPT_URI => http://wswebdev1.orctel.internal:4055/bin/vars.pl
                SESSION_ID => 
         -----> SERVER_PORT => 4055
                HTTP_COOKIE => _pk_id.6.f375=8cd80679a9c4d9ef.1433769921.2.1433831714.1433771233.; ch_session=1
                REMOTE_ADDR => 172.19.231.106
         -----> SERVER_PROTOCOL => HTTP/1.1 <---------    HTTP version agreed between client and server during the negotiation phase 
                REQUEST_URI => //bin/vars.pl              
         -----> SERVER_ADDR => 192.168.60.201
         -----> HTTP_HOST => wswebdev1.orctel.internal:4055
                MOD_PERL => mod_perl/2.0.2


        SPOOFYING USER AGENT: it's easy to fool a naïve CGI programmer into
                              thinking we've used any kind of client program.

                              use LWP::UserAgent; <---------  LWP library (to create an instance of UserAgent)

                              my $ua  = new LWP::UserAgent;
                              $ua->agent("Mozilla/5.0 Galeon/1.2.1 (X11; Linux i686; U;) Gecko/0");
                              my $req = new HTTP::Request('GET', 'http://localhost/cgi-bin/env.pl');

                              my $res = $ua->request($req); <-- "HTTP_USER_AGENT => Mozilla/5.0 Galeon/1.2.1 (X11; Linux i686; U;) Gecko/0"

mod_cgi architecture:     It forks a Child for each request. Apache has something like:

                                   <IfModule prefork.c>
                                   StartServers    2
                                   MinSpareServers    1
                                   MaxSpareServers    2
                                   ServerLimit    256
                                   MaxClients    256 <-------- not more that this forks
                                   MaxRequestsPerChild    4000    
                                   </IfModule>

                          Each incoming request is forwarded by the mod_cgi process to an idle child.
                          If there are no idle childs, a new one is forked.
                          If the fork cannot be done, the request is QUEUED (<---- size of queue managed by Apache directive "ListenBacklog")
                          until a  child becomes available.

                          (When also "ListenBacklog" is full, the browser
                          client receives a SERVER UNREACHABLE response)

1 CGI <--> 1 Perl         Each CGI script executed by the child is managed by a new instance of the Perl interpreter.
                          When the script exits (no matter how), the process
                          and the interpreter exit as well, cleaning up on the way. 
                          When a new interpreter is started, it has no
                          history of previous requests. All the variables are
                          created from scratch, and all the files are reopened
                          if needed. 

DISADVANTAGES OF MOD_CGI: - overhead 1: forks (almost insignificant on modern Unix systems)
                          - overhead 2: Loading the Perl interpreter.
                          - overhead 3: compile CGI script from scratch
                          - No persistency: it's impossible to create persistent variables, which
                                            in turn prevents the establishment of persistent
                                            database connections and in-memory databases.
                          - No memory sharing: Starting a new interpreter removes the benefit of
                                            memory sharing that could be obtained by preloading
                                            code modules at server startup. Also, database
                                            connections can't be pre-opened at server startup.

mod_perl 1.0:            The first improvement is to embed the Perl interpreter, in each child
1 CHILD <--> 1 Perl      and not for each CGI script executed by that child.
                         A copy of the Perl interpreter is also embedded into the Apache httpd executable
                         allowing to configure the overall server through Perl scripts.
                         Any mod_perl Apache directive in http.conf starts with 'Perl'.
                         
                         Adding a large executable (Perl) into another large executable (Apache) 
                         creates a very, very large program. 
                         mod_perl certainly makes httpd significantly bigger, and you
                         will need more RAM on your production server.
                         Techniques can reduce memory requirements.
______________  

        Apache::Registry                             Apache::PerlRun

   <IfModule mod_perl.c>                          ..
      PerlModule Apache::Registry                     PerlModule Apache::PerlRun
      Alias /perl/ /usr/local/apache/cgi-bin/         Alias /cgi-perl/ /usr/local/apache/cgi-bin/
      <Location /perl>                                <Location /cgi-perl>
         SetHandler perl-script                          ..
         PerlHandler Apache::Registry                    PerlHandler Apache::PerlRun
         Options +ExecCGI                                ..
         PerlSendHeader On                               ..
         PerlSetupEnv On                                 ..
      </Location>                                     ..
   </IfModule>                                     ..

 
                          
Apache::Registry        They are 2 mod_perl packages to run unmodified CGI scripts.
Apache::PerlRun         Apache::Registry caches all scripts, and Apache::PerlRun doesn't.

                        Apache::Registry compiles scripts on first use and
                        keeps the compiled scripts in memory. On subsequent
                        requests, all the needed code (the script and the
                        modules it uses) is already compiled and loaded in
                        memory. This gives you enormous performance benefits,
                        but it requires that scripts be well behaved.


   <IfModule mod_perl.c>
      PerlModule Apache::Registry <----------   PerlModule xxxx is the mod_perl directive to load 1 of the internal  mod_perl modules
      Alias /perl/ /usr/local/apache/cgi-bin/ <-- gives an alias to a filesystem path usually outside DocumentRoot, that I can so access
      <Location /perl>          <-- wraps here all the instruct. which will be executed for any request of type http://host + "/perl" ...
         SetHandler perl-script <-- set 'perl-script' as the 'content handler' for this block  <Location></Loc..>, actually activates mod_perl
         PerlHandler Apache::Registry <-- is the real hanlder inside mod_perl which will be called to answer any file requested inside <Loc..> </Loc..>
         Options +ExecCGI  <-- requested by Apache::Registry to mark that directory as containing cgi scripts.
         PerlSendHeader On <-- intercepts all outputis and converts into a proper HTTP header. So legacy CGI script can run without modifications.
         PerlSetupEnv On
      </Location>
   </IfModule>
               
                  With the above configuration in http.conf, I can now
                  put some scripts (ex a.pl) in the dir marked by Alias (/usr/local/apache/cgi-bin/)
                  and call them as http://host + /perl + /a.pl
                  
                  The different behaviour of Run-vs-Registry can have side effects on
                  global vars:

                        use CGI;
                        $q = CGI->new( );
                        $topsecret = 1 if $q->param("secret") eq 'Muahaha';
                        # ...
                        if ($topsecret) { display_topsecret_data( ); }
                        else            { security_alert( ); }

                        It works with ::PerlRun but with::Registry on the
                        second run, preserving the var their values, there
                        could be a problem.

                        1' solution: use strict + declare var before their usage
                                         use strict;
                                         use vars qw($topsecret $q);
                                         $topsecret = 0;
                                         $q = undef;
                        2' solution: avoid global var (use my)
                                         my $q = CGI->new( );
                                         my $topsecret = $q->param("secret") eq 'Muahaha' ? 1 : 0;


           SetHandler xxxx       xxxx=handler-name is an APACHE directive (not mod_perl)
                                 that associate xxxx as the hanlder for all the files in the sections
                                 <Directoty> <Loaction> or <Files> where thr SetHandler is written.
                                 For mod_perl the name for xxxx is "perl-script"

           PerlModule xxxx       xxxx=internal module of mod_perl (it's searched that .pm file
                                 as usual in any path of @INC)

           PerlRequire 'xxxx'    xxxx= is a quoted script file name (with an absoulte path or if relative
                                 it will be searched in @INC). Has the same effect of PerlModule but 
                                 using filenames instead of module names.
            
           Perl*Handler xxxx     they are a family of directives to associate one of the handler
                                 of the typical APACHE multiphases loop 

           PerlSendHeader {On|Off} intercepts any output and translates into HTTP/1.x header

           PerlSetEnv var_name val   allows to set an ENV var

           PerlSetupEnv {On|Off}     enables to pass to all CGI script the env vars (HTTP_REFERER, REQUEST_URI ...)

           PerlPassEnv env_var       passes a var 'env_var' to any CGI script

           PerlFreshRestart {On|Off} allows to recompile and load all the modules without a server STOP+START

           PerlWarn {On|Off}         enables warning on all  perl code modules.

           PertTaintCheck {On|Off}   enables more check on all perl code modules.

           PerlSetVar name value     allows to pass generic vars (not ENV) to perl modules. 



internal module of mod_perl (it's searched that .pm file
                                 as usual in any path of @INC)

handler-name is an APACHE directive (not mod_perl)



------------------------ MOD_PERL_CONFIG <END>

error_log           is the 1st place to look when there are errors
                    in particular each "Internal Server Error".
                    A local perl program print on the shell terminal
                    but on a server application the perl programm
                    inside Apache, prints in 
                        error_log
                        STDERR (the server terminal where I executed httpd)

                    Normally it prints on error_log, but can print on STDERR
                    for at least the following reasons:
                     - the error_log is wrongly defined in httpd.conf
                       (the directive ErrorLog is wrong), so no file is opened.
                     - during the no-fork execution (httpd -X) (ex in debug)
                       most status messages that normally go to error_log
                       go to STDERR

die "...."         nb. without a \n, the messages is printed with also "line 9"
    "...\n"            (or whichever is the number of line)
                       I miss this added info if I put \n.
warn "..."             The same works for warn (which is the sister of die
                       that logs on error_log (and go on  living))






1. in httpd.conf
   PerlRequire /home/sbasile/modperl/db.pl    
            
   It should be a link to a perl file containing a function (the 'handler')
   that is specified right after:

   PerlRequire /home/sbasile/modperl/db.pl    
   <Location /mymod>
    SetHandler perl-script
    PerlHandler MyMod
   </Location>


2.  Add PerlFixupHandler Apache::DB

  <Location />
         SetHandler perl-script
         PerlHandler ModPerl::PerlRun
         <IfDefine PERLDB>
                 PerlFixupHandler Apache::DB <--------------
         </IfDefine>
         Options +ExecCGI
         PerlSendHeader On
         PerlSetupEnv On
    Order allow,deny
    Allow from all
  </Location>


3.  start Apache in single mode (-X)
    httpd -X -f myfile.conf
   
4.  connect to the server. The debug prompt is waiting.
    I can see the env var
    >p %ENV
  1 PATH/home/sbasile/bin/:/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/opt/CollabNet_Subversion/bin/:/usr/local/oracle/product/10.2.0/bin:/home/sbasile/bin:/home/sbasile/perl5lib/lib/bin:/home/sbasile/perl5/perlbrew/bin:.MOD_PERL_API_VERSION2PERLDB_PIDS18210MOD_PERLmod_perl/2.0.2
    
    I can see the backtrace
    >T
    $ = ModPerl::PerlRun::handler('ModPerl::PerlRun', ref(Apache2::RequestRec)) called from -e line 0
    $ = eval {...} called from -e line 0
2. 
 ModPerl::PerlRun::handler(/usr/lib/perl5/vendor_perl/5.8.5/i386-linux-thread-multi/ModPerl/PerlRun.pm:28):








  
  
  
  
  
  
  
  
  
