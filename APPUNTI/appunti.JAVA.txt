  ./A.java:
   __________________________________
   |public class A {
   |
   |    public static void main(String []args) {       <----- "public static void main(String args[])"  the mandatory entry-point of every Java program.
   |       System.out.println("Hello World");
   |    }
   | }
   |_________________________________

   javac A.java          --->   A.class              # javac compiler. It produces bytecode
   java  A               --->   Hello World          # java  JVM/java virtual machone. It runs the bytecode. Note it's not java A.class  but just java A
                                                                                                                                 ^^^^^^

   o  the file (A.java) must have the same name of the public class in there (A)
   o  there is only 0 or 1 public class in each file .java     (and 1+  non-public classes)
                           ^^^^^^
   o  package .....         (if present) must be at the top    \______   package & imports apply to ALL classes (1 public + many non-public) of the file
   o  import  .....         (if present) must be right after   /


------ Java Modifiers

    ___________________________
    Access Modifiers:

                              classes     interfaces    variables       methods      methods & Inheritance

      default                                                                                                 without any access control modifier, visibility is to any other class in the same package.     ex String a;


      private                    X           X                                                                visibility only inside the class (class & interfaces cannot be PRIVATE)  ex. private String a;
                                                                                      not inherited at all


      public                                                                                                  visibility from everywhere (where anyhow the class must be 1st imported:  import ...A) ex. public static void main(String[] arguments) {
                                                                                      must be public
                                                                                      in all subclasses.


      protected                  X           X                                                                visibility only in (any class some package) + (SUBLASSES in different packages) (class & interfaces cannot be PROTECTED)  ex. protected String a;
                                                                                      must either be
                                                                                           protected or public
                                                                                      in subclasses;
                                                                                      they cannot be private.


    ___________________________
    Non Access Modifiers:

                              classes     interfaces    variables       methods

      static                     X           X


      final                   cannot be                 can be init      cannot be
                              subclassed                only once        overridden
                                                                         (in subclasses)


      abstract                can only be                                it has no
                              extended                                   implementation
                              (I cannot create                           (which will be
                              an instance)                                in subclasses)


      synchronized               X           X           X               can be accessed by
       (thread)                                                          only one thread
                                                                         at a time.

      volatile                                        before reading
       (thread)                                       the value of
                                                      var in a thread
                                                      it is first merged
                                                      from main memory
                                                      (where other threads
                                                       might have changed it)





------ Java Variables

    Local Variables
              o vars inside functions
              o they live on the stack
              o no-default-value assigned when not-init

    Class Variables (Static Variables)
              vars inside a class (and outside of any methods) declared static
               __________________________________                       ^^^^^^
               |public class A {
               |
               |   static int i = 0;
               |
               |    method1 () {
               |       ...
               |    }
               | }
               |_________________________________
              o there is only 1 for ALL the objects of the class (they share that value)
              o they are created in static-memory when the prog starts.
              o they are accessed as   ClassName.VariableName.

    Instance Variables (Non-static Variables)
              o vars inside a class (and outside of any methods) NOT declared static
                                                                              ^^^^^^
              o they live on the heap
              o the have default-value when not-init (int: 0 / bool: false / class: null)


------ Java Enums

       enum FreshJuiceSize{ SMALL, MEDIUM, LARGE }
       FreshJuiceSize size;


------ Conctructors

       o  every CLASS must have 1 (constructor)
       o  if I don't write 1, JAVA will create 1 by default (that initializes all member variables to zero)
       o


     public class A {
          public A() {                  // constructor with no args
          }

          public A(String name) {       // constructor with 1 arg String
          }
     }




















----------------------------------------------------------------------------------------------------
JAVA: more installations on a mac
----------------------------------------------------------------------------------------------------
    1.    /usr/libexec/java_home -V        <--- to know how many installations are there
                                  ^
                                  uppercase

                |  Matching Java Virtual Machines (5):
                |      1.8.0_102, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_102.jdk/Contents/Home  <-------------.
                |      1.8.0_101, x86_64:	"Java SE 8"	/Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home                |
                |      1.7.0_71, x86_64:	"Java SE 7"	/Library/Java/JavaVirtualMachines/jdk1.7.0_71.jdk/Contents/Home                 |
                |      1.6.0_65-b14-466.1, x86_64:	"Java SE 6"	/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home        |
                |      1.6.0_65-b14-466.1, i386:	"Java SE 6"	/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home        |
                |                                                                                                                       |
                |  /Library/Java/JavaVirtualMachines/jdk1.8.0_102.jdk/Contents/Home                                                     |
                                                                                                                                        |
    1.a    nb.    /usr/libexec/java_home -v1.8     --> gives:  /Library/Java/JavaVirtualMachines/jdk1.8.0_102.jdk/Contents/Home     ----'
                                          ^
                                          lowercase

    2.
                export JAVA_7_HOME=$(/usr/libexec/java_home -v1.7)
                export JAVA_8_HOME=$(/usr/libexec/java_home -v1.8)
                export JAVA_9_HOME=$(/usr/libexec/java_home -v9)

                alias java7='export JAVA_HOME=$JAVA_7_HOME'
                alias java8='export JAVA_HOME=$JAVA_8_HOME'
                alias java9='export JAVA_HOME=$JAVA_9_HOME'

                export JAVA_HOME=$JAVA_8_HOME            #default java8

----------------------------------------------------------------------------------------------------
THE SIMPLEST PROG:
----------------------------------------------------------------------------------------------------
   1. go in a dir (ex ~)
   2. write a simple My_class.java (containing main:  public static main (String [] args))
   3. compile with: javac My_class.java
   4. this generates a .class in the same dir

   1. Now create a 'package tree'  (ex from current dir: mkdir -p org/basilest)
   2. move My_class.java in org/basilest
   3. edit My_class.java adding 'package org.basilest;'
   4. from ~: javac org/basilest/My_class.java
   5. this generates a .class in that dir:  ord/basilest/My_class.class

   4.b  modify 4. to have classes in another dir: javac -d class_dir org/basilest/My_class.java
   5.b  javac creates the dir/tree so that now is:  class_dir/org/basilest/My_class.class

   6. execute. To run you must call 'java'
      from ~:   java -cp class_dir org.basilest.My_class


----------------------------------------------------------------------------------------------------
JAR and CLASSPATH
----------------------------------------------------------------------------------------------------

    1. If I write a proj with 3 classes A.java B.java C.java defined as package "org.basilest"
       I'll have a dir like  ~/....../current_dir/org/basilest/(A.java B.java. C.java)
    2. If some API are in external jar files, I have to instruct javac, the compiler, how to locate them.
       I have 2 options:
               - define the ENV var $CLASSPATH (that is like PATH a list of dirs  separated by ':')
               - pass the list of jar, in the command line as -cp ".....jar : .....jar : ....jar"
                 to avoid listing ALL the jars, since java 1.6 the * is allowed:
                               ________________________________________

                     As a special convenience, a class path element containing a basename of *
                     is considered equivalent to specifying a list of all the files in the
                     dir with the extension .jar or .JAR.

                     For example, if dir foo contains a.jar and b.JAR, then the
                     class path element foo/* is expanded to A.jar;b.JAR, except that the order
                     of jar files is unspecified.
                     All jar files in the specified dir, even hidden ones, are included
                     in the list.
                     A classpath entry consisting simply of * expands to a list of all the jar files
                     in the current dir.
                               ________________________________________

    3. Probably the current dir (as :.:) must also be added in the list fo dirs.
    4. To compile A.java into A.class in the same dir ~/....../current_dir/org/basilest/
       do, from ~/....../current_dir/

             javac           -cp "dir1/a.jar:dir2/*:.:" org/basilest/A.java
    5. To compile A.java into A.class in a different dir3
       do, always from ~/....../current_dir/
             javac -d dir3/  -cp "dir1/a.jar:dir2/*:.:" org/basilest/A.java

       NB. It will not be .../dir3/A.class but (preserving the package hierarchy)
           .../dir3/org/basilest/A.class

    6. from ..../dir3   I can now execute it with
       java -cp "dir1/a.jar:dir2/*:.:"   org.basilest.A  <---- NB not .class
             ^                              ^
            the same jars used by javac     NB it's . not /

     NB. javac is the compiler
         java is the Virtual Machine (VM) that is going to run the bytecode.
         Both can be executed as server (java[c] -server) or client (java[c] -client)
         optimizing the appl. according to if it will run as a server or client app.
         (ex -client is better for GUI)

     NB. javap is the disassembler (shows the bythecode from a .class)
         play with the options:
                     -classpath ...  if the classes are somewhere
                     -c              the code
                     -l              also line numbers
                     -p -private     priva. members
                     -public         pub.    "
                     -protected      prot    "
                     -package        all the above


         Moreover JIT is the link between a deeper transformation.
         The bytecode is INTERPRETED by the JAVA VM, but is kept monitored by
         JIT that runtime after some time COMPILEs it.
         This optimization is not done permanently as the monitoring of the running
         code carries on.
         ex. Instruction like ' if (p == null) return; ... do something'
             if after some time JIT notices that p is never null will be compiled
             as if the code was '... do something'. If for some reason after some time
             a p = null arrives, the code is for a while 'de-optimized' without triggering
             a null-pointer-exception.
             The uncommon event is intercepted by JIT by the 'uncommon trap' mechanism
             that operates even when in an if--else branches JIT discovers that a branch
             is much more unlikely than the other and can compiles alternating the code
             ex if the code was if (x > y) {A} else {B} (where the else always requires a jump
             after the test-instruction) but 99.99 % is always x <= y
             JIT will compile reverting the test as if it was if (x <= y) {B} else {A}

             In the end JIT is intended to kill JUMPS in the Assembly code.

             Another JUMP killing is removing function-calls, compiling the
             function INLINE if it's short enough. To decide what 'short enough' means
             there are 2 flags
                  -XX:MaxInlineSize   (default 35 bytes)  all function-calls will be
                                      compiled inline if the function-code is <
                  -XX:FreqInlineSize  all function that are called often will be also
                                      compiled inline if its code is <


----------------------------------------------------------------------------------------------------
Eclipse
----------------------------------------------------------------------------------------------------
Ctr + space:     open a context menu
Crt + 1 :        quick fix: rename class & file, add import, suggest what to do.
Crt + O :        (letter O, not zero): open an outline, a resume, menu for the class where I'm inside)
Crt + E :        switch between the open files/tab
Alt + arrows (up/dows): to move 1 line of code up/down
Crt + Shift +    R (to open resources (ex files))
            +    T  (to open types menu)
    + T  (to open types hierarchy: ex select a class, than type Crt+T and look at the hierarchy)
    + L  (got to that line of code)
    + Q  (back to the code place where I wrote last time)
F3:   go to the file/definition of the class I've selected
F4:   open the hierarchy for the class I've selected

Refactoring   (all start with Alt + Shift than a leter):
Alt + Shift + R       : modify in parallel a var name wherever it's used.
Alt + Shift + M       : 1st select some lines of code, with Alt+Shit+M they are automatically extracted
                        from there into a new method, and the method name goes to replace those lines.

Alt + Shift + I       : The opposite: inline Method. 1 selected line, calling an external method
                        is replaced by the body of the method and the external method disappears.

N.B. the same ...+ M/ +I works with variables

Try also extracting constant: selecting a value (ex 5), will add a constant declaration and then replace
                              the value, with that constant.

Alt + Shift + S       : Add setter / getter methods

With Refactoring you can also have for free:
            - constructors
            - toString method

Views: all the windows or canvas inside the main Eclipse Win. Views can be moved from one canvas to any other
                 (drag&drop).
Perspective are the specific arrangment of the views (e.x. Java perspective / debug perspective / ...)
Usefull perspectives:
  - Java Browsing: make all available as views: methos, var, classes.
  - Java Type hierarchy: open this perspective, than also add project explorer view, than, drag&drop
             something (ex. a package) into the Java Type hierarchy view canvas and see the diagrams.

----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
"Hollywood Principle: Don't call us, we'll call you".
Robert C. Martin and Martin Fowler.

(Dependency injection) implements inversion of control and
allows a program design to follow the dependency inversion principle.

injection:
one or more dependencies (or services) are injected, or passed by reference, into a dependent object (or client)
and are made part of the client's state.
allows program designs to be loosely coupled and
to follow
   the dependency inversion and
   single responsibility principles
It's a (software design pattern) as opposite to the (service locator pattern),
which allows clients to know about the system they use to find dependencies.

Dependency injection involves 4 elements:
   the implementation of a service object;
   the client object depending on the service;
   the interface the client uses to communicate with the service;
   the injector object, which is responsible for injecting the service into the client.

The injector object may also be referred to as an assembler, provider, container, factory, or spring.

----------------------------------------------------------------------------------------------------
SOAP    Simple Object Access protocol   Version 1.2 became a W3C recommendation on June 24, 2003.
----------------------------------------------------------------------------------------------------
A protocol for exchanging structured information in web services.
(a method of remote Procedure Calls)
It uses
      "XML Information Set"
for its message format.
can operate over any transport protocol such as
HTTP, SMTP, TCP, UDP, or JMS


A SOAP message is an ordinary XML document containing the following elements:

                                                                     Required:
Envelope   Identifies the XML document as a SOAP message             Yes
Header     Contains header information                               No
Body       Contains call, and response information                   Yes
Fault      Provides information about errors that occurred           No
           while processing the message

Disadvantages

Because of verbose XML, SOAP can be considerably slower than competing middleware technologies such as
CORBA, GIOP, ICE, and DCOM
which use much shorter, binary message formats.

----------------------------------------------------------------------------------------------------
SERIALIZATION
----------------------------------------------------------------------------------------------------
The process of serializing an object (also called marshalling an object) is the process of translating
           data structures or
           object state
into a format that can be stored (file,  memory buffer, or transmitted across a network)
and reconstructed later (when the series of bits is reread according to the serialization format:
deserialization or unmarshalling)
|[Ma|[Ma||
For example, for maximal use of distribution, a computer running on a different hardware
should be able to reliably reconstruct a serialized data stream, regardless of endianness.
This means that the simpler and faster procedure of directly copying the memory layout of the data structure
cannot work reliably for all architectures.

For many complex objects, such as those that make extensive use of references, this process is tortuous
In a serialization scheme  the encoding of the data is by definition serial,
extracting one part of the serialized data structure requires that the entire object be read from start to end.
In applications where higher performance is an issue, use a more complex, non-linear storage organization.

Serialization, breaks the opacity exposing private implementation details.  Publishers of proprietary software
often keep the details of their programs' serialization formats a trade secret (obfuscate or even encrypt the
serialized data).
Interoperability requires that applications be able to understand each other's serialization formats.
Therefore, remote method call architectures such as CORBA define their serialization formats in detail.

Many institutions, such as archives and libraries, attempt to future proof their backup archives—in particular,
database dumps—by storing them in some relatively human-readable serialized format.

In the late 1990s, a push to provide an alternative: XML a human readable text-based encoding.
(XML disadvantage: losing  compact byte-stream-based encoding,
but now file size is less of a concern than in the early days of computing)

JSON is a more lightweight plain-text alternative to XML which is also commonly used for client-server
communication in web applications. JSON is based on JavaScript syntax.

YAML, is a more powerfull JSON

Several programming languages directly support serialization, (Ruby, Smalltalk, Python, PHP, Objective-C, Java, .NET)

Java
provides automatic serialization which requires that the object be marked by implementing the
          java.io.Serializable interface.
Implementing the interface marks the class as "okay to serialize", and Java then handles serialization internally.

The language allows the developer to override the serialization process more thoroughly by implementing another interface,
the Externalizable interface, which includes two special methods that are used to save and restore the object's state.

There are reasons why objects are not serializable by default.
For example, a Thread. There is no context in which a deserialized Thread object would maintain useful semantics.
Classes containing sensitive information (for example, a password) should not be serializable nor externalizable.


----------------------------------------------------------------------------------------------------
JAVA BEANS
----------------------------------------------------------------------------------------------------
JavaBeans are classes that encapsulate many objects into a single object (the bean).
They are serializable, have a 0-argument constructor, and allow access to properties using
     getter and
     setter methods.
The name Bean was given to encompass this standard which is meant to create reusable software components for Java.

Disadvantages

A class with a nullary constructor is subject to being instantiated in an invalid state.

Having to create a getter for every property and a setter for many, most, or all of them can lead
to an immense quantity of boilerplate code. In computer programming, boilerplate code or boilerplate
is the sections of code that have to be included in many places with little or no alteration.

The JavaBeans functionality is provided by a set of classes and interfaces in the java.beans package.

----------------------------------------------------------------------------------------------------
Hibernate       4.3.7    (2014.30.10)
----------------------------------------------------------------------------------------------------
We can certainly do this by employing Object Relational Mapping (ORM) tools. These
tools’ main job is to transform the Java objects to relational data and vice versa. There
are quite a few ORMs available. One that has gained a serious following is Hibernate.
Hibernate is an ORM framework that lets you work on Java objects without having to
worry about SQL queries, database connections, datasources, and resource manage-
ment issues.

----------------------------------------------------------------------------------------------------
Spring      http://repo.spring.io/release/org/springframework/spring/4.1.4.RELEASE/
----------------------------------------------------------------------------------------------------
Replacement for, or even addition to the Enterprise JavaBean (EJB) model.
current version Framework 4.0 (December 2013)

                      -----------------------------------------
                      Beans.xml:  1/3    xml external file
                      -----------------------------------------
                      <?xml version="1.0" encoding="UTF-8"?>

                      <beans xmlns="http://www.springframework.org/schema/beans"
                          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                          xsi:schemaLocation="http://www.springframework.org/schema/beans
                          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

                         <bean id="helloWorld"                          <-- id: mandatory attribute
                             class="com.tutorialspoint.HelloWorld"      <-- the java class to link
                             init-method="init"                         <-- (optional)  a fun to call at start
                             destroy-method="destroy">                  <-- (optional)  a fun to call on exit
                             <property name="message" value="Hello World!"/>
                         </bean>

                      </beans>

                      -----------------------------------------
                      class HelloWorld:  2/3  the actual class/code that will be executed
                      -----------------------------------------
                      package com.tutorialspoint;

                      public class HelloWorld {
                         private String message;

                         public void setMessage(String message){
                            this.message  = message;
                         }
                         public void getMessage(){
                            System.out.println("Your Message : " + message);
                         }
                         public void init(){                     <--- the fun linked at start
                            System.out.println("Bean is going through init.");
                         }
                         public void destroy(){                  <--- the fun linked on exit
                            System.out.println("Bean will destroy now.");
                         }
                      }
                      -----------------------------------------
                      class MainApp :   3/3 the main file that import xml external info
                      -----------------------------------------
                      package com.tutorialspoint;

                      import org.springframework.context.support.AbstractApplicationContext;
                      import org.springframework.context.support.ClassPathXmlApplicationContext;

                      public class MainApp {
                         public static void main(String[] args) {

                            AbstractApplicationContext context =
                            new ClassPathXmlApplicationContext("Beans.xml"); <---- read info from external xml

                            HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
                            obj.getMessage();
                            context.registerShutdownHook();
                         }
                      }
----------------------------------------------------------------------------------------------------
JSF   / JSP
----------------------------------------------------------------------------------------------------
1998: Java Servlets             On the server
                                The HTML code is generated inside the Java class (Servlet)
1999: JavaServer Pages (JSP)    On the server
                                The Java code is executed inside the HTML page  (Scriptlet)
Model-View-Controller (MVC)     design pattern that used together
                                  - Servlet (for the business logic)
                                  - JSP (for dynamic view generation)

                                The development in this age, required a lot of stuff
                                   - binding (linking input user fields with java code)
                                   - validation
                                   - templating
                                And many frameworks were proposed (Apache Struts, Spring MVC)

2004: JSF 1.0 (Java Server Faces)  Sun decided to create a new way from scratch.
          1.1
          1.2 (in 2006)
          2.0 (in 2009) AJAX support & GET request support
          2.1
          2.2 (in 2013)




      - 2) Pages Prototype and Design
               - once only visio was enough to model the application in the analysis phase
               - now a prototype for the application is required in the very eraly stage

               - suggested solution: HTML 5
                 (JSF will be used only for binding input fields)

      - 3) Development and Debugging
                The approach is:
                    - MVC through views and managed beans
                    - binding is automatic using a script language called 'expression language' (EL)
                    - Validators, Convertors, and Navigation rules are built-in

      - 3) Development and Debugging
                many serious performance issues, including:
                1. The overhead of including all the static resources
                   (Images, CSS, and JavaScript) in JSF components tree.
                2. Missing standard and transparent caching functionalities.




JAVA EE         Java EE is an abstract specification.
                Anybody is open to develop and provide a working implementation.

                Implementations are
                         WildFly,
                         TomEE,
                         GlassFish,
                         Liberty,
                         WebLogic, etc.

APP: SERVER     called APPLICATION SERVERS,

SERVL. CONT     There are also SERVLET CONTAINERS which implement only the
                JSP/Servlet part of the huge Java EE API, such as
                         Tomcat,
                         Jetty, etc.

                Java-EE developers, should write code utilizing only javax.* classes
                instead of org.jboss.wildfly.*, com.sun.glassfish.*, etc), so the code will run
                on any (APPLICATION) SERVER.

                The Java EE SDK download from Oracle.com contains basically the GlassFish server
                and optionally also the NetBeans IDE.


SPRING          Spring is a standalone framework which substitutes and improves
                many parts of Java EE.
                Spring doesn't necessarily require Java EE to run.
                A barebones servletcontainer like Tomcat is already sufficient.
                Simply put, Spring is a competitor of Java EE.
                E.g. "Spring" (standalone) competes EJB/JTA, Spring MVC competes JSF/JAX-RS,
                Spring DI/IoC/AOP competes CDI, Spring Security computes JAAS/JASPIC, etc.

                Back during the old J2EE/EJB2 times, the EJB2 API was terrible i
                to implement and maintain.
                Spring was then a much better alternative.
EJB3            But since EJB3 (Java EE 5), the EJB API was much improved based
                on lessons learnt from Spring.
                Since CDI (Java EE 6), there's not really a reason to look
                at again another framework like Spring.


JSP             JSP is a technology running on a SERVER which allows you
                to write template text in CLIENT side languages HTML, CSS, JavaScript ...
                JSP supports the so-called taglibs which are backed by pieces of Java code
                with which you can control the page flow and/or output dynamically (programmatically).
                A well known taglib is JSTL.
                JSP also supports Expression Language (EL), with syntax like ${} which
                can be used to access backend data.

VIEW  JSP       To view a JSP: Install Apache on your PC. Put the JSP file in
                                   /htdocs/JSP
                Name the JSP file index.jsp. Open Apache and start the web service
                (the top one. Click Start) To view it, go to your browser and  go to
                127.0.0.1/JSP. or more explicit even 127.0.0.1/JSP/index.jsp


                When a JSP is requested for the first time or when the webapp starts up, the servlet container will compile the JSP file into a class extending HttpServlet and use it during the webapp's lifetime. You can find the generated source code in the server's work directory. In, for example, Tomcat, it's the /work directory. On a JSP request, the servlet container will execute the compiled JSP class and send the generated output (usually just HTML/CSS/JS) through the webserver over the network to the client side, which in turn displays it in the browser.

----------------------------------------------------------------------------------------------------
Struts
----------------------------------------------------------------------------------------------------
The web application programmer is responsible for writing the model code, and for creating
a central configuration file struts-config.xml that binds together
   M.odel,     (Hibernate)
   V.iew,      (the HTML) : typically in JSP (JavaServer Pages), but XML/XSLT and Velocity are also supported).
   C.ontroller (a servlet known as ActionServlet)

It is usually associated with the model–view–controller (MVC) paradigm.
Model is left undefined with the expectation that developer would fill in an appropriate solution.
Database interaction via JDBC and EJBs were options suggested on the Struts homepage.
More recently, Hibernate, iBatis, and Object Relational Bridge were listed as more modern options that could be used for a model.

JSP technology is used as a pure template engine. All of the logic is separated out into a servlet,
leaving the JSP with the sole responsibility of rendering the output.

Requests from the client are sent to the controller in the form of "Actions" defined in the configuration file;
if the controller receives such a request it calls the corresponding Action class that interacts with
the application-specific model code.
The model code returns an "ActionForward", a string telling the controller what output page to send to the client.
Information is passed between model and view in the form of special JavaBeans.
A powerful custom tag library allows it from the presentation layer to read and write the content of these beans
without the need for any embedded Java code.

Struts is categorized as a Model 2 request-based web application framework.

Model 2 is a complex design pattern used in the design of Java Web applications
which separates the display of content from the logic used to obtain and manipulate the content.
----------------------------------------------------------------------------------------------------
TomCat    developed by the Apache Software Foundation (ASF)
   version: 8.0.15                               2014-11-07
----------------------------------------------------------------------------------------------------

   web server (open source)

   implements several Java EE specifications including
     Java Servlet,  (Catalina)
     JavaServer Pages (JSP), (Jasper: JSP Engine)
     Java EL,
     WebSocket,
   and provides
     a "pure Java" HTTP web server


 Tomcat is normally installed in a dir /opt/tomcat/
 with inside other dirs
 (mainly:

       ./bin    (with the exe startup.sh / catalina.sh / shutdown.sh )
       ./temp
 )

 catalina.sh is what is required to start & stop (the others are aliases):

      $CATALINA_HOME/bin/catalina.sh start
      $CATALINA_HOME/bin/catalina.sh stop

      or

      $CATALINA_HOME/bin/startup.sh
      $CATALINA_HOME/bin/shutdown.sh

 The env vars are set in catalina.sh
 mainly they are CATALINA_HOME and JAVA_HOME / JRE_HOME
 so that they can be set already in ~/.bashrc

  export CATALINA_HOME=/opt/tomcat

 The 2 JAVA vars could be already set, anyhow they are the dir where the java & javac
 binaries are located:

    . type java                        /usr/bin/java              (that is a symbolic link)
    . ls -l /usr/bin/java              -> /etc/alternatives/java     "         "      "
    . ls -l /etc/alternatives/java     -> /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java
                                                                                ^    ^

      so JRE_HOME   should be  /usr/lib/jvm/java-8-openjdk-amd64/jre     (the bin is added by Tomcat)

      There is in  /usr/lib/jvm/java-8-openjdk-amd64/bin/java
      that is a link     -> ../jre/bin/java     (<----- to the JRE)

      So even
      JAVA_HOME  could be set as    /usr/lib/jvm/java-8-openjdk-amd64/   (the bin is added by Tomcat)

      anyhow the important one is JRE_HOME and if both are set tomcat will refer to JRE_HOME.

open firefox:
      http://localhost:8080


----------------------------------------------------------------------------------------------------
Servlet version:3.1   May 2013  JavaEE 7
----------------------------------------------------------------------------------------------------

A Java servlet is a Java program that extends the capabilities of a server.
-->  hosted on Web servers.
The Java counterpart to PHP and ASP.NET.

A "servlet" is a Java class that conforms to the Java Servlet API (javax.servlet)
could in principle communicate over any client–server protocol,
but they are most often used with the HTTP protocol.

Servlets can maintain state in session variables across many server transactions
by using HTTP cookies, or URL rewriting.

The package (javax.servlet.http)
defines HTTP-specific subclasses of the generic servlet elements, including
session management objects that track multiple requests and responses between the web server and a client.
Servlets may be packaged in a WAR file as a web application.



3 methods life cycle of a servlet:
   init(),
   service(),
   destroy()

   call  init(), passing an object implementing the (javax.servlet.ServletConfig) interface.

   After initialization, the servlet instance can service client requests.
   Each request is serviced in its own separate thread.
   service(): The web container calls the service() method of the servlet for every request.

   destroy() Finally, the web container calls the destroy() method that takes the servlet out of service.





----------------------------------------------------------------------------------------------------
JAVA SYNTAX
----------------------------------------------------------------------------------------------------
comments:      //      /*  */               /**   javadoc   */

Main method:     public static void main(String[] args) {  }

Packages:        part of a class name.
                 ex. full class name: java.io.InputStream  class: InputStream   package: java.io

                 A public class X must be written inside a file named X.java
                 A class belonging to a certain package:

                       package myapplication.mylibrary;

                       public class X {
                       }

                 file X.java must be nested into folders: myapplication/mylibrary/X.java

Import:          after package lines, follow import lines.
                 If class Y.java must access X.java instead of specify the full path:

                 myapplication/mylibrary/X.fun();
                 add an import line, and then refers only to X.fun();

                 import java.util.*;   // import all classes inside java.util
                 import java.*;        // import nothing! As there is no file.java directly in java folder.

Static import declaration

                 available since J2SE 5.0.
                 allow access to static members in another class, interface, annotation, or enum;
                 import static java.lang.System.out;     //'out' is a static field in java.lang.System
                 import static java.lang.System.*;

if, then ... do while...:  the same as in C (also label:   break;  continue [label optional];  return;)
Enhanced for                    (available since J2SE 5.0.)
                for (int i : intArray) {    //Assuming "intArray" is defined to be an array of int
                    doSomething(i);         //ex2: for (String e : a) { ..
                }

finally:         'return' statement ends execution immediately, except for one case:
                 within a try block if there is a finally, control is passed to the finally block.

                     void doSomething(boolean streamClosed) {
                         try {
                             if (streamClosed) {
                                 return; <--------------------------------------
                             }
                             readFromStream();
                         } finally {
                             /* Will be called last even if
                             readFromStream() was not called */
                             freeResources();
                         }
                     }

Exception handling statements                 // try-catch-finally

Exceptions are managed within try ... catch blocks.

                     try {
                         // Statements that may throw exceptions
                         methodThrowingExceptions();
                     } catch (Exception ex) {
                         // Exception caught and handled here
                         reportException(ex);
                     } finally {
                         // Statements always executed after the try/catch blocks
                         freeResources();
                     }

If any of the try block commands throws an exception, execution of the block is discontinued and
the exception is handled by the catch block.
There may be multiple catch blocks, in which case the first block with an exception variable
whose type matches the type of the thrown exception is executed.

Java SE 7 also introduced multi-catch. Allows Java to handle different types of exceptions
in a single block provided they are not subclasses of each other.

                     try {
                         methodThrowingExceptions();
                     } catch (IOException | IllegalArgumentException ex) {
                         //Both IOException and IllegalArgumentException will be caught and handled here
                         reportException(ex);
                     }

If no catch block matches the type of the thrown exception, the exception is propagated upwards through
the call stack until a matching catch block.
If the exception propagates all the way up to the top-most main method without a matching catch block being found,
a textual description of the exception is written to the standard output.

The statements within the finally block are always executed after the try and catch blocks,
whether or not an exception was thrown and even if a return statement was reached.
Such blocks are useful for providing clean-up code that is guaranteed to always be executed.

The catch and finally blocks are optional, but at least one or the other must be present following the try.


try-with-resources:  a special type of try-catch-finally introduced as an implementation of the dispose pattern
in Java SE 7. The try is followed by initialization of resources that are released automatically when the try
is finished.
Resources must implement java.lang.AutoCloseable.
A catch or finally are both optinal.

                  try (FileOutputStream fos = new FileOutputStream("filename");
                      XMLEncoder xEnc = new XMLEncoder(fos))
                  {
                      xEnc.writeObject(object);
                  } catch (IOException ex) {
                      Logger.getLogger(Serializer.class.getName()).log(Level.SEVERE, null, ex);
                  }


throw:       is used to throw an exception and end block (or method) execution.

                    void methodThrowingExceptions(Object obj) {
                        if (obj == null) {
                            // Throws exception of NullPointerException type
                            throw new NullPointerException(); <------------------------------
                        }
                        // Will not be called, if object was null
                        doSomethingWithObject(obj);

Error:        take into consideration that IO can also throw Errors.
              Errors are not Exception, though both share the base class Throwable.
              Since IO can throw Errors, you may want to go so far as to catch Throwable
              try{
                   ...
               } catch (Throwable t){
                   if(t instanceof Exception){
                       if(t instanceof IOException){
                           // handle this exception type
                       } else if (t instanceof AnotherExceptionType){
                           //handle this one
                       } else {
                           // We didn't expect this Exception. What could it be? Let's log it, and let it bubble up the hierarchy.
                           throw t;
                       }
                   } else if (t instanceof Error){
                       if(t instanceof IOError){
                           // handle this Error
                       } else if (t instanceof AnotherError){
                           //handle different Error
                       } else {
                           // We didn't expect this Error. What could it be? Let's log it, and let it bubble up the hierarchy.
                           throw t;
                       }
                   } else {
                       // This should never be reached, unless you have subclassed Throwable for your own purposes.
                       throw t;
                   }

assert:       available since J2SE 1.4. the assert keyword followed by a conditional expression.
              On false an AssertionError is thrown.
              Notice that this is an Error and not an Exception.
              This statement may include a colon followed by another expression,
              which will act as the error's detail message.

assert n != 0;// If n equals 0, AssertionError is thrown
assert n != 0 : "n was equal to zero";

Arrays:  length is defined at creation and cannot be changed.

                int[] numbers = new int[5];
                numbers[0] = 2;
                numbers[1] = 5;
                int x = numbers[0];


                int[] numbers = new int[] {20, 1, 42, 15, 34};       // Long syntax
                int[] numbers = {20, 1, 42, 15, 34};                 // Short syntax

                int[][] numbers = new int[3][3];
                numbers[1][2] = 2;

                int[][] numbers = {{2, 3, 2}, {1, 2, 6}, {2, 4, 5}};

multi-dimensional arrays are not bound to be rectangular unlike C:

                int[][] numbers = new int[2][]; //Initialization of the first dimension only

                numbers[0] = new int[3];
                numbers[1] = new int[2];


class:
Top-level class                 class X {
                                }
Inner class                     class X { // Top-level class
                                    class Y { // Inner class
                                    }
                                }
Nested class                    class X { // Top-level class
                                    static class Y { // Nested class
                                    }
                                }
Local class                     class X {
                                    void bar() {
                                        class Y {// Local class within a method
                                        }
                                    }
                                }
Anonymous class                 class X {
                                    void bar() {
                                        new Object() {// Creation of a new anonymous class extending Object
                                        };
                                    }
                                }

                                ___________________
                                The anonymous class expression consists of;

                                  . The new operator
                                  . The name of an interface to implement or a class to extend.
                                  . ( args ) <--- to the constructor (if a class)
                                    Note: as an interface, has no constructor I use only an empty pair of parentheses ()
                                  . A body.


Class Modifiers:     before the 'class':

    -         - no modifiers at all, means 'package-private' and the class is visible only to the other classes of the same package.
    public    - visible everywhere.
    abstract  - a class only serves as a base and cannot be instantiated.
    static    - Nested classes, specifies that the class does not belong to a specific instance of the containing class.
    final     - cannot be extended and cannot have any subclasses.

Function Modifiers:
    -         - no modifiers at all, means 'package-private' and the function can be called/visible only by the same package classes
    public    - visible everywhere.
    private   - visible only inside that class
    protected - visible only : any class some-package
                               any child-class external-package

    abstract - functions can be present only in abstract classes, have no body and must be overridden in a subclass
    static - Makes accessible without creation of a class instance. cannot access non-static members in the same class.
    final - cannot be overridden in a subclass.
    native - Actual implementation happens outside Java code, and such methods have no body.
    strictfp - Declares strict conformance to IEEE 754 in carrying out floating-point operations.
    synchronized - Declares that a thread executing this method must acquire monitor.
                   For synchronized methods the monitor is the class instance or java.lang.Class if the method is static.

Var Modifiers:
    -         - as functions
    public    - as functions
    private   - as functions
    protected - as functions

    static - idem
    final - Allows the field to be initialized only once in a constructor or inside initialization block
            or during its declaration, which ever is earlier.
    transient - Indicates that this field will not be stored during serialization.
    volatile - it is ensured that all threads see a consistent value for the variable.

Inheritance:
                     class X {
                     }

                     class Y extends X {      // cannot inherits from other classes!!! No multiple inheritance
                     }

If a class does not specify the superclass, it implicitly inherits from java.lang.Object class.
Thus all classes in Java are subclasses of Object class.

Overriding methods:    Unlike C++, all non-final methods can be overridden
                    class X {
                        public int fun () {
                            return 0;
                        }
                    }

                    class Y extends X {
                        public int fun () {
                            return 1;
                        }
                    }

Interfaces:   1 abstract class, with vars but where the functions have no body.
              Classes that implement an Interface, defines its all functions:

interface ActionListener {                  class ActionHandler implements ActionListener, RequestListener {
    int ACTION_ADD = 0;                         public void actionSelected(int action) {
    int ACTION_REMOVE = 1;                      }
                                              ...........
    void actionSelected(int action);        }
}

Interfaces can inherit from other interfaces just like classes.
Unlike classes it is allowed to inherit from multiple interfaces.

                        interface EventListener extends ActionListener, RequestListener {

                        }

functional interface:  is any interface that
                       - contains only 1 abstract method.
                         (--> you can omit the name of that method when you implement it)
                       - can contain 1 or + default methods
                       - can contain 1 or + static  methods
                       - to enforce the compiler that is is a functional interface
                         and so generate errors in case of misuse ther is a
                         dedicated annotation: @FunctionalInterface

                         @FunctionalInterface
                           public interface xxxx { ...

                       - Java 8 defines 3 builtin:
                                         abstract method to define
                         Predicate<T>  : boolean test  (T t);
                         Consumer <T>  : void    accept(T t);
                         Function<T, R>: R       apply (T t);

---------------------- Generics:

when defining a class (or interface) I can use the syntax class A<T,S,...> {...}
where I list some "type parameters" that can be used as "generic-types" in any line of
code inside the class.
ex.

public interface Pair<K, V> {                   public class OrderedPair<K, V> implements Pair<K, V> {
    public K getKey();
    public V getValue();                            private K key;
}                                                   private V value;

                                                    public OrderedPair(K key, V value) {
                                                           this.key = key;
                                                           this.value = value;
                                                    }

                                                    public K getKey()   { return key; }
                                                    public V getValue() { return value; }
                                                }


when declaring (instantiating with real types) I go to substitute
the generic type with "type arguments"
        Pair<String, Integer> p1 = new OrderedPair<String, Integer>("Even", 8);
        Pair<String, String>  p2 = new OrderedPair<String, String>("hello", "world");

"type parameters":   the letters T,E,K,V used in definition
"type arguments":    the real types used during delcaration
                     they cannot be primitive types (so Integer is ok, 'int' not)

A shorter <> (Diamond operator) can be used when the compiler can understand from the context
the "type":
            Pair<String, Integer> p1 = new OrderedPair <> ("Even", 8);
The official word to refer to this compiler ability and its algorithm to identify
the most specific type that fits is TYPE-INFERENCE

Type erasure:  Once the compiler has written the code, it deletes the Type arguments
               so there is no way to determine it (ex Integer or any parent (Number or Object))

               so the following will print "Equal [class java.util.ArrayList]"

               ArrayList<Integer> li = new ArrayList<Integer>();
               ArrayList<Float>   lf = new ArrayList<Float>();
               if (li.getClass() == lf.getClass()) { // evaluates to true
                   System.out.println("Equal ["+ li.getClass() + "]");
               }

               Type-erasure is done at compile time so tha the Java run-time environment
               does not know which parameterized type was used.

---------------------- lambda expression
           It introduces in Java some functional mechanism (like LISP and Javascript)
           allowing the functions to be instantiated.

           They are
             - anonimous functions, with a '->' instead of the { }
               so it's:
                    (args) -> body
             - they cannot live alone. They are assigned to an object
               that is of type functional-interface
               (they implements the single abstract method)
           ex:

           numbers.forEach((Integer value) -> System.out.println(value));

           The TYPE-INFERENCE allows to skip the type:
           numbers.forEach(value -> System.out.println(value));

           The Java-8 method-reference-operator (::) allows even only
           numbers.forEach(System.out::println);

           public int sumAll(List<Integer> numbers, Predicate<Integer> p) {  |    sumAll(numbers, n -> true);
                                                                             |    sumAll(numbers, n -> n % 2 == 0);
               int total = 0;                                                |    sumAll(numbers, n -> n > 3);
               for (int number : numbers) {                                  |                    ^
                    if (p.test(number)) {                                    |              here the lambda expr.
                        total += number;                                     |
                    }                                                        |
               }                                                             |
               return total;                                                 |
           }                                                                 |


---------------------- Annotations:

Annotations:  Java  (since J2SE 5.0) has a set of predefined annotation types,
              but it is allowed to define new ones.
              They are a way to embed metadata into code.

1 annotation declaration is 1 interface (preceded by the @ sign).
They implicitly extend from
                            java.lang.annotation.Annotation
and cannot be extended from anything else.

The main difference is that method declarations must
         have 0 parameters
         throw no exceptions.
         they may have a default value, which is declared using the default keyword after the method name:
         Return only primitive types: String, Class, enums, annotations, and arrays of these.

          @interface BlockingOperations {
              boolean fileSystemOperations();
              boolean networkOperations() default false;
          }

     - Annotations are a way to add information that can be then used
       by the compiler (compilation phase) or by the program at runtime (execution phase)
     - The usage of these information at runtime is possible by the java 'reflection' mechanism.
     - annotations are a '@' + name --> @name
       attached to classes, interfaces, methods, fields
     - Annotations are often used by frameworks as a way of conveniently applying behaviours to
       user-defined classes and methods that must otherwise be declared in an external
       source (such as an XML configuration file)
     - When Java source code is compiled, annotations can be processed by compiler plug-ins called
                       annotation processors.
       Processors can produce informational messages or create additional Java source files or resources,
       which in turn may be compiled and processed, and also modify the annotated code itself.
       The Java compiler conditionally stores annotation metadata in the class files,
       if the annotation has a RetentionPolicy of CLASS or RUNTIME.
       Later, the JVM or other programs can look for the metadata to determine how to interact
       with the program elements or change their behavior.
     - In addition to processing an annotation using an annotation processor, a Java programmer
       can write their own code that uses reflections to process the annotation.
     - the built-in annotations are following 3:
           - @Override         : this instructs the compiler to throw an exception
                                 when the overriding link between the 2 methods (Parent/Child)
                                 should be broken
           - @Deprecated       : when a class, method, field is annotated as Deprecated, the complier
                                 should thow a warning when anyone is still carrying on using it.
                                 Javadoc relies on a lowercase tag '@deprecated' to document the usage:
                                 /**
                                   * @deprecated
                                   * reason for why it was deprecated
                                   */
                                  @Deprecated
                                  public void anyMethodHere(){
                                      // Do something
                                  }

           - @SuppressWarnings: to suppress the warnings generation for the listed warinings.
                                ex.
                                 @SuppressWarnings("deprecation")
                                    void myMethod() {
                                        myObject.deprecatedMethod();
                                }

     - custom xxx annotations can be created as:
                . defining a normal interface xxx, that is child of java.lang.annotation
                . the definition is done prepending the keyword "@interface"
                               public @interface xxx {                  |  @interface yyy  {
                                   int studentAge() default 18;         |      int      count();
                                   String studentName();                |      String[] books();
                                   String stuAddress();                 |  }
                                   String stuStream() default "CSE";    |
                               }
                . importing it where it must be used: "import java.lang.annotation.xxx"
                . calling it as
                                @xxx(
                                    studentName="Chaitanya",  <--- nb. default val can be skipped
                                    stuAddress="Agra, India"
                                )
                                @yyy(                         <--- nb. I can add more annotations
                                    count=3,
                                    books={"C++", "Java"}
                                )
                                public class MyClass {
                                ...
                                }
     - @Target : limits the range of what an annotation can annotate to any element of this list

                    ElementType.METHOD
                    ElementType.PACKAGE
                    ElementType.PARAMETER
                    ElementType.TYPE
                    ElementType.ANNOTATION_TYPE
                    ElementType.CONSTRUCTOR
                    ElementType.LOCAL_VARIABLE
                    ElementType.FIELD

                 ex. when defining xxx, add @Target({ElementType.METHOD})
                      @Target({ElementType.METHOD})
                               public @interface xxx {

                               }
     - @Inherited : adding this when defining xxx (ex.
                    @Inherited                      <---
                       public @interface xxx {

                    ) means that when used in a class F
                    @xxx                            <---
                     public class F {
                       ...
                     }
                     then any child C of C, will also inherited it.

                     public class C extends F {    <---
                        ...
                     }
     - @Retention    when adding this during xxx definition
                     I can specify till when the info of the annotation can be used
                     @Retention(RetentionPolicy.SOURCE)  <--- it will keep only in the source and discarded already in the class object
                         public @interface xxx

                     @Retention(RetentionPolicy.CLASS)    : it is preserved in the object class, but not at runtime
                     @Retention(RetentionPolicy.RUNTIME)  : it is preserved even for runtime usge.

     - @Documented   if added when defining xxx, it will make Javadoc including the annotation
                     when generating doc for a class F that uses the annotation.


----------------------------------------------------------------------------------------------------
JAVADOC
----------------------------------------------------------------------------------------------------

     . Javadoc generates HTML code from the source.
     . It's aim is to document software intended as an API


     /**      <--- comments with an extra '*'

     */           <------ NO NEW LINE before the xxxxxxx line
     xxxxxxxx     <--- this is the item to document

     . Javadoc  generator is released with each delivery of the 'Java Development Kit'
     . Inside the /**   */  the structure is:

     __________________________ FOR A FUNCTION

          /**
             blah blah blah ......   <--- 1 LINE with an general description
             <p>                                   <---- <p> are used to have it separated in the generated HTML
             blah blah blah ......   <--- N LINES optionally of a more detailed description
             blah blah blah ......
             <p>

             @xxxx   <--- then there is a list of tags the possible to be used are:
             @yyy                 . @param      doc the args:
             @zzz                                                @param arg1    text text text text
                                                                 @param arg2    text text text text
                                                                 @param arg3    text text text text
                                                                 @param arg4    text text text text
                                  . @return     doc the return:
                                                                 @return    text text text text
                                  . @throws     doc any exception thrown inside the method
                                  . @see        doc what else to look at
                                  . @author
                                  . @version
                                  . @since      doc version of the package this class was first added to
          */
          public int xxxx (...) {
          }

     __________________________ FOR A VAR
     /**
       1 line description
     */
     var xxx;



     More advanced tags:
      _______________________________________________________________________________________________________________________________________
          APPLIES TO:                                         TAG
      _______________________________________________________________________________________________________________________________________
                                                   |   @exception  classname description  |
      Method                                       |   @throws     classname description  |  Describes an exception that may be thrown from this method.
      Class, Interface, Enum, Field, Method        |   @deprecated description            |  Describes an outdated method.
      Overriding  Method                           |   {@inheritDoc}                      |  Copies the description from the overridden method.
      Class, Interface, Enum, Field, Method        |   {@link reference}                  |  Link to other symbol.
      Static Field                                 |   {@value #STATIC_FIELD}             |  Return the value of a static field.
      Class, Interface, Enum, Field, Method        |   {@code literal}                    |  Formats literal text in the code font. It is equivalent to <code>{@literal}</code>.
      Class, Interface, Enum, Field, Method        |   {@literal literal}                 |  Denotes literal text. The enclosed text is interpreted as not containing HTML markup or nested javadoc tags.



----------------------------------------------------------------------------------------------------
JAR
----------------------------------------------------------------------------------------------------


 1 To create a JAR file                            jar cf jar-file input-file(s)
 2 To view the contents of a JAR file              jar tf jar-file
 3 To extract the contents of a JAR file           jar xf jar-file
 4 To extract specific files from a JAR file       jar xf jar-file archived-file(s)
 5 To update a JAR file                            jar uf jar-file input-file(s)
 6 To run an application packaged as a JAR file    java -jar app.jar
 7 (requires the Main-class manifest header)
 8 To invoke an applet packaged as a JAR file      <applet code=AppletClassName.class
                                                           archive="JarFileName.jar"
                                                           width=width height=height>
                                                   </applet>


 - To create a JAR file                            jar cf jar-file input-file(s)
   The command will also generate a default manifest file for the JAR archive:   META-INF/MANIFEST.MF

   jar cmf existing-manifest jar-file input-file(s)      to include manifest information from an existing manifest file.

   Warning: The manifest must end with a new line or carriage return.
            The last line will not be parsed properly if it does not end with a new line or carriage return.

   jar cvf0 ......  0 means NO_COMPRESSION
                    You might want to avoid compression, for example, to increase the speed with which a JAR file
                    could be loaded by a browser.

   jar cvf TicTacToe.jar TicTacToe.class audio images

   would create a .jar file conatining (preserving dir hierarchy):
                                      META-INF/MANIFEST.MF
                                      TicTacToe.class
                                      images/cross.gif
                                      images/not.gif
                                      audio/beep.au
                                      audio/ding.au
                                      audio/return.au
                                      audio/yahoo1.au
                                      audio/yahoo2.au

   jar cvf TicTacToe.jar TicTacToe.class -C audio -C images

   The -C option remove that directory hierarchy moving all at flat-top-level:

                                      META-INF/MANIFEST.MF
                                      TicTacToe.class
                                      cross.gif
                                      not.gif
                                      beep.au
                                      ding.au
                                      return.au
                                      yahoo1.au
                                      yahoo2.au

 - To execute a JAR, the Manifest must have this info:

      Main-Class: classname



Working with Manifest Files

  META-INF/MANIFEST.MF is the default manifest file created.
  Any Manifest is a list of information
               xxxxxx :  value
  Default Manifest looks like:
                                  Manifest-Version: 1.0
                                  Created-By: 1.7.0_06 (Oracle Corporation)

  At lest the entry point must be added:

  Main-Class: classname      <--- the class with main:     public static void main(String[] args)

  so prepare a new text Manifest file and create again the jar with jar cmf

  Another var is Class-Path: xxxxxx where can be specified path to access other jar files (where
  other classes resources must be retrueved) The path is relative to the current dir where jar is located:

         Class-Path: jar1-name jar2-name directory-name/jar3-name

----------------------------------------------------------------------------------------------------
