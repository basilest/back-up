--------------------------------------------------- view ENV var + others
(set -o posix ; set ) | vi -          to see ALL var & functions (env and the others)


--------------------------------------------------- crontab
 crontab means cron table, that is where root or any user
 can add some rows (with the cron syntax) to specify periodic tasks
 to be executed.
 The syntax for each row is:
 
  * * * * *  command to execute
  │ │ │ │ │
  │ │ │ │ │
  │ │ │ │ └───── day of week (0-6) (Sunday=[0 or 7], or use names SUN-SAT)  - SC
  │ │ │ └─────── month (1-12 or JAN-DEC) - SC
  │ │ └───────── day of month (1 - 31)   - SC
  │ └─────────── hour (0-23)             - SC
  └───────────── min  (0-59)             - SC

SC (Special Chars) are 
      *    value skipped
      ,    when the value is a list  (ex. MON,WED,FRI)
      -    when the value is a range (ex. 2000-2010)
      /    (only on some cron implementations) the syntax */<value>
           means only 'mod' <value>. ex a hour */3 means any hour mod-3 (0,3,6,9,...) 
ex:   
   0 20 * * * /home/oracle/scripts/export_dump.sh      (run each day at 20:00)
   1 0  1,2 * *  printf > /var/log/apache/error_log    (run on 1st and 2nd days of each month at 00:01)

/etc/cron.allow        can list on rows, the usernames with    the rights to run cron
/etc/cron.deny              "        "         "       without      "          "  

File location depends on the Unix distribution. A file named with the user name (`whoami`)
is store in the following dirs:

/var/cron/tabs/             FreeBSD/OpenBSD/NetBSD
/var/spool/cron/            IBM AIX Unix CentOS/Red Hat/RHEL/Fedora/Scientific Linux
/var/spool/cron/crontabs/   HP-UX Unix Debian / Ubuntu Linux
/usr/lib/cron/tabs/         Mac OS X

crontab [-u user] [ -elri ] <file>

-e     crontab files (for each user) are not edited directly but with crontab -e
       which opens the editor specified in env var (VISUAL or EDITOR)

-l     to list the entries 

-r     to clean all the tables (any crontab row) 
       -i      (prompt before deleting user's crontab)

[-u user]   to do the above commands as associated to user
            (used by root to add to some of the users)

<file>   instead of -e, I can load a crontab directly from a file



a way to backup and restore is:
     1. crontab -l > c.txt
     2. crontab  c.txt 

a way to copy from an user to another:
     crontab -u <user1> -l | crontab -u <user2>

a way to copy to another server
     crontab -l | ssh $remote_host crontab


--------------------------------------------------- date
  date  +%s    ->     1445293970       num sec 01.01.1970

  date --date $xxxxx       gives time related to the text string in val $xxxxx
  date  -d    $xxxxx         "                "        "           "

  date --date $xxxxx +%s   gives again num sec ----> I can operates on date with + - * / 


  date +%x    ---->    22/10/15      dd/mm/yy
                                                  the fact it's dd/mm (en_GB)
                                                  and not mm/dd  (en_US) depends from the 
                                                          echo $LANG    --> en_GB.UTF-8
                                                  setting to US
                                                          LANG=en_US
                                                  now
                                                     date +%x   ---->  10/22/15
  

--------------------------------------------------- signals & kill 
kill -x PID       send signal -x to proces with that PID    (-x  can be the number (ex 2) or the name (ex SIGINT))
kill -l           to have the list of signal names:

     1) SIGHUP         2) SIGINT         3) SIGQUIT         4) SIGILL         5) SIGTRAP
     6) SIGABRT        7) SIGBUS         8) SIGFPE          9) SIGKILL       10) SIGUSR1
    11) SIGSEGV       12) SIGUSR2       13) SIGPIPE        14) SIGALRM       15) SIGTERM
    16) SIGSTKFLT     17) SIGCHLD       18) SIGCONT        19) SIGSTOP       20) SIGTSTP
    21) SIGTTIN       22) SIGTTOU       23) SIGURG         24) SIGXCPU       25) SIGXFSZ
    26) SIGVTALRM     27) SIGPROF       28) SIGWINCH       29) SIGIO         30) SIGPWR
    31) SIGSYS        34) SIGRTMIN      35) SIGRTMIN+1     36) SIGRTMIN+2    37) SIGRTMIN+3
    38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6     41) SIGRTMIN+7    42) SIGRTMIN+8
    43) SIGRTMIN+9    44) SIGRTMIN+10   45) SIGRTMIN+11    46) SIGRTMIN+12   47) SIGRTMIN+13
    48) SIGRTMIN+14   49) SIGRTMIN+15   50) SIGRTMAX-14    51) SIGRTMAX-13   52) SIGRTMAX-12
    53) SIGRTMAX-11   54) SIGRTMAX-10   55) SIGRTMAX-9     56) SIGRTMAX-8    57) SIGRTMAX-7
    58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4     61) SIGRTMAX-3    62) SIGRTMAX-2
    63) SIGRTMAX-1    64) SIGRTMAX       

kill -l 15    returns 'TERM' from its number, the signal name (without SIG).

       SIGHUP     1          Hangup
       SIGINT     2          Interrupt from keyboard   CTRL-C
       SIGKILL    9          Kill signal
       SIGTERM    15         Termination signal
       SIGSTOP    17,19,23   Stop the process          CTRL-Z


      TERM (15)  should be the 1st try as proc can execute its 'clean' code if it has any
      INT  (2)   CTRL-C    2nd try
      KILL (9)             last try


killall         like kill but can kill all instances of a proc with a given 'name'
pkill, pgrep    advanced feature:  can kill processes from other than your own user ID and 
                                   specifying processes by name


SIGHUP  (1)   when a shell receives SIGHUP it exits
              (to exit shell with PID 3456:    kill -1 3456)

A SHELL that exits (for having received SIGHUP or for other reasons), sends SIGHUP to all
its jobs (whichever state, running or suspended)
This feature (huponexit) can be 'on' or 'off'  (see below)
--------------------------------------------------- shopt
shopt        shows the option settings of the shell

autocd                  off
cdable_vars             off
cdspell                 off
checkhash               off
checkjobs               off
checkwinsize            off
cmdhist                 on
compat31                off
compat32                off
compat40                off
compat41                off
compat42                off
complete_fullquote      on
direxpand               off
dirspell                off
dotglob                 off
execfail                off
expand_aliases          off
extdebug                off
extglob                 off
extquote                on
failglob                off
force_fignore           on
globstar                off
globasciiranges         off
gnu_errfmt              off
histappend              off
histreedit              off
histverify              off
hostcomplete            on
huponexit               off  <--------------
interactive_comments    on
lastpipe                off
lithist                 off
login_shell             off
mailwarn                off
no_empty_cmd_completion off
nocaseglob              off
nocasematch             off
nullglob                off
progcomp                on
promptvars              on
restricted_shell        off
shift_verbose           off
sourcepath              on
xpg_echo                off

--------------------------------------------------- trap
trap intercepts the signals. The syntax is:
     trap '.....; .....; .....'     SIG1 SIG2 SIG3



so trap + some commands + the signals trapped, which can be as usual:
                - the numbers   (ex 15)
                - the name (without SIG)
                - the special value 0 or EXIT, which mean when that script ends
                - the special value DEBUG (the commands inside the trap '....' are executed on each cmd')
                  moreover variables defined with the more specific syntax:
                                declare -t VAR=val
                  instead of the normal
                                           VAR=val
                  will be logged or 'traced' (t)
                - the special value ERR (the commands inside the trap '....' are executed on each exit != 0)
                  (in some cases, inside if, while, ... this is not always true, so check to be sure)
ex1.
     trap "echo Booh!" SIGINT SIGTERM
ex2.
     FILE=/tmp/$(basename $0).pid
     trap 'rm $FILE' EXIT
     trap 'echo "receiving SIG to stop";  exit 3'  15  <----- if a kill -15 is sent to this script,
     if [ -e $FILE ]                                          it will sent itself an exit 3,
     then                                                     which will be trapped, above,
            echo "cannot run if file is present"              so the file is removed
            exit 2
     fi
     echo $$ > $FILE
     sleep 10
     exit 0

--------------------------------------------------- echo -e
    echo -e       allows to print ANSI escape sequences

    color:        escapes for color are  
                  \e[  +   colo_1 + ;  +  col_2 + m         col1,col2 are foreground, background colors
                                                            they can be in any order as they have different ranges
                  \e or \E is the same                         foreg. 30-37   backg. 40-47

                                                                       foreg      backg. (+10)
                                                               black    30          -
                                                               red      31          -
                                                               green    32          -
                                                               yellow   33          -
                                                               blues    34          -
                                                               magenta  35          -
                                                               cyan     36          -
                                                               white    37          -
                  "\e[33;44m blah blah blah"

                  an optional 0; or 1; can be added. It has meaning only for FOREGROUND
                  color and make it light (1) or dark (0)
                  ex
                        "\e[1;32;41m     light green on red
                        "\e[0;32;1;41m   light green on red (the same, as the second 1; replace the first 0;
                       

    
   

tput sgr0             reset terminal to original settings
echo -e "\e[0m"        "         "            "            (better, as more portable)


to avoid so the effect remains after the echo -e, add the \e[0m at the end

                  "\e[33;44m blah blah blah \e[0m"
               
--------------------------------------------------- dmesg
command that prints the message-buffer of the kernel.

the 'buffer' is the file   /var/log/dmesg
that can be accessed directly

During boot all the output at video are stored in that buffer.
So printing after the boot can be read. After some time, the
buffer is overwritten, so those information go lost.

       ex. 
           dmesg | grep -i memory
       
       can be used to inspect the amount of RAM

--------------------------------------------------- kermit
   to manage in 1 tool all theine

     minicom, cu, tip, seyon, pcomm, telnet, or rlogin.
     Zmodem, FTP, rcp
     Expect, Runscript, Perl, Tcl
     ssh, scp, ktelnet, srp-telnet

the linux implementation of kermit is ckermit


--------------------------------------------------- term
echo $TERM      to see which terminal (ex. xterm)
infocmp         to display 'terminfo' data, used by my terminal
/usr/share/terminfo      may be in another loaction. It's the repository 
                for terminfo files.
                This value can be also set in var $TERMINFO
                which so can be $TERMINFO= /usr/share/terminfo/
 tic            to 'compile' modifications done in terminfo file


 tput colors    if display 8: not good

 -->   sudo apt-get install ncurses-term          
       vim ~/.bashrc                          | or also:~/.profile:           
                                              |
       add line:   export TERM=xterm-256color |   if [ -e /usr/share/terminfo/x/xterm-256color ]; then
                                              |           export TERM='xterm-256color'
                                              |   else
                                              |           export TERM='xterm-color'
                                                 fi








 redo tput colors  --> 256
--------------------------------------------------- (dash) -
if - is in place of a input file, means stdin
      idem            output            stdout (video)

--    'end of options'
--------------------------------------------------- help

    man ls
    man -a aaaa    open one after the others, all the man pages containing aaaa
    man -k aaaa    search manages with the given string (here aaaa)
    man -d ...     usual man, but at the 'exit', print debug info
    man -w ...     not open man page. Just link where it is on disk
    info ls
    cmd --help
    /usr/share/doc


    $ man -wa mkfifo
    /usr/share/man/man1/mkfifo.1
    /usr/share/man/man3/mkfifo.3   <---- then open this: man 3 mkfifo
--------------------------------------------------- X
     more complex graphical env (GNOME, KDE) are built on X


--------------------------------------------------- System dir
   

--------------------------------------------------- /
--------------------------------------------------- /
--------------------------------------------------- /
To know Ubuntu version
    cat /etc/issue 
or otherwise
    lsb_release -a    # part of pkg 'lsb': Linux Standard Base support for Debian

--------------------------------------------------- /tmp
    1. Capture video with Recordmydesktop (ogv fotmat)
    2. convet ogv to gif (Use mplayer and imagemagik)
    mplayer -ao null <video file name> -vo jpeg:outdir=output
    convert output/* output.gif
    convert output.gif -fuzz 10% -layers Optimize optimised.gif

--------------------------------------------------- /tmp
   

The cleaning of /tmp is done by the upstart script 
                 /etc/init/mounted-tmp.conf. 
 The script is run by upstart everytime /tmp is mounted. 
 Practically that means at every boot.

The script does roughly the following: 
        if a file in /tmp is older than $TMPTIME days it will be deleted.

$TMPTIME is an environment variable defined in /etc/default/rcS.
The default value of $TMPTIME is 0, which means every file and directory in /tmp gets deleted. 
$TMPTIME=7 means 1 week   $TMPTIME=-1 means never

useful commands are 'tmpreaper'  which is based on 'tmpwatch'
but both are not by default installed.
-------------------------------------------------- avconv
avconv -i Simple_Man.mp4 -acodec copy -ss 00:00:07 -t 00:00:25 Simple_Man.07-34.aac
--------------------------------------------------- masscan
This is the fastest Internet port scanner. 
It can scan the entire Internet in under 6 minutes, transmitting 10 million packets per second.

It produces results similar to nmap, the most famous port scanner. 
Internally, it operates more like scanrand, unicornscan, and ZMap, using asynchronous transmission. 
The major difference is that it's faster than these other scanners. 
In addition, it's more flexible, allowing arbitrary address ranges and port ranges.
--------------------------------------------------- concat more pdf files
gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -dPDFSETTINGS=/prepress 
              -sOutputFile=merged.pdf 10.Bristol.Londra 10.Londra.Stansted 16.Londra.Bristol

use gostrscript that is available everywhere.
Other options are:
    pdftk:   also comes with Ghostrscipt but can be not installed
             lot of option, fast, good compression
    pdfjam:  cames with LaTeX
             lot of option as well
    pdfunite: no options

pdftk    input1.pdf input2.pdf input3.pdf cat output output.pdf
pdfjam   input1.pdf input2.pdf input3.pdf        -o  output.pdf
pdfunite input1.pdf input2.pdf input3.pdf            output.pdf


--------------------------------------------------- xinput  &  xev

command to see and configure keyboard / mouse

   xinput list   (providdes a list of devices and their id= )
                  e.g 
                  -----> USB Optical Mouse     id=11   [slave  pointer  (2)]
   xinput test 11
                 to test what appens cliking and scrolling. ex:

                                  button press   1  
                                  button release 1    <--- left click
                                  button press   3 
                                  button release 3    <--- right
                                  button press   4 
                                  button release 4    <--- wheel forward
                                  button press   5 
                                  button release 5    <--- wheel backward

  instead of xinput test    it can also be used   xev
--------------------------------------------------- xorg.conf
typically located in /etc/X11/xorg.conf
but
does not exist by default any more.  
Recent releases of Ubuntu haven't required a xorg.conf file. 
You can generate one pretty easily though:

               sudo Xorg -configure
               or
               sudo X -configure

if above commands are executed once X server is already running (usually it is already running
on display or port 0) so you open on first available display; in most cases 1 :

                 X :1 -configure 

this command produce a file    "xorg.conf.new"  in the user home
and can be renamed and moved in /etc/X11/xorg.conf

All the settings of the new xorg.conf file are overwritten by the already present X.conf files
usually located in dir /usr/share/X11/xorg.conf.d

--------------------------------------------------- xmodmap
The set of physical keys of a keyboard can be functionally groupped as:
         - alphanumeric keys (only to print char, numbers or symbols)
         - navigation keys for moving 
         - function keys (Fn, Esc, Del, Break)
         - modifier keys (Shift, AltGr), Control): to be added to alphanumeric keys to modify 
                                                   the behaviour and allow more symbols.

So through the modifiers keys, 1 single physical keys (e.g. n) can produces MORE symbols, ex.: 

          n    (when pressed alone)
          N    (when pressed with Shift)
          ñ    (when pressed with AltGr)
          Ñ    (when pressed with Shift+AltGr)

X server,  identifies :
               - the physical key by a number (keycode) 
               - all the possible system printing symbols in the file /usr/include/X11/keysymdef.h (removing the XK_ )  
ex.:
        grep -wi xk_n /usr/include/X11/keysymdef.h

        #define XK_N                             0x004e  /* U+004E LATIN CAPITAL LETTER N */
        #define XK_n                             0x006e  /* U+006E LATIN SMALL LETTER N */

        grep -i _ntilde /usr/include/X11/keysymdef.h

        #define XK_Ntilde                        0x00d1  /* U+00D1 LATIN CAPITAL LETTER N WITH TILDE */
        #define XK_ntilde                        0x00f1  /* U+00F1 LATIN SMALL LETTER N WITH TILDE */

Whenever a key is pressed or released, X server generates an event that contains 
       the 'keycode' of the pressed key 
       the 'mask' with the pressed modifiers.

Try to see with xev:

------------------------------------- press n

KeyRelease event, serial 37, synthetic NO, window 0x3c00001,
    root 0x9c, subw 0x3c00002, time 16015893, (48,46), root:(670,624),
    state 0x0, keycode 57 (keysym 0x6e, n), same_screen YES, <-----   here the KEYCODE: dec 57
    XLookupString gives 1 bytes: (6e) "n"                                  the symbol:  hex 6e
    XFilterEvent returns: False

------------------------------------- press Shift + n

KeyPress event, serial 37, synthetic NO, window 0x3c00001,
    root 0x9c, subw 0x3c00002, time 16023348, (48,46), root:(670,624),
    state 0x0, keycode 50 (keysym 0xffe1, Shift_L), same_screen YES,  <--- here the KEYCODE: dec 50
    XLookupString gives 0 bytes:                                       /* no symbol as it's Shift 
    XmbLookupString gives 0 bytes: 
    XFilterEvent returns: False

KeyPress event, serial 37, synthetic NO, window 0x3c00001,
    root 0x9c, subw 0x3c00002, time 16024067, (48,46), root:(670,624),
    state 0x1, keycode 57 (keysym 0x4e, N), same_screen YES, <-----   here the KEYCODE: again dec 57
    XLookupString gives 1 bytes: (4e) "N"                                  the symbol:  hex 4e
    XmbLookupString gives 1 bytes: (4e) "N"
    XFilterEvent returns: False

------------------------------------- press AltGr + n

KeyPress event, serial 37, synthetic NO, window 0x3c00001,
    root 0x9c, subw 0x3c00002, time 16034738, (48,46), root:(670,624),
    state 0x0, keycode 108 (keysym 0xfe03, ISO_Level3_Shift), same_screen YES, <--- here the KEYCODE: dec 108
    XKeysymToKeycode returns keycode: 92                                        /* no symbol as it's AltGr
    XLookupString gives 0 bytes:                                                   AltGr is also called ISO_Level3_Shift 
    XmbLookupString gives 0 bytes: 
    XFilterEvent returns: False

KeyPress event, serial 37, synthetic NO, window 0x3c00001,
    root 0x9c, subw 0x3c00002, time 16035091, (48,46), root:(670,624),
    state 0x80, keycode 57 (keysym 0xf1, ntilde), same_screen YES,  <-----   here the KEYCODE: again dec 57
    XLookupString gives 2 bytes: (c3 b1) "ñ"                                      the symbol: ñ
    XmbLookupString gives 2 bytes: (c3 b1) "ñ"
    XFilterEvent returns: False

------------------------------------- press AltGr + Shift + n

KeyPress event, serial 37, synthetic NO, window 0x3c00001,
    root 0x9c, subw 0x3c00002, time 16038178, (48,46), root:(670,624),
    state 0x0, keycode 108 (keysym 0xfe03, ISO_Level3_Shift), same_screen YES,
    XKeysymToKeycode returns keycode: 92
    XLookupString gives 0 bytes: 
    XmbLookupString gives 0 bytes: 
    XFilterEvent returns: False

KeyPress event, serial 37, synthetic NO, window 0x3c00001,
    root 0x9c, subw 0x3c00002, time 16039344, (48,46), root:(670,624),
    state 0x80, keycode 50 (keysym 0xffe1, Shift_L), same_screen YES,
    XLookupString gives 0 bytes: 
    XmbLookupString gives 0 bytes: 
    XFilterEvent returns: False

KeyPress event, serial 37, synthetic NO, window 0x3c00001,
    root 0x9c, subw 0x3c00002, time 16039645, (48,46), root:(670,624),
    state 0x81, keycode 57 (keysym 0xd1, Ntilde), same_screen YES,
    XLookupString gives 2 bytes: (c3 91) "Ñ"
    XmbLookupString gives 2 bytes: (c3 91) "Ñ"
    XFilterEvent returns: False

X has 8 bit mask reserved to identify (one bit each) a modifier. 3 are Shift, Lock (the CapsLock), Control.
The others are called Mod1 ... Mod5.
To see your current X modifiers configuration, use xmodmap -pm ex.:

                   shift       Shift_L (0x32),  Shift_R (0x3e)
                   lock        Caps_Lock (0x42)
                   control     Control_L (0x25),  Control_R (0x69)
                   mod1        Alt_L (0x40),  Meta_L (0xcd)
                   mod2        Num_Lock (0x4d)
                   mod3      
                   mod4        Super_L (0x85),  Super_R (0x86),  Super_L (0xce),  Hyper_L (0xcf)
                   mod5        ISO_Level3_Shift (0x5c),  Mode_switch (0xcb)


While Shift-Lock-Control are modifiers with a physical key, mod1 ... mod5 even if defined (e.g. the above 
output from xmodmap -pm list some values for them) can be really submitted only if the keycode is a physical key.


The association between the physical key and list of the symbols that can be generated from that key with the modifiers,  
is a table that is managed by the command xmodmap.

                xmodmap -pke
                                -pk    print the keyboard  (-pke print in a format that can be then submitted again as input)
                                -pp    print the mouse
                                -pm    print the modifiers
                                -e     to execute a command

ex. 
                xmodmap -pke | grep -w N      --->    keycode  57 = n N n N ntilde Ntilde

Whichever is the list of symbols associated to a key (the above report 6 symbols) X foresees the standard  behaviour 
for the 1st 2nd 3th 4th and they can be obtained as:

1. 1st : pressing the key alone
2. 2nd : pressing Shift + key
3. 3th : pressing Mode_switch + key
4. 4th : pressing Shift + Mode_switch + key

Mode_switch is a builint X-keyword to identify that through that modifier you can add 2 more symbols to that key. 
Ok, so we have a scheme to have at leat 4 symbols for each alphanumeric keys, but which is the physical key for Mode_switch ?
Mode_switch comes by default with a high keycode value (0xCB, 203) outside the physical keycodes space, so
you cannot print symbols 3th and 4th.

Anyhow most X installation comes with 6 symbols in the list. The standard 4 and 2 more:      ex. keycode  57 = n N n N ntilde Ntilde

   1. Key                          : the key alone: n     
   2. Shift+Key                    : N
   3. mode_switch+Key              : as Mode_switch is usually not mapped to a physcal key you cannot generate this
   4. mode_switch+Shift+Key        : as Mode_switch is usually not mapped to a physcal key you cannot generate this 
   5. ISO_Level3_Shift+Key         : ñ
   6. ISO_Level3_Shift+Shift+Key   : Ñ

ISO_Level3_Shift modifier comes both already associated to a Mod1 ... Mod5, as mapped onto the physycal AltGr key.
So the above it's:
        
   5. AltGr+Key                : ñ
   6. AltGr+Shift+Key          : Ñ

Thus in most all clean X system you should have for free the keysym table reported by 
                           xmodmap -pke
where there are 6 symbols and you can submit the 1st 2nf 5th 6th with proper Shift / AltGr combination
but not the 3th and 4th. That is really more than enough for all the symbols you must require,
anyhow just to see that mode_switch works you can associate to some physical key:
  - Fn keys do not generate X events, and so are totally dead. You can't use it. 
  - maybe we can free NmLock and take it

xmodmap -pm :

                   shift       Shift_L (0x32),  Shift_R (0x3e)
                   lock        Caps_Lock (0x42)
                   control     Control_L (0x25),  Control_R (0x69)
                   mod1        Alt_L (0x40),  Meta_L (0xcd)
                   mod2        Num_Lock (0x4d)
                   mod3      
                   mod4        Super_L (0x85),  Super_R (0x86),  Super_L (0xce),  Hyper_L (0xcf)
                   mod5        ISO_Level3_Shift (0x5c),  Mode_switch (0xcb)


free the physical key 77 (NumLock) to map onto it the Mode_switch:    xmodmap -e 'remove mod2 = Num_Lock'
remove Mode_switch from mod5 (where there is also AltGr):             xmodmap -e 'remove mod5 = Mode_switch'
add Mode_switch to physical key 77 (NumLock)                          xmodmap -e 'keycode 77 = Mode_switch'

so now you can print all the 6 symbols from the table ex.:
                                xmodmap -pke | grep 47
                                keycode  47 = ograve ccedilla semicolon colon at dead_cedilla

                      1. Key               :  ò
                      2. Shift+Key         :  ç
                      3. NumLock+Key       :  ;
                      4. NumLock+Shift+Key :  :
                      5. AltGr+Key         :  @
                      6. AltGr+Shift+Key   :  ¸



To configure your own mapping, you can try:

                xmodmap -pke > ~/my_map_file

                then change something as you like in the my_map_file

                and resource it:  xmodmap ~/my_map_file

                To have it sourced at boot write the above command in your own xinitrc  (~/.xinitrc) 
                or in the common one /etc/X11/xinit/xinitrc


____________________________________________________________

BOOT:
      1. BIOS search 'OS loader'  (LILO, GRUB, ..) 
         which can be in any device (also external USB, CD)
         following any sequence specified (1st CD, 2nd HD, ...)

       . boot-loader finds the proper kernel to load, 
         with configurations stored in its config file 
                            (ex /etc/lilo.conf
                                /boot/grub/menu.lst 
                                /grub/grub.conf)

         this default can be interrupted submitting a command line list of args
         ex. LILO: linux root=/dev/hda9
         where the kernel loaded is that with label 'linux' and the root filesystem
         is taken from partition /dev/hda9
         So kernel-options are passed through those file or even at command line

       . the config for kernel modules are not passed on command line
         but they are loaded from file  /etc/modules.conf 
         So module-options are passed only through conf file 
 
dmsg     print the messages that were fast displayed through the boot
         so usually you inspect as dmsh | vi -
         These data are stored in a fixed size kernel buffer (ring buffer)
         so to inspect them, do after the boot, as the kernel during runtime
         output msgs, they will overwrite the buffer.
         Other info are instead written in syslog files, and they are
         not overwritten.

runlevels   from 0 (shutdown) to 6 (reboot)
            1,s,S  Single-user (no network) filesystem maintenance. Most daemons are down
                   The best way is add 1 or 'single' at the grub command line
                        kernel /vmlinuz ....... 1
                        kernel /vmlinuz ....... single
                   The worst is run 'init 1'

            2      Multi-user with no X win system / NFS (Debian default)
            3      Multi-user with no X  (Red Hat default)
            4      not used
            5      Multi-user with X.

            the above levels are just for a rough idea. The real important things
            is the 
                       init
            process, that runs a series of script, usually in /etc

            /etc/init.d     stores most scripts to run different daemons
                            ex /etc/init.d/httpd  (for Apache server) 
                               /etc/init.d/httpd start       (stop, restart, reload)

            /etc/rc0.d ...  /etc/rc6.d contains sym (soft) links 
            to the scripts in the /etc/init.d   (0...6 as the init level)
            So runlevel 3 is completed once all the script of /etc/rc3.d
            have been executed.
            The names are usually in the form  KNNname SNNname
            NN is a number, which specifies which script is called first than another
            K  refers that the script contains daemnons to Kill (stop)
            S  refers               idem                to Start
            First are called all K files (any service is stopped) then all S.

     default runlevel: in file etc/inittab the line 
                           id:3:initdefault:                  (in case of 3)
            
     runlevel    to know in which runlevel I am. ex. it shows 3 5 is I passed
           from 3 to 5 with a 'init' cmd, or shows N 5   in case a normal boot in 5
         
     init n    to change inite level to n.  (exec init 0   shutdown)

     shutdown  to perform a init 0 or init 6 specifying when, and optionally
            sending a msg.

                shutdown [options] time [warning_message]

               -r    reboot after shutdown  (same as init 6)
               -h    halt     "      "      (same as init 0)
               -k    don't really shutdown but send a msg to all user
               -f    on next reboot skip filesystem check
               -F           "       do       "        "   

               time:    (now, +minutes_from_now, hh:mm)o
                     shutdown -r +5 System maintenance is required
                     shutdown –h 23:59
                     shutdown –h now
         
____________________________________________________________ partitions
partition the dist to allocate various filesystems


/boot    (partition to store most of the kernel) this is the partition
         that LILO or GRUB go to address
         usually 50 / 100 MB
         below the 1024-cylinder limit for older kernels and BIOS
/        (root partition)  500/850 MB
swap     usually double of the RAM size
/usr     4 GB    for exec shared through NFS
/var     2 GB    log files, mails, spools
/tmp     500 MB  for temp files
/home    90  GB


/etc/fstab    is the table which specifyc where and how
              the different filesystem partition have been mounted

sfdisk        to manage the partition layout
              sfdisk -d /dev/hda > partition_backup.txt     to dump a bakup
              sfdisk /dev/hda < partition_backup.txt        to restore later

superblock    the linux equivalent of Windows FAT.
              Stores metadata info for disk and filesystem (size,blocks ...)

MBR           A small program in 1 sector (--> 512 B) of disk. It launches OS
              To backup:  
                    dd if=/dev/hda of=~/mbr.txt count=1 bs=512     #count 1 means 1 copy
              To restore:
                    dd if=~/mbr.txt of=/dev/hda count=1 bs=512

backup        use dd.   You can backup copy a partition (ex. /dev/hdx) to another partition
              on the same disk, or into another disk:  dd if=/dev/hdx of=/dev/hdy

____________________________________________________________ boot loaders
 LILO: a 1st part of this utility is in MBR and only has instructions
       to launch a 2nd part (normally stored in the boot partition on disk) 
       that provides the prompt with the list of options to launch.

       LILO map installer, is the utility that installs LILO (in MBR) and 
       thus allows to configure the prompt options and so on, normally store
       in file /etc/lilo.conf:

       boot = /dev/hda                 partition containing boot sector 
       timeout = 50                    timeout on prompt  
       prompt                          wait for user  
       read-only                       the kernel will in case convert then in write  
       map = /boot/map                 default path for map file  
       install = /boot/boot.b            

       image=/boot/bzImage-2.6.0       1 kernel image to offer
          label=test-2.6.0             any text to present on menu
          root=/dev/hda1               root partition

 GRUB: is much flexible to manage different kernel and OS.
       It address partitions on disks as 
                       (hd0)        first hard disk 1st partition 
                       (hd0,1)      first hard disk, 2nd partition 
                       (fd0)        floppy disk, 1st partition

       To install grub launch the script grub-install '(hd0)'
       or do interactively through cmd:
                  grub

____________________________________________________________ shared library

  The libraries shared among different programs (ex the printf) 
  allow program exe to have less size. The common code,
  stored in a 'shared library' is linked dynamically to each of them.

  If an exe has not the libraries it needs, it fails to run.

ldd:   is the prog that allow to know which libraries are required
       by an exe.
               ex.  ldd /bin/bash
                linux-vdso.so.1 =>  (0x00007fff5613c000)
                libtinfo.so.5 => /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007ff4d1282000)
                libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ff4d107e000)
                libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff4d0cb9000)
                /lib64/ld-linux-x86-64.so.2 (0x00007ff4d14d0000)

ld.so   it's the dynamic lynker. Search each library in 
        1. $LD_LIBRARY_PATH  that like $PATH, lists the dir to search separated by ':'
        2. the file '/etc/ld.so.cache'  which is a bin file (fast to read) generated
           by 'ldconfig' cmd
               ldconfig -p        list what is inside the cache
ldconfig       ldconfig dirs...   add new dir in the cache.

 
____________________________________________________________ packegs
  
  ------------
  .deb     (Debian). They are in the form
                
                name_vvv-rrr_aaa.deb

                vvv   version      (major id)
                rrr   revision     (minor id)
                aaa   architecture (patch level)

           they are managed by the tools:

         . dpkg        command line
         . apt-get     command line
         . dselect     interactive fron-end for dpkg

         . alien   can create .deb pkg or also 
                   convert non deb pkg like (rpm)

                   -i   install the pkg and remove the converted pkg   
                   -r   convert pkg in rpm
                   -t     "      "     tgz

                   ex.  alien -i package.rpm

   
         . /var/lib/dpkg/  contains text files (ex status / available) and dirs
                           with the information of installed pkg, what to remove, ...
                           This dir is used by both dpkg and apt-get

         . dpkg:
               -i       pkg    install pkg
               --purge  pkg    remove  pkg
               -r       pkg    remove  pkg but not the .conf files
               -E              not overwrite prev installed pkg (with same  version)
               -G                        idem                   (..   older   ..   )
               -L       pkg    list files installed from pkg
               -s       pkg    display status info for pkg
               -S   pattern    Search for files with that patter in all pkgs
               -l  [pattern]   list info for all pkg names that match pattern
                               if pattern is not specified list info for all pkgs
               --unpack pkg    unpack but not install
               -R              recursively on subdir (ex to add at option -i, ..)
               --print-avail pkg   extract info for pkg from /var/lib/dpkg/available
               --configure   pkg   Configure an unpacked pkg. Requires setup of conf files.


               ex.  # dpkg -S apt-get
                      apt: /usr/share/man/man8/apt-get.8.gz
                      apt: /usr/bin/apt-get

               ex.  # dpkg -l 'ap*'
||/ Name                    Version          Architecture     Description
+++-=======================-================-================-============================
un  apache2.2-bin           <none>           <none>           (no description available)
ii  apg                     2.2.3.dfsg.1-2ub amd64            Automated Password Generator 
un  apmd                    <none>           <none>           (no description available)
ii  app-install-data        14.10            all              Ubuntu applications (data files)
                    ...     ...     ...     ...     ...     

  ------------
  apt-get      Advanced Package Tool (APT), not only specific for .deb

               -d   download only not install (to prevent install errors if download stops)
    options    -s   simulate the changes, but do nothing
               -y   answer yes automatically to all prompts

               install pkg  install / upgrade 
    commands   remove  pkg  
               upgrade pkg  upgrade only if dep are ok with no conflicts. 
               update  pkg  fetch a list of currently available pkg
               dist-upgrade   upgrade the debian distribution

               list the pkg to obtain in 
                                        /etc/apt/sources.list



  apt-get      Advanced Package Tool (APT), not only specific for .deb


  ------------
  rpm     
        -i  
            -v        verbose
            -vv       super "
            -h        display hash (#) as progression bar during install
            --test    not install, only test
            --force   replacement (allow an old pkg to replace a newer!)

        -U  upgrade   upgrade also if there wasn't a previous version
                      so it acts like the install (-i)
            --test    not upgrade, only test

        -e  remove
            --test    not remove, only test

        -q  query
            -a        list all pkgs                      rpm -qa
            -l pkg    list all files inside pkg          rpm -ql kernel-source
            -c        list only conf files               rpm -qc at
            -d        list only doc  files               rpm -qd at
            -i pkg    list info of pkg                   rpm -qi kernel-source
            -f xxx    list any pkg containing file xxx   rpm -qf /etc/aliases
            -R        list the Required pkg by this pkg
            -p        to specify a pkg (ex. I can write rpm -qi pkg / or rpm -qi -p pkg)

        -V  Verify
  ------------
  yum   (Yellowdog Updater Modified)
        is configured through the /etc/yum.conf

        yum install        yum install samba
        yum erase          yum erase   httpd  # remove only if ok with dep
        yum remove         yum remove  httpd  # remove without check dep (caution!)
        yum check-update
        yum update
        yum list           list all pkg in the system
        yum info           ex. yum info samba
        yum search
____________________________________________________________ network
  ipconfig     (can be an alias for   nmcli dev list iface eth0 | grep IP4)
  ip route     (to get default gateway)
  ip addr      (to get my addr)
  route -n     (overbiew where traffic is going)
  cat /et/resol.conf  (dns info)
  cat /etc/hosts      (preloaded hostnames)

____________________________________________________________CRONTAB
 crontab means cron table, that is where root or any user
 can add some rows (with the cron syntax) to specify periodic tasks
 to be executed.
 The syntax for each row is:
 
  * * * * *  command to execute
  │ │ │ │ │
  │ │ │ │ │
  │ │ │ │ └───── day of week (0-6) (Sunday=[0 or 7], or use names SUN-SAT)  - SC
  │ │ │ └────────month (1-12 or JAN-DEC) - SC
  │ │ └──────────day of month (1 - 31)   - SC
  │ └────────────hour (0-23)             - SC
  └──────────────min  (0-59)             - SC

SC (Special Chars) are 
      *    value skipped
      ,    when the value is a list  (ex. MON,WED,FRI)
      -    when the value is a range (ex. 2000-2010)
      /    (only on some cron implementations) the syntax */<value>
           means only 'mod' <value>. ex an hour */3 means any hour mod-3 (0,3,6,9,...) 
ex:   
   0 20 * * * /home/oracle/scripts/export_dump.sh      (run each day at 20:00)
   1 0  1,2 * *  printf > /var/log/apache/error_log    (run on 1st and 2nd days of each month at 00:01)

/etc/cron.allow        can list on rows, the usernames with    the rights to run cron
/etc/cron.deny              "        "         "       without      "          "  

File location depends on the Unix distribution. A file named with the user name (`whoami`)
is store in the following dirs:

/var/cron/tabs/             FreeBSD/OpenBSD/NetBSD
/var/spool/cron/            IBM AIX Unix CentOS/Red Hat/RHEL/Fedora/Scientific Linux
/var/spool/cron/crontabs/   HP-UX Unix Debian / Ubuntu Linux
/usr/lib/cron/tabs/         Mac OS X

crontab [-u user] [ -elri ] <file>

-e     crontab files (for each user) are not edited directly but with crontab -e
       which opens the editor specified in env var (VISUAL or EDITOR)

-l     to list the entries 

-r     to clean all the tables (any crontab row) 
       -i      (prompt before deleting user's crontab)

[-u user]   to do the above commands as associated to user
            (used by root to add to some of the users)

<file>   instead of -e, I can load a crontab directly from a file



a way to backup and restore is:
     1. crontab -l > c.txt
     2. crontab  c.txt 

a way to copy from an user to another:
     crontab -u <user1> -l | crontab -u <user2>

a way to copy to another server
     crontab -l | ssh $remote_host crontab
____________________________________________________________

/proc  list info like

       cat /proc/interrupts 
               CPU0    CPU1    CPU2    CPU3    CPU4    CPU5    CPU6    CPU7       
         0:      18       0       0       0       0       0       0       0  IR-IO-APIC-edge      timer
         1:   25529    1004     807     884    1470    1138    1023     851  IR-IO-APIC-edge      i8042
         7:       8       0       0       0       0       0       0       0  IR-IO-APIC-edge    
         8:       0       0       0       1       0       0       0       0  IR-IO-APIC-edge      rtc0
         9:   13528    6556    4940    4684    5402    3156    2419    2306  IR-IO-APIC-fasteoi   acpi

        cat /proc/dma
         4: cascade

        cat /proc/ioports 
        0000-0cf7 : PCI Bus 0000:00
          0000-001f : dma1
          0020-0021 : pic1
          0040-0043 : timer0
          0050-0053 : timer1
          0060-0060 : keyboard
          0062-0062 : PNP0C09:00
            0062-0062 : EC data
____________________________________________________________

USB     # lsusb -t             (to show devices physically USB attached)
                        Bus# 4
                        '-Dev#    1 Vendor 0x0000 Product 0x0000
                        Bus# 3   
                        '-Dev#    1 Vendor 0x046d Product 0xc501
                        |-Dev#    2 Vendor 0x0781 Product 0x0002
                        '-Dev#    3 Vendor 0x0000 Product 0x0000
                        Bus# 2    
                        '-Dev#    1 Vendor 0x04b8 Product 0x0005

        # types of USB host controllers

          OHCI  - USB1.1   12 Mbps   Open      Host Controller Interface
          UHCI  - USB1.1   12 Mbps   Universal Host Controller Interface
          EHCI  - USB2.0  480 Mbps   Enhanced  Host Controller Interface
____________________________________________________________

MODULES:       cat -n /proc/modules     to see which is running
                                        'lsmod' is a trivial prog to make that cat
                                        better presented.

               modinfo                  list info on a module (ex. author)

               lspci                    list the PCI bus, and the device attached
                        -t              displays in a tree form
                        -vv             very verbose

               insmod                   to insert a new module in the running kernel
                                        ex. insmod fat
                        -s              output to syslog instead of stdout
                        -v              verbose

               rmmod                    to remove a module
                        -a              remove all unsude mod
                        -s              syslog

               modprobe                 Act as a wrapped arounf both insmod and rmmod
                                        taking care of dependency.
                                        So modprobe add mods
                        -r              modprobe -r remove mods

















