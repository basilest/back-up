
--------------------------------------------------- / Encription

       SERVER             13           CLIENT
 i)    ----------------- [P]-----------------   a common prime number [P] is agreed
                                                between CLIENT & SERVER
                          7
 ii)   -----------------[AES]----------------   a common algorithm ("encryption generator" (ex AES))
                                                is agreed. Ex. choose another PRIME P2  (7)
 iii)   8                                5
       [pS]                             [pC]    2 normal integers are individually chosen by CLIENT and SEVER
                                                They are kept secret and not sent.
 iv)    1                                6
       [pubS]                           [pubC]  2 public keys are generated individually (& sent)
                                                using some formula F and the info so far:

                                                          ( P , AES , pS ) ---> pubS
                                                          ( P , AES , pC ) ---> pubC

                                                ex F: (P ^ pS   mod  P2)
                                                                      13 ^ 8   % 7 = 815730721 % 7 = 1
                                                                      13 ^ 5   % 7 = 371293    % 7 = 6


 v)    [K]                              [K]     Diffie-Hellman alg. proves that working individually with the info so far,
                                                both CLIENT & SERVER calculate the same number [K]

                                                          Diffie-Hellman ( P - pS - pubC ) ---> K
                                                          Diffie-Hellman ( P - pC - pubS ) ---> K

                                                                      6  ^ 8   % 7 = 1679616  % 7 = 1
                                                                      1  ^ 5   % 7 = 1        % 7 = 1

                                                called "Session key"
                                                that is used to encrypt all the communication that follows.

                                               The magic is due to a property of modulo exponents:

                                                           ( P ^ x mod P2 ) ^ y  mod P2  = P ^ xy  mod P2   = K
                                                           ( P ^ y mod P2 ) ^ x  mod P2  = P ^ yx  mod P2   = K


       To have K that can be any value between 1 - (P-1)
       the P2 at step ii) is chosen as a "primitive root modulo P" that is a quite complex stuff
       and it's not easy to locate it with a simple formula, even if they are still calculated with
       more complex calculations.

       session key
       Asymmetrical Encryption
       Symmetrical Encryption
       aes128-ctr
       1st authentication : establish encryption to protect future communication.
       2nd encrypting the connection
       public/private asymmetrical key pairs that can be created are only used for authentication,
       public  key:  can only encrypt messages (not able to decrypt back)
       private key:  the only component capable to decrypt
       session key:  Diffie-Hellman
                     client & server combine individually their own private data with public data
                     from the other system to arrive at an identical secret session key.
--------------------------------------------------- / ssh
        SERVER              CLIENT
         |                  | ~/.ssh/known_hosts
         |                  |       /id_rsa
         |              1)  |       /id_rsa.pub <--- ex. "ssh-rsa AAAAB3N.....sbasile@pd12682.internal.ch"
         |                  |            |                     ^
         |                  |            |to copy here
         |                  |            |
     2)  |~/,ssh/authorized_keys  <------' 1 line for each pub-key (so copy pasted here the client id_rsa.pub)
         |                  |              (nb. each *.pub key has the 1st chars saying its type: rsa/dsa/...)
       __|_____            _|_______       The server will authenticate only these clients
      |        |          |         |
      |  sshd  |  <=====> |   ssh   |
      |________|          |_________|


      There could be different ways to configure the handshaking, anyhow
      roughly it is:
             1) a client connects

    - 'sshd':   is the real OpenSSH daemon (on the server)
                that interacting with the other ssh client
                they together  allow a secure encrypted communication
                over an insecure network.

                -D   sshd will not detach and does not become a daemon.
                     This allows easy monitoring of sshd.
                -f   to specify a config file other than /etc/ssh/sshd_config
                -p   a port other than 22


    ~/.ssh    <--- is a dir (on the client) (N.B. chmod must be 700 for this dir)
                   containing usually something like:

                          -rw-r--r--  1 sbasile  staff   182 10 Jul  2015 config
                          -rw-------  1 sbasile  staff   668  2 Jul  2015 id_dsa <---- keys for SSH version 2 <--- DEFAULT
                          -rw-r--r--  1 sbasile  staff   626  2 Jul  2015 id_dsa.pub
                          -rw-------  1 sbasile  staff  3243 29 Jun  2015 id_rsa <---- keys for SSH version 1
                          -rw-r--r--  1 sbasile  staff   753 29 Jun  2015 id_rsa.pub
                          -rw-------  1 sbasile  staff  1468  6 Jan 13:00 known_hosts
                          -rw-r--r--  1 sbasile  staff    45  3 Jun  2015 ssh_config

                          the convention is
                            |    ~/.ssh/identity     rsa  SSH ver. 1
                       (D)  |    ~/.ssh/id_rsa       rsa  SSH ver.   2
                            |    ~/.ssh/id_dsa       dsa  SSH ver.   2
                            |    ~/.ssh/id_ecdsa   ecdsa  SSH ver.   2

                                                   ec : elliptic curve

    - Once having a public key (eg id_rsa.pub) it's possible to log into a remote server R
      doing this on R:
                     - create or enter into dir ~/.ssh   (must have chmod 700)
                     - append in ~/.ssh/authorized_keys (or create if not present, with chmod 640)
                       the exact text of ~/.ssh/id_rsa (with no new line)
                     - (some servers that the file is called with an ending 2: a authorized_keys2)

                   ______________________________________
                   | Most probably the above commands are executed directly onto server R
                   | but anyhow ssh allows to execute each as ex:
                   |    - ssh basilest@R mkdir -p .ssh   (and add the password at prompt)
                   |    - cat .ssh/id_rsa.pub | ssh basilest@R 'cat >> .ssh/authorized_keys'
                   |_____________________________________



    - 'ssh-keygen': the above files are created by 'ssh-keygen':
                    ex. ssh-keygen -t rsa -b 4096 -C "your_email@example.com"  -f pippo_rsa

                              -t : rsa1            for SSH v.1
                                   rsa,dsa,ecdsa   for SSH v. 2
                              -b : min is    768
                                   default  2048
                                   ecdsa: ec sizes are 256 384  521

                              -f   to add a meaningfull name (otherwise you don't know for which
                                   server it was created)
                                   So  dir ~/.ssh can contain many diffenet ssh-keys for different servers.

                              -O
                                   clear      clear all enabled permissions.  This is useful to clear
                                              the default set of permissions that can be
                                              added individually.

                                   force-command=command
                                              Forces the execution of command instead of any shell or
                                              command specified by the user when the certificate is
                                              used for authentication.

                                   no-agent-forwarding     Disable ssh-agent(1) forwarding
                                   no-port-forwarding      Disable port forwarding
                                   no-pty                  Disable PTY allocation
                                   no-user-rc              Disable execution of ~/.ssh/rc by sshd(8)
                                   no-x11-forwarding       Disable X11 forwarding


                          config
                               1	KeepAlive yes
                               2	ServerAliveInterval 20

                               3	Host github.com
                               4	  User git
                               5	  ProxyCommand /usr/local/bin/corkscrew wsproxy.internal.ch 8080 %h %p

                               6	Host wswebdev1
                               7	  HostName %h.orctel.internal
                          id_dsa
                               1	-----BEGIN DSA PRIVATE KEY-----    <--- this was without a passphrase
                               2	MIIBugIBdAKBgQCpHnP/mm59BzhOKjelK+BqozuwK3Li804qXkOfW0PC1em2CXAn
                               3	Al2AVYG/5ydl5uNuW1NEb+phcuLkhNhXYbf0fs7+q6Xbm/9Nt3I74Z4OFkSEUYfV
                                                   ....
                              10	3CKM0PWJEa4aFMC9qNRZoFhRVdTzpQlussZdunYlLOjGmwZlHnPTGgIULR79nL2p
                              11	v5Iq6mWKZqVm0sEniWY=
                              12	-----END DSA PRIVATE KEY-----
                                             id_dsa
                                                  1	-----BEGIN DSA PRIVATE KEY-----    <--- this how it looks with a passphrase
                                                  2	Proc-Type: 4,ENCRYPTED
                                                  3	DEK-Info: AES-128-CBC,2DADDEF9CB50685509A1197A4D244772
                                                                      ....
                                                 10	3CKM0PWJEa4aFMC9qNRZoFhRVdTzpQlussZdunYlLOjGmwZlHnPTGgIULR79nL2p
                                                 11	v5Iq6mWKZqVm0sEniWY=
                                                 12	-----END DSA PRIVATE KEY-----
                          id_dsa.pub
                               1	ssh-dss AAAAB3NzaC1kc3MAAACBAKkdc/+abn0HO....== sbasile@pd12682.companieshouse.local
                          id_rsa
                               1	-----BEGIN RSA PRIVATE KEY-----
                               2	MIIJKQIBAAKCAgEA8zHExVpDqZNOBO38byaIrFZn1vaNRj+lAvkNEL6HZIZYaVyc
                              50	            ....
                              51	-----END RSA PRIVATE KEY-----
                          id_rsa.pub
                               1	ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQ....== sbasile@pd12682.internal.ch
                          known_hosts   <--- stores the servers where I connected to
                               1	wswebdev2.orctel.internal,192.168.60.202 ssh-rsa AAAAB3NzaC1yc2....
                               2	wswebdev1.orctel.internal,192.168.60.201 ssh-rsa AAAAB3NzaC1yc2....
                               3	github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDb....
                               4	chl-dev,10.100.100.102 ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAwZak....
                          ssh_config
                               1	ServerAliveInterval 15
                               2	ServerAliveCountMax 3

                      passphrase : when generating a key, if no passphrase is specified the key (ex. id_rsa file)
                                   is in clear text. With a passphrase it is encripted, so even if an hacker can access my id_rsa
                                   it's not usable.

    - 'ssh-agent':     it can be started to run in background,

                 eval "$(ssh-agent -s)"  --> Agent pid 3319
                 echo $SSH_AGENT_PID     --> 3319
                 lsof | grep -i 3318     --> ssh-agent 3319 sbasile    3u    unix 0x6b706d27656c46d7  0t0  /var/folders/6k/qfwxd7ln1tdg_6pw7s6c10k00000gr/T//ssh-9sXXPCGOd5l2/agent.3318
                 echo ${SSH_AUTH_SOCK}   --> /var/folders/6k/qfwxd7ln1tdg_6pw7s6c10k00000gr/T//ssh-9sXXPCGOd5l2/agent.3318
                                             the default values is $TMPDIR/ssh-XXXXXXXXXX/agent.<ppid>
                 echo $TMPDIR            --> /var/folders/6k/qfwxd7ln1tdg_6pw7s6c10k00000gr/T/

                       it can be started to run in background, eval "$(ssh-agent -s)"
                       having a pid (which is then stored in var  $SSH_AGENT_PID).
                       This agent opens a UNIX socket in $TMPDIR (full name in ${SSH_AUTH_SOCK}
                       but it can be changed with option -a: ssh-agent -a ...).
                       On this read-only-by-the-user SOCKET channel,
                       the agent interacts with the other utilities of the ssh- family:

                           ssh-add
                           ssh-keygen
                           ssh
                           sshd

                 ssh-agent -k        <-- it exits (kill) the running instance of ssh-agent
                                        (the pid is still in $SSH_AGENT_PID))
                                        the output is unset SSH_AUTH_SOCK;  <---- so use ssh-agent -k to remember these names
                                                      unset SSH_AGENT_PID;
                                                      echo Agent pid 3319 killed;

    - 'ssh-add':   adds any desired keys to the agent  (ex. ssh-add ~/.ssh/id_rsa)

                       ssh-add         with no arguments adds the 4 files (D) above, (or what present of them)
                                       (the passphrase (if any) must be filled)
                       ssh-add -l      list of the keys inside the agent
                       ssh-add -d      To remove the loaded keys (it can be usefull to test the passpharse
                                       because after the ssh-add -d another ssh-add  will ask for the passphrase)

    - The sequence is usually:
                               1. eval "$(ssh-agent -s)"       create a running instance of ssh-agent
                               2. ssh-add                      add any desired keys
                               3.

    - Configure SSH server:  add a 'git' user shared among all the project developers:
                             sudo adduser git
                             su git
                             cd
                             mkdir .ssh && chmod 700 .ssh
                             touch .ssh/authorized_keys && chmod 600 .ssh/authorized_keys
                             cat /tmp/id_rsa.john.pub    >> ~/.ssh/authorized_keys
                             cat /tmp/id_rsa.josie.pub   >> ~/.ssh/authorized_keys
                             cat /tmp/id_rsa.jessica.pub >> ~/.ssh/authorized_keys
                             cd /opt/git
                             mkdir project.git
                             cd project.git
                             git init --bare
                             cat /etc/shells    <--- store all possible shells (add the path of git limited shell)
                             which git-shell    /usr/bin/git-shell
                             sudo vim /etc/shells
                             sudo chsh git      <--- add git to user able to login with a shell (chsh: change login shell)
                                                     user xxx can log from remote: ssh git@gitserver
    - 'ssh':
                ssh -v git@github.com     -v verbose   -vv   -vvv (max)


                -1    try SSH ver 1
                -2         "     2
                -4    IPv4 addr only
                -6    IPv6      only

                -p                 to connect to a port different from 22
                -i keyfile         do specify something diff from the defaults ~/.ssh/id_dsa ...
                -g                 Allows remote hosts to connect to local forwarded ports.
                -e escape_char     can change the escpae default char ~ (see below, session manag.) to another

                -t                 INTERACTIVE shell:  ssh -t user@hostname sudo command
                                   (note that an INTERACT. and a NOT-INTERACT. shell load different config files
                                    so for ex. the $PATH vars could be different)


    - session commands:
                        ENTER ~ .          ENTER: to be sure to have a newline
                                           ~      starts the submission of ssh control char
                                           .      ssh control char to mean END session

                                           The above close a stuck ssh session.

                             ~?            help (list of avail escapes)

                             ~^Z           suspend the remote ssh connection and
                                           allow to be at 'local' prompt.
                        Once I'm over, a fg bring me back into remote.

    - remote commands via SSH:

              |  ssh user1@serv date                     1 command
              |  ssh user1@serv 'df -H'                  1 command  (quote if spaces sometimes can help)
              |  ssh user1@serv 'ls; pwd; cat a.txt'     + commands
              |  ssh user1@serv 'ls && pwd && cat a.txt' + commands
              |
              |
              |                                          + commands  (the "heredoc" ususl way to write on multilines) :
              |
              |  VAR1="boo"
              |  ssh -T $HOST << EOSSH           ssh -T $HOST <<'EOSSH'    <---- use '' is want to assign and use remote var
              |  ls                              VAR1=`pwd`
              |  pwd                             echo $VAR1
              |  if true; then
              |    echo $VAR1                    VAR2=$(uname -a)
              |  else                            echo $VAR2
              |    echo "False"
              |    fi                            EOSSH
              |  EOSSH
              |
              |  use of LOCAL vars              use of REMOTE vars
              |
              |
              |
              |  ssh user1@serv '/scripts/r.sh'          run remote script
              |  ssh user1@serv < loc.sh                 run a local script (just an input redirect, so also a pipe work:    cat loc.sh | ssh user1@server1 )



