


write my own built-in and keep into the running shell

----------------------------------------------------------


 $0              name of script
 $1, $2, $3, ... are the positional parameters.
                  ...  after $9, ${10}, ${11}, ${12}.
 $#              NUMBER of args
 $*              string with ALL args (seen as a single word)
                 more exactly  "$*" is the IFS expansion of all positional parameters, $1 $2 $3 ....
 $@              same as $* but each arg is quoted
                 more exactly it's an array-like construct of all positional parameters, {$1, $2, $3 ...}

 $?              EXIT STATUS of most recent foreground pipeline

 $$              PID of the current shell (not subshell).
 $!              PID of the most recent background command.

 $_              last cmd name or if it had options last option  (ex du >/dev/null   $_:du    ls -al  $_:-al)
                 (or at startup, the abs path of the command to start the current shell immediately after startup).
 $-              Flags passed to script (ex in a shell the flags passed ex --> himBH)
                 but actually doesn't work well in bash (it comes from ksh)


$a               better to use ${a}
${a/23/BB}       substitue in $a 23 with BB
$(cmd)           better than `cmd`       $(ls -l)
$((5+3))         better than $[5+3]
${#a}            len of char of a (as a string)
${#array[*]}     len of array $a
${#array[@]}          idem


____________________________________________________________
	 ( )     [ ]      { }
____________________________________________________________



Brackets

     1) if [ CONDITION ]             [ is like an external command (test) even if 'builtin'.
                                     that is why a space after [ is required
                                     as it is a command by its own, it manages parameters with its own syntax  (uses -a -o  for and or)
                                     ( ) can be used to group with -a or -o but
                                     must be escaped [ \( .... \) -a ...
     2) if [[ CONDITION ]]           is a shell 'keyword' to test (uses && ||  and also regex =~)
                                     so should be always the preferred way.
     3) Array[1]=element1            Array initialization
     4) [a-z]                        Range of characters within a Regular Expression
     5) $[ expression ]              A non-standard & obsolete version of $(( expression ))


Curly Braces

	 1) {}                                      Text replacement, after find and xargs
	 2) ${variable}                             Parameter substitution
	 3) ${!variable}                            Indirect variable reference
	 4) { command1; command2; . . . commandN; } Block of code   (note a 'space' after '{' and ';' before last '}')
                                                Thanks to the space, this usage of {} can be distinguished.
                                                This block of code is like an anonymous function.
                                                It means:
                                                    . I can group more commands as a whole
                                                    . it's not executed in an SUBSHELL but inline
                                                    . vars defined inside are then visible even outside

	 5) {string1,string2,string3,...}           Brace expansion  ex. (<-- NO SPACE after the ',')
                                                a{d,c,b}e --> ade ace abe)
                                                /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
                                                         --> /usr/ucb/ex /usr/ucb/edit /usr/lib/ex?.?* /usr/lib/how_ex

	 6) {x..y[..incr]}                          Extended brace expansion
                                             echo {1..5}         1 2 3 4 5
                                             echo {1..5..2}      1 3 5
                                             echo {001..005}     001 002 003 004 005
                                             echo {001..005..2}  001 003 005
                                             echo {a..z}         a b c d e f g h i j k l m n o p q r s t u v w x y z
                                             echo {a..z..2}      a c e g i k m o q s u w y

                                                    nb. It can be nested:
                                                       b{ar{d,n,k},ed}s  --> bards barns barks beds

Parentheses

	 1) ( command1; command2 )             Command group executed within a subshell  (nb. runs a child SHELL)
	 2) Array=(element1 element2 element3) Array initialization
	 3) result=$(COMMAND)                  Command substitution, new style - used to assign the OUTPUT of a command (runs a child SHELL)
                                           nb. command sub. can be nested $(ls $(pwd))
                                               like the old ` ` that required anyhow to escape the internals: ` .. \` \` ...`
	 4) >(COMMAND)                         Process substitution  <--- NO SPACE: >(    <(
	 5) <(COMMAND)                         Process substitution

Double Parentheses   (vars inside can be written with or without the '$')

   	 1) (( var = 78 ))                     Integer arithmetic
   	 2) var=$(( 20 + 5 ))                  Integer arithmetic, with variable assignment

           allowed operators:
                            + - * /
                            ++
                            --
                            %
                            **       (exponential)
                            << >>    (bitwise shift)
                            & | ~ ^  (bit: AND OR NOT EXCLUSIVE-OR)
                            !        (logical NOT)
                            < <= == => > != && ||


   	                        ex. (( var++ ))
   	                            (( var-- ))
   	                            $(( (3 > 2) || (4 <= 1) )) has the value 1
   	 3) (( var0 = var1<98?9:21 ))          C-style ternary operation

     TRUTH VALUE RETURNED BY $(( )) is the opposite of 'test' and 'exit status'
     true=1  false=0
         $(( 5 > 3 ))     echo $?   --> 1
         [ 5 -gt 3 ]      echo $?   --> 0

____________________________________________________________
  PARSER
____________________________________________________________


            [1] split into words                      | separetors: SPACE\t\n;)(><|&
                                                      |
                      " ? --> [4]                     |
                      ' ? --> [9]                     |
                    |                                 |
     ______________________________________           |
     |          check 1st w.               |          |
     |                                     |          |
  [1] <-- opening key.      other key.   ---> SYNTAX  |
     |  (if, function     (then, fi, done, |  ERR     |
     |      ...)              ...)         |          |
     |         not keyword                 |          |
     |_____________________________________|          |
                    |                                 |
                                                      |
  [1] <--     alias ?                                 |
                    |                                 |
           [2]   brace exp.                           | a{b,c} --> ab ac
                    |                                 |
           [3]   tilde exp.                           | ~ste   --> /home/ste
                    |                                 |
           [4]   param exp.                           | $VAR   --> 5
                    |                                 |
           [5]   cmd subst.                           | $( grep ...)
                    |                                 |
           [6]   arith. subs.  " ? --> [9]            | $(( i++ ))
                    |                                 |
           [7]   word split                           | separators: IFS
                    |                                 |
           [8]   path exp.                            | /**/a.?
                    |                                 |
           [9]   cmd lookup                           | builtin / $PATH
                    |                                 |
          [10]   RUN (eval)                           |
                                                      |

____________________________________________________________
  SPECIAL CHARs
____________________________________________________________
       1  ~         home
       2  `         old cmd substitution
       3  #         comment
       4  $         var
       5  &         background
       6  *         STRING wildchar
       7  ()        see braces
       8  []        "
       9  {}        "
      10  \         QUOTE next char (any of these 19 chars is no more special)
      11  |         pipe
      12  /         pathname
      13  ;         cmd separator
      14  '         strong QUOTE (any these 19 chars is no more special)
      15  "         weak QUOTE   (some of these 19 chars, ex. '$', remain special)
      16  > <       in-out redirection
      17  ?         CHAR wildchar
      18  !         not
      19  RETURN    run cmd. (note that both \ ' or " escape correctly it,
                              so having a long cmd on more lines, with the
                              prompt defined in PS2)


      CTRL          CTRL like DEL/BACKSPACE/ALT are some more 'special' chars
                    Most common:
                       CTRL-C      intr  (kill 2)
                       CTRL-D      eof
                       CTRL-\      term  (kill 15) more powerfull than 2

                       CTRL-?      the same as DEL
                       CTRL-M      the same as RETURN

                       CTRL-Z      suspend

                       CTRL-S / Q  suspend / restart screen output
____________________________________________________________
  CTRL ------- READLINE & BIND

  All the CTRLs come from the READLINE C-Library that in GNU is the
  common code to many applications.
  I can write a C prog myself, that including the library:
         #include <readline/readline.h>
         #include <readline/history.h>
  and then linking it ( -lreadline)
  can have all the features (ex TAB for autocompletion and so on).
  Readline key bindings (all the CTRL & ALT) are taken from the text editor Emacs,
  but can be customized.
  On some systems, Esc must be used instead of Alt, because the Alt shortcut conflicts with anothers.

  READLINE configuration is done in the file ~/.inputrc  (even with proprietary
  syntax commands $if $else $endif)
  .inputrc is usually a list of keybindings ex:
       Control-u: universal-argument
       Meta-Rubout: backward-kill-word

  It is really full-featured and complex. Use man readline



  bind is another way to operate on readline, and link a special sequence
  of keystroke to do something
      bind -P  to see which and how any of the sequneces are configured
      bind -l  to see all the names of the readline functions
      bind -p  provides an output that is in the syntax of .inputrc
               so a way to start with an .inputrc is bind -p > ~/.inputrc
____________________________________________________________
  HELP
____________________________________________________________

   man       usual help
   help      gives info on a command (ex 'help cd').
             It can be even partial (ex 'help re, will give
             help on all startin with re (ex. 'read' 'readonly' 'return'))
             or wildchars (ex help 're??' will only returns help on 'read').

____________________________________________________________
~      $HOME
~+     $PWD      (current dir)
~-     $OLDPWD   (previous wd)

____________________________________________________________
  EMACS or VI editor mode

  To edit on the command line bash uses:
     1. emacs mode by default  (or it can be set as:   set -o emacs)
     2. vi mode  (set -o vi)
     3. no editor mode, if the shell was launched as bash .... -noediting

emacs mode:
            Ctrl-A    start of line
            Ctrl-E    end   of line
            Ctrl-U    delete till start
            Ctrl-W    delete current word
            Ctrl-B    move back by words / Alt-F move forward by words
            Ctrl-R    to search back in history
            ...

vi mode:
            - ESC to enter into vi-command mode
            - to enter vi-input mode (i a I A R ...)
            - then usual commands ($ 0 ^ w W b B e E D p ...)
            - even . as 'last command' is available
            - even ~ to change lower/upper case
            - to search back in history use / and then n or N (or ?)
            - autocomletion:
                 . normally TAB is all what you need, but even if it's not real vi
                   there are these autocompletions:
                     . do ESC and \, then
                         a =    to see the available possibilities
                         a *    to have the best match filled in
            - v  opens the line into vi (saving it will execute)
                 the same as doing 'fc' (fix line)
            ____________________________________________________________
            to add to the prompt in which vi-mode (edit | command) I'm currently in,
            add:
                     bind 'set show-mode-in-prompt on'     (in ~/.bash_profile)

            That feature is available in bash from ver. 4.3
            On mac there is a problem, as the bash is 3.x and they don't update
            for some GPL licence issues. So after using "brew install bash"
            that adds bash 4.x: /usr/local/bin/bash  (while the 3.x remains /bin/bash)
            Anyhow iTerm2 in the profile settings still opens /bin/bash
            (this can be seen with:  echo $BASH_VERSION)
            so add in profile-settings-command: /usr/local/bin/bash -l
            (with the missing -l , ~/.bash_profile is not sourced)
            even tmux opens /bin/bash so in ~/.tmux.conf add
            set -g default-shell /usr/local/bin/bash

____________________________________________________________
14 HISTORY TRICKS

    0. cmds history are save in HISTFILE (var usually = ~/.bash_history)
    1. export HISTTIMEFORMAT='%F %T ':   timestamp in front of each cmd 2008-08-05 19:02:39 ls
    2. Ctrl R   Ctrl R and then arrows <--  -->   to modify the command
    3. last cmd:  (1) !!   (2) !-1    (3)  Ctrl P <-- in emacs mode
    4. !4   to execute  num 4      !-4   to execute back of 4
    5. !ps  execute last cmd starting with ps
    6. HISTSIZE=450  HISTFILESIZE=550    to set history to 450 cmd and file .bash_history to 550 text lines
    7. export HISTSIZE=0    to make bash not record anything (no history)
    8. history -c   to clear all the previous history
    9. export HISTCONTROL=ignoredups         remember only 1 inst. of many consecutive = cmd
   11. export HISTCONTROL=erasedups          remember only 1 inst. of many also non consecutive = cmd
   12. export HISTCONTROL=ignorespace        ignore (not remember) cmd that start with a space
   13. export HISTIGNORE="pwd:ls:ls -ltr:"   ignore (not remember) this list of cmds
   14.  vi !!:$  execute a cmd (here vi) taking the arg of the last cmd
        vi  !^      "                  "           1st  arg     "
        vi !cp:2    "                  "           2nd  arg     "     starting with cp
        vi !cp:$    "                  "           last arg     "     starting with cp
   15. fc   (stays for fix command) is the builtin command to recall the history opening into editor mode
       the editor opened is defined by the var $FCEDIT  (ex FCEDIT=/usr/bin/vim)
       Once the editor is closed that command is executed.
       fc -l     list last 15 cmd
       fc -l 2023   edit cmd num 2025
       fc -l  vi    edit cmd starting with vi
       fc -s aaa=bbb xxx   edit last xxx cmd changing string aaa with bbb

____________________________________________________________
    SHELL OPTIONS:  set -o
____________________________________________________________
    a set -o produces the list of the on/off options of the shell:
                 Current option settings
                 errexit         off
                 noglob          off    <--- do not expand * and ?
                 ignoreeof       off    <--- Ctrl-D  doen't exit the shell (an explicit 'exit' is required)
                 interactive     off
                 monitor         off
                 noexec          off
                 stdin           on
                 xtrace          off
                 verbose         off
                 vi              off
                 emacs           off
                 noclobber       off    <--- .. > a.txt do not overwrite if a.txt is present
                 allexport       off              can be anyhow overwritten with  >| a.txt
                 notify          off
                 nounset         off
                 priv            off
                 nolog           off
                 debug           off
    To set an option on:  set -o    (ex set -o vi)
    To set an option off: set +o    (ex set +o vi)


    shopt    is a new builtin to set/unset even more options.
             shopt -p      to see the full list statuso
             shopt -s      to set
             shopt -u      to unset



____________________________________________________________

When Linux boots, executes all scripts in dir
                /etc/rc.d
to restore the sys config and set up services.
____________________________________________________________
how empty a file (e.g. named log.txt) with no char:

cat /dev/null > log.txt
____________________________________________________________
START A SCRIPT
____________________________________________________________

A shell script is a TXT file starting with
                  #!
The #! is actually a two-byte magic number she-bang or sh-bang:
concatenation of tokens sharp (#) and bang (!)

then followed by the executable file to launch
usually it is '#!/bin/bash' but can be

#!/bin/rm                # Self-deleting script.
#!/bin/more              # self-listing documentation file.

#!/bin/sh
#!/bin/bash
#!/usr/bin/perl
#!/usr/bin/tcl
#!/bin/sed -f
#!/bin/awk -f

/bin/sh invokes default shell, so /bin/bash in a Linux machine.
It makes the script portable to non-Linux machines, though you
sacrifice Bash-specific features


A shell is launched as
               bash

there are many options, each with a short symbol, or its long name.
To use the long name, the syntax is
                bash -o  ....long name ,,,,

                ex.
                    bash -v          (short)
                    bash -o verbose  (long form)
       nb.
       bash -v      prints also each cmd before executing it.
       bash -x      (xtrace) debugging an expanded form of bash -v

       bash -p      run as root  (priviledged)
       bash -t      run only 1st cmd and exit
       bash -s      run cmd from (stdin)
       bash -n      like make -n    goes through all the script cmds
                    without executing them (it is used for making
                    syntax check of the script....'compiling')
       bash -i      run the script (intercatively)
       bash -u      reports ERRORs for any UNSET var
       bash -e      EXITS at any point where the exit status $?
                    of that command (ex grep $a ...) should be != 0
                    (a general way to know when commands return
                     errors, without checking $? on all those lines)
       bash -a      EXPORTS all var that defines (so that child processes
                    can see them)

                          ex
                      parent.sh        child.sh
                        R=56           echo $R > aaaa    <-- aaaa is empty
                        child.sh

                      parent.sh        child.sh
                        set -a         echo $R > aaaa    <-- aaaa contains 56
                        R=56
                        child.sh

       bash -h      HASH or pre-store the PATH of each command (like a
                    pre-processor) to make it faster
       bash -k      Normally a line like
                             a=2  cmd  b=3 c d=4
                    'a' is an ENV var for cmd (as it comes before) b,c,d are args
                    with -k it's like
                             a=2 b=3 d=4 cmd c
                    so cmd has 1 only arg $1 and 3 ENV vars


so for debugging a.sh:
      solution 1:    bash -x  a.sh
      solution 2:    modify 1st line:  #!/bin/bash -x
      solution 3:    turn it on, only in the lines of interest:
                          set -x      <--- start debugging from here
                          set +x      <--- stop from now on

      nb. the effect of -v is very similar, anyhow it also dumps
          comments (is less detailed but more readable)

nb.  more flags must be grouped, because UNIX passes ONLY 1 arg
     so:
         #!/bin/bash -vah    WORKS!
     while
         #!/bin/bash -v -a -h    NOT!    (equivalent only to -v)

nb.  as the special var $- reports which flags are currently ON (ex hia)
     to call other scripts with the same set, I can use
            bash -$- child_script.sh
     So if for instance I execute father.sh with -x, it will be also propagated
     to child.sh
____________________________________________________________
	 FUNCTIONS
____________________________________________________________
    function xxxxx {       or even only       xxxxx {
    }                                         }


    (){...} (or function {...}) are called anonymous functions
    and are typically used to set a local scope: (){ local IFS=:; }

      A function as it's executed inline (not in a subshell) is faster than
      writing in a script

      declare -f:   to see all the function defined in current shell
      declare -F:   to see all the function defined in current shell (only the NAME)
      type xxxxx:   to see the code
____________________________________________________________
	 PRECEDENCE
____________________________________________________________

      1. Aliases
      2. Keywords     (ex if for ...)
      3. Functions
      4. built-in     (ex cd wait)
      5. exec         (to search in PATH)



      type xxx      to know what is xxx (from 1.Aliases to 5.exec):
                    ex.
                       type ls      ls is aliased to `ls --color=auto'
                       type if      if is a shell keyword

      type -a xxx   to have all the list from Aliases to exec
                       type -a ls
                                    ls is aliased to `ls --color=auto'
                                    ls is /bin/ls

      builtin  is the keyword that makes BASH to search only in the
               bultin set, skipping ALIASES and FUNCTIONs (that would come first)
               ex. builtin cd

      command  is the keyword that makes BASH search in builtin & PATH
               skipping (like in builtin) ALIASES and FUNCTIONs
               (ex. command rm)

      \        is the short for both builtin and command
               ex  \cd  instead of builtin cd
                   \ls  instead of command ls

      enable   to manage builtins
               -a      dump all and the status
               -p      dump all   (with no status)
               -d      unload (delete) a bultin
               -f xx   load a new builtin (shared object) xx
               -n xx   disable builtin xx (with no args, dumps all DISABLED)
               -s      to restrict on only POSIX subset


               skipping (like in builtin) ALIASES and FUNCTIONs
               (ex. command rm)

____________________________________________________________
BUILT-IN vs EXTERNAL PROG
____________________________________________________________

Some commands are built in the shell, for performance reason (they are frequently used)
others, are external commands.

POSIX, defines following as  regular Built-In

        alias        false         jobs         read       wait
        bg           fc            kill         true
        cd           fg            newgrp       umask
        command      getopts       pwd          unalias

           test       Evaluate expression.
           ulimit     Set or report file size limit.

while the following (even if they are even much more used of the above) are external cmds

           find       Find files.
           ls
           ln         Link files.
           pwd
           touch      Change file access and modification times.
           mv
           cp
           dd         Convert and copy a file.
           mkdir
           rm
           rmdir

           basename
           dirname
           cat

           chgrp
           chmod
           chown

           cksum      Write file checksums and sizes.
           sum        Print checksum and block or byte count of a file.

           cmp        Compare two files (good for binary conmpare).

           df         Report free disk space.
           du         Estimate file space usage.

           pathchk    Check pathnames.
           sh         Shell, the standard command language interpreter.
____________________________________________________________
END A SCRIPT
____________________________________________________________

use command exit

exit        #The right and proper method of "exiting" from a script.

            maybe with a variable to return a value

            E_NOTROOT=87   # Non-root exit error.
              .......
              exit $E_NOTROOT
____________________________________________________________
BUILTIN
____________________________________________________________

A builtin is a command contained within the Bash tool set, literally built in.
This is either for
   - performance reasons -- builtins execute faster than external commands,
     which usually require forking a separate process --
   - builtin needs direct access to the shell internals.
____________________________________________________________
SPECIAL CHARACTERS
____________________________________________________________

;  Permits putting two or more commands on the same line.

.       Equivalent to source.
        Invoked from the command-line, executes a script.
        Invoked from a script, imports code into the script, appending.
       (same effect as the C #include).
        This is useful when multiple scripts use a common data file:


. data_file    # Load a data file.
               # Same as "source data_file", but more portable.

"    partial quoting [double quote].
     special characters (except $  \ (escape) and ` (backquote))
     are preserved (from interpretation)

'    full quoting [single quote].
     All of the special characters
     are preserved
     This is a stronger form of quoting.

     NB. quoting must be seen as turn-on/off the SHELL interpreter
         on that string. So it's not mandatory to do it at the start&end
         but in any point if the effect it's the same, like the following:
         (where a file is named with a space in the middle)

                    rm 'file1 file2'
                    rm file1' 'file2
                    rm f'ile1 file'2



        hello="A B  C   D"
        echo $hello        # A B C D
        echo "$hello"      # A B  C   D    preserves whitespace.
        echo '$hello'      # $hello        preserve also $

     N.B. use quoting a variable when whitespace are important
     ex.
                  List="one two three"

                  # Splits the variable in parts at whitespace.
                  # Preserves whitespace in a single variable.
                  for a in $List                                     for a in "$List"
                  do                                                 do #     ^     ^
                    echo "$a"                                          echo "$a"
                  done                                               done
                  # one                                              # one two three
                  # two
                  # three

     Quoting can also suppress echo's "appetite" for newlines.
     echo $(ls -l)
          total 8 -rw-rw-r-- 1 bo bo 13 Aug 21 12:57 t.sh -rw-rw-r-- 1 bo bo 78 Aug 21 12:57 u.sh

     echo "$(ls -l)"
          total 8
           -rw-rw-r--  1 bo bo  13 Aug 21 12:57 t.sh
           -rw-rw-r--  1 bo bo  78 Aug 21 12:57 u.sh

`    (backquote)  can be used a pair of ` like                  # it's better to use $(cmd)
                          a=`cmd`
     to assign to a var the result of a command.
     (the shell will replace the string quoted by ``
      by the rerurned value)
     ` .. `  is also called (command substitution)


\    escape [backslash]. To quote a single character:
     \X has the effect of 'X'.
     It may be used to quote " and '

     It is also used when writing a command that continues on more lines.

     NB.




:    null command ["NOP"]
     It may be also considered a synonym for true.


     :   echo $?   # 0


     while :
     do
        ...          #Endless loop
     done

     When used with > is the same as cat /dev/null >
     : > data.xxx   # Same effect as   cat /dev/null >data.xxx

____________________________________________________________
SPECIAL CHARACTERS
____________________________________________________________
     ------------

!    from the command line triggers an history event.
     Not inside a script, as history it's disabled.
                  useful cmd for history
                         !!                repeat last
                         !15                  "   15th (absolute)
                         !-15                 "   15th (relative, back from now)
                         !stef                "   last starting with 'stef'
                         !?stef               "        containing    'stef'
                         ^stef^stefano        "   last, modifing stef with stefano

                  $HISTSIZE:  1000                  (<-- default)
                  $HISTFILE:  ~/.bash_history       (<-- default)

                  to have the 'vi'-like setting while editing bash cmd
                  use: set -o vi


!    reverse (or negate) the exit status of the command
     needs a space after !
     ex
       ls | bogus_command     # bash: bogus_command: command not found
       echo $?                # 127

       ! ls | bogus_command   # bash: bogus_command: command not found
       echo $?                # 0

$?   holds the exit status of a command, a function,
     or of the script itself.

$$   holds the process ID of the script in which it appears.

$_   is the last arg passed to the last executed cmd
     or if the last executed cmd had no args, its the name of the cmd itself
     du     > /dev/null;  echo $_    # du
     ls -al > /dev/null;  echo $_    # -al


()   command group. List commands within parentheses starts a subshell.
     ex:   (a=hello; echo $a)
     Var inside () are not visible to the rest of the script,
     act like local var.

     - stands also for array initialization.
     Array=(element1 element2 element3)

Globbing   Filename expansion: means expanding filename containing
           special char ex: pippo.??? --> pippo.001 or pippo.txt
           Only a few char of Regular Expression are understood:
           ?    1 char    (ex ls ??   matches files of 2 chars)
           *    any char (N.B. not match filenames start with a dot,
                ex: .bashrc)
           []   all char inside
           ^    for negating        ex. ls -l [^ab]*
           !    "      "

           So Globbing returns a list of (SORTED !!!!) names (file-names) and works
           also if it's not quoted
           (Yes, note that the Shell expands + sorts!)

           ex. echo *   -->  a.1 b.1 c.1 t2.sh test1.txt

           Is the shell to expand the * BEFORE the command
           on the command line is executed. So commands are not aware
           how the arguments originally were. This is sometimes used
           putting a file named -i in a dir, so that a "rm *"
           will be quite sure expanded (and sorted) as rm -i ...
           so asking confirmation





{}         (brace expansion)       # default is ON (like call bash -B
                                                         with bash +B    is OFF)
           It creates string. The form is
                 S1{a,b,c}S2
           a,b,c is a list of strings separated by a comma ,
           S1 is an optional string named 'prefix' put before each elem
           S2 is an optional string named 'suffix' put after each elem
                 so it comes:   S1aS2  S1bS2 S1cS2
           ex.
             echo a{d,c,b}e    #ade ace abe
             cp file22.{txt,backup}    #cp file22.txt file22.backup

             mkdir /usr/local/src/bash/{old,new,dist,bugs}    # -->

             mkdir /usr/local/src/bash/old
                   /usr/local/src/bash/new
                   /usr/local/src/bash/dist
                   /usr/local/src/bash/bugs

            Brace expansion is performed BEFORE any other. It's strictly text:
            any char (also special) is preserved:

            ex. echo XX{a,*,?.?}Y     # XXaY XX*Y XX?.?Y

            echo \"{These,words,are,quoted}\"   # "These" "words" "are" "quoted"

{a..z}      Extended Brace expansion. (Form version 3 of Bash).

            echo {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z
            echo {0..3} # 0 1 2 3
            base64_charset=( {A..Z} {a..z} {0..9} + / = )

{}           Block of code. An anonymous function.
             However, unlike in a "standard" function, the variables inside
             remain visible outside:

             a=123
             { a=321; }
             echo "a = $a"   # a = 321

             This is usefull on I/O redirection:
             --------------- < IN
             File=/etc/fstab

             {
             read line1
             read line2
             } < $File

             echo "First & Second line in $File are:"
             echo "$line1"
             echo "$line2"
             --------------- > OUT
             {
               echo
               echo "Archive Description:"
               rpm -qpi $1       # Query description.
               echo
               echo "Archive Listing:"
               rpm -qpl $1       # Query listing.
               echo
               rpm -i --test $1  # Query whether rpm file can be installed.
               if [ "$?" -eq $SUCCESS ]
               then
                 echo "$1 can be installed."
               else
                 echo "$1 cannot be installed."
               fi
             } > "$1.test"       # Redirects output of everything.
             ---------------
            N.B.  Unlike (), {} will NOT normally launch a subshell
            only exception is if it's in a pipe: ...| {..}


{}   Used in
      find  with option -exec
      xargs with option -i

      as a 'place holder', the full file path name is substituted for "{}".


      find   -exec COMMAND \;               # Carries out COMMAND on each found file
                                            # ";" is escaped to avoid shell interpreting.

      find ~/ -name 'core*' -exec rm {} \; # Removes all core dump files from user home

      ls . | xargs -i -t cp ./{} $my_dir   # copy current dir files into $my_dir




(( ))   integer expansion. Expand and evaluate int expression in (( )).
     ex. a=$(( 5 + 3 ))  # a=8
     It replaces the deprecated usage of $[]
     a=3; b=7;  echo $[$a+$b]    #10

     It's a mechanism for allowing C-style
     (( a++ ))  (( a-- ))   (( ++a ))  (( --a ))
     (( t = a<45?7:11 )<--------------------------------- nb use of ?)

     N.B. If the expression evaluated in (()) = zero -->  exit status = 1 ("false").
     A non-zero expression returns an exit status of 0, or "true".
     This is in marked contrast with a C-like behaviour or with using the others
     construct : test and [ ]

     (( ))  is used ot test NUMERICAL values       both required a space after ((  [[
     [[ ]]  is sued to test STRING    values                                     ^   ^

____________________________________________________________
I/O Redirection
____________________________________________________________
                                ----> stdout (screen fd=1)
     stdin (keyboar fd=0) ---->
                                ----> stderr (screen fd=2)

      1>pippo.txt  1>>pippo.txt         redirect stdout to write/append on pippo.txt
      2>pippo.txt  2>>pippo.txt         redirect stderr to write/append on pippo.txt
      &>pippo.txt  &>>pippo.txt         redirect both 1 and 2 to write/append on pippo.txt

     Other 7 numbers (3-9) are available as fd (on MAC any ex. 85)
     (a fd is the C file handle  (pointer to an 'open' file))


     N.B. the redirections are automatically "reset" after each line,
          (i.e. (stdout, sterr) are back to video).
          preceding the redirection with an  'exec'
          the effect remains on subsequent cmds of that current SHELL


      ________________________________________________________________
     | TO START a fd (ex 4) (assigning it to file in READ/ WRITE/ APPEND):
     |________________________________________________________________
     |
     |         4>pippo.txt   # create fd 4 to WRITE  on pippo.txt  If not set is 1 (stdout): >pippo.txt
     |         4>>pippo.txt  #             to APPEND                             1 (stdout): >pippo.txt
     |         4<pippo.txt   #             to read                               0 (stdin):  <pippo.txt
     |         4<>pippo.txt  #             to read/write                         1 (stdout): <>pippo.txt
     |____________________________________
     | TO USE a fd (ex 4):  the syntax is &4
     |____________________________________
     |
     |         'use' means, that on that current cmd of the command-line the read or write
     |         will be done using fd, so 0 or 1 or 2 will have a reassignment like:
     |             0<&4   1>&4    2>&4
     |                                       ex.  2>&1  redirect stderr to stdout
     |________________________________
     | TO CLOSE a fd: the syntax is  &-
     |________________________________
     |
     |          4<&-   # close 4 on READ
     |          4>&-   # close 4 on WRITE/APPEND
     |
     |                                    nb   <&-   short for 0<&-
     |                                         >&-   short for 1>&-
     |
     |           Child processes inherit open fds. This is how pipes work.
     |           To prevent a fd from being inherited, close it.


     lsof    is used to see open fds:

             lsof -a -p $$ -d0,1,2        #dump for this ($$) shell fds 0 1 2

             COMMAND PID     USER   FD   TYPE DEVICE SIZE NODE NAME
              bash    363 bozo        0u   CHR  136,1         3 /dev/pts/1
              bash    363 bozo        1u   CHR  136,1         3 /dev/pts/1
              bash    363 bozo        2u   CHR  136,1         3 /dev/pts/1


     ________________________
     | EXAMPLEs TO UNDERSTAND:
     |_______________________
     |   cat pippo.txt
     |                  --> aaaa
     |                      bbbb
     |   4>pippo.txt
     |                  --> the 1st effect is that pippo.txt is now empty (!) aaaa & bbbb deleted
     |                      the 2nd effect is that 4 is then no more present (nothing on lsof ... -d4)
     |   4>>pippo.txt
     |                  --> aaaa & bbbb still there
     |                      nothing on lsof ... -d4
     |   exec 4>pippo.txt
     |                  --> aaaa & bbbb deleted
     |                      can see it on lsof ... -d4:
     |
     |                          bash    6343 stiv    4w   REG    8,8   6   29 /home/stiv/TEST/pippo.txt
     |                                               ^
     |   exec 4>>pippo.txt
     |                  --> aaaa & bbbb still there
     |                      can see it on lsof ... -d4
     |   echo cccc 1>&4
     |                  --> pippo.txt will have aaaa & bbbb & cccc
     |   4<&-
     |                  --> 4 is closed only on this line
     |   exec 4<&-
     |                  --> 4 is closed forever
     |
     |So 'exec' can be avoided if everything occurs in 1 cmd line:
     |    4>>pippo.txt echo cccc 1>&4
     |
     |                                    echo 1234567890 > pippo
     |                                    exec 3<>pippo
     |                                    read -n 4 <&3             # Read only 4 characters.
     |                                    echo -n . >&3             # Write a decimal point there.
     |                                    exec 3>&-                 # Close fd 3.


     >|  force redirection: forcibly overwrite an existing file.
         When bash is called as
                          bash -C        (said 'noclobber')
         it means it prevents file overwrite.
         Still, even if called as bash -C, the >| will overwrite !!!



     -   redirection

         ex1.
         # move a tree of dirs  tar -p (preserves file permissions)
         (cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -)
         other ways:
             cp -a /source/directory/* /dest/directory
             #or to wok also with .hidden files:
             cp -a /source/directory/* /source/directory/.[^.]* /dest/directory

         ex2.
         #if tar has not builtin the bunzip2 option:
         bunzip2 -c linux-2.6.16.tar.bz2 | tar xvf -

         ex3. back up of files
         find . -mtime -1 -type f -print0 | xargs -0 tar rvf "$archive.tar"

                -mtime -1: mod in the last day
                -type f  : regular file
                -print0  : print filename ending with 'null char' instaed of '\n'
                           this can so be processed with the -0 opt f xargs
____________________________________________________________
read    /   readarray
____________________________________________________________

read  . a builtin.
      . it reads from <stdio>
  -u  . it reads from that file descriptor
      . it reads 1 line  at a time (so 2 read in a row, reads 2 lines, 3 reads 3 lines ....)

      . The line is loaded into any var specified ex    while read -r line;
        If more vars are specified in each of them are loaded the 'words' (token separated by the IFS)
        of the line (last var takes all the remaining)
               ex.1   while read -r w1 w2 w3;

               ex.2   OLD_IFS=$IFS
                      IFS=":" read -r col1 col2 col3 <<< "hello::world"          # col1=hello col2=  col3=world
                      IFS=$OLD_IFS


      . If no var is specified the line is loaded into the var $REPLY
        ex. while read -r; do line="$REPLY"; cd $line ...


  -a  . If a single var 'array' is passed (option -a)   ex. while read -r -a var;
        then all the 'words' are loaded as elements of the array
        while read -r -a var ;do echo ${var[1]} ${var[2]} ${var[0]}; done < cc.txt      # n.b ${var[1]} and not $var[1]



  -r  . -r raw input (disables the \ (so it is considered a normal char, not meant to escape next char or for line-continuation))
        IT MUST BE ALWAYS USED

  -d  . specify a line-delimiter different from \n to read 'lines'

  -n  . it reads max n chars (maybe less if delimiter (\n or -d) is found first)    read -n 209 var<cc.txt; echo "[$var]";
  -N  . it reads n chars (regardless if found delimiters)                           read -N 209 var<cc.txt; echo "[$var]";

  -p  . prompt (print a string before reading)  ex. read -p "give me a number: " -r num; echo $num;

  -t  . add a timer on waiting                  ex. read -t 5 -p "give me a number: " -r num; echo $num;


readarray   . it loads all the lines of a file into an array
              cat input.txt
                  1 2 3
                  4 5 6
                  7 8 9
              readarray var < input.txt
                 echo $var       # 1 2 3
                 echo ${var[0]}  # 1 2 3
                 echo ${var[1]}  # 4 5 6
                 echo "${var[@]}"  1 2 3
                                   4 5 6
                                   7 8 9
____________________________________________________________
VARIABLES
____________________________________________________________
     a=some_value   # SET var a to some_value     ($a is DEFINED and NOT NULL)
     a=             # SET var a but leave it NULL ($a is DEFINED but NULL)
     unset a        # delete a var                ($a is NOT DEFINED)
     $a        #the value. A better use is ${a}
     ${a}      to be used when var & strings must be concatenated:
                  my_id=${USER}-on-${HOSTNAME}   #stiv-on-stiv-GP60-2PE
                  PATH=${PATH}:/opt/bin
                  'hash' command shows the last used paths from PATH serach
                   so that subsequent calls are faster

     nb. I can run bash -u    to have ERRORS each time a var is UNDEFINED
         (a way to debug and clean the script)

   Bash var are normally UNTYPED (to TYPED them use declare),
   they are just text, even if in case the string is built by only digits
   bash understand they are 'numbers' and give sense to any related arithmetic operation.
   NOTE: that the 'integer' value of a sting is 0.
   NOTE: usually is 0 also the 'integer' value of UNSET o NOT_EXIXSTING (not declared) var

   Integer in older versions of Bash were signed long (32-bit) integers, [-2147483648  2147483647].
   As of version >= 2.05b, Bash supports 64-bit integers.

   Bash does not understand floating point arithmetic. It treats numbers containing
   a decimal point as strings.


     -------------- declare / readonly
     declare (builtin) allows to assign array or integer types to a var:

            . declare            with no args dump all ENV var (like 'set' alone)
            . declare -i         type INT.
                                   v1=12 v2=5
                                   r=v1*v2 && echo $r                 --> "v1*v2"  # WRONG
                                   declare -i r && r=v1*v2 && echo $r --> 60       # OK
            . declare -r         readonly (a CONST) cannot be 'unset'
            . declare -x         define + export  (like export a=...)
            . declare -a         define the var as an ARRAY
            . LOCAL              A declare in a function is implicitly also a 'local'
                                 (scope limited within the function)

     readonly (builtin)    like declare -r
                           readonly with no args or with -p, dumps all "declare -r"
                           ex:

                                declare -r BASHOPTS="checkwinsize:cmdhist:complete_fullquote:
                                                     expand_aliases:extglob:extquote:force_fignore:
                                                     histappend:interactive_comments:login_shell:
                                                     progcomp:promptvars:sourcepath"
                                declare -ir BASHPID
                                declare -r BASH_COMPLETION_COMPAT_DIR="/etc/bash_completion.d"
                                declare -ar BASH_REMATCH='()'
                                declare -ar BASH_VERSINFO='([0]="4" [1]="3" [2]="46" [3]="1"
                                                            [4]="release" [5]="x86_64-pc-linux-gnu")'
                                declare -ir EUID="1000"
                                declare -ir PPID="6843"
                                declare -r SHELLOPTS="braceexpand:emacs:hashall:histexpand:history:
                                                      interactive-comments:monitor"
                                declare -ir UID="1000"


     -------------- let
          let is intended to assign an INTEGER expression to a var.
          It can be summarised as:

               let int_var=expression

                 ex:

               a=2334                   # Integer.
               let "a += 1"             # a = 2335
               b=${a/23/BB}             # Substitute "BB" for "23". ---> b = 2BB5
               let "b += 1"             # b = 1    the integer value of 2BB5 is 0

     -------------- DEFAULT:

     ${a?err_msg}   if $a is not defined exits the script with the "err_msg"
     ${a=val}       if $a is not defined sets it to val
     ${a-val}       if $a is not defined uses HERE val  ($a is unchanged, (so undefined))

     ${a+val}       if $a IS defined uses HERE val


     the versions with ':' are "not defined OR NULL":

                                       ${a:?err_msg}
                                       ${a:=val}
                                       ${a:-val}
                                       ${a:+val}

           ex. a=1;  echo ${a-2}   #1
               a=;   echo ${a-2}   # nothing
               a=;   echo ${a:-2}  #2
                     echo ${b-2}   #2          b is undefined
                     echo ${b:-2}  #2

     -------------- ARRAY

      DECLARATION (& ASSIGNMENT)

          names=([2]=alice [0]=hatter [1]=duchess)
          names=(hatter duchess alice)
          names=(hatter [5]=duchess alice)   (assigning elem at index 0,5,6) <---------.
          declare -a names                                                             |
                                                                                       |
      REFERENCING                                                                      |
          echo ${names[5]}                                                             |
                                                                                       |
      *  @                                                                             |
          as for argv[]                                                                |
          *    returns all the elements as 1 word (with IFS separating the elements)   |
          @    returns many quoted words of each elem.                                 |
                                                                                       |
          ex:                                                                          |
             for i in "${names[@]}"; do                                                |
                                                                                       |
      UNASSIGNED elements                                                              |
          elem not assigned are NULL if considered as STRING.                          |
          The syntax                                                                   |
          ${!array[@]}    returns the LIST of the DEFINED indexs                       |
                          ex, here would be 0,5,6 -------------------------------------'

      LEN OF ELEMENTS / LEN OF ARRAY
          . ${#names[5]}    returns the LEN of the element [5] (ex if it is "duchess" --> 7)
          . ${#names[@]}    returns the LEN of the ARRAY
          . ${#names[*]}    returns the LEN of the ARRAY

      REMOVING ELEM
          . unset names[5]

    --------------

     ${#a}        # return len of char for value of a
                  # for an array only the len of 1st elem
                  ex. a=12345ab;    echo ${#a}        #7
                      a=(e1 e2 e3); echo ${#a}        #2

                  ${#array[*]}    both give the number of elements in the array.
                  ${#array[@]}

                      a=(e1 e2 e3); echo ${#a[*]}        #3
                      a=(e1 e2 e3); echo ${#a[@]}        #3

Numbers are usually decimal (base 10).
Prefix 0      is octal (base 8).                   let "oct = 032"   # 26
Prefix 0x     is hexadecimal (base 16).            let "hex = 0x32"  # 50
BASE#NUMBER   is any base
              # range (2 - 64) : 10 digits + 26 lowercase characters
                                           + 26 uppercase characters + @ + _

              let "b64 = 64#@_"      # 4031


              #  Using a digit out of range gives error .

              let "bad_oct = 081"
              # (Partial) error message output:
              #  bad_oct = 081: value too great for base (error token is "081")

              exit $?   # Exit value = 1 (error)



INDIRECT REFERENCES
b=${!var}  the new construct ${!var} replace the old less readable eval var1=\$$var2
and return the value of the variable whose name is the value of var
e.g.
                    t=table_cell_3       # var t conatins that string text
                    table_cell_3=24      #
                    echo "t = ${!t}"     # t = 24  that is the value of the variable
                                                   named by t value

____________________________________________________________
ENV VARIABLES
____________________________________________________________

As any unix process, the shell has an "environment", a group of variables
that the process may reference.
Even if the env-space is limited, you can add ("export") environmental variables.
Those var are accessible
only to child processes. A script invoked from the command-line
cannot export variables back to the command-line,
like Child cannot export variables back to the parent.

                W R O N G                  R I G H T

               MYVAR="hello"           MYVAR="hello"
               echo $MYVAR             echo $MYVAR;  export MYVAR
               hello                   hello
               bash                    bash
               echo $MYVAR             echo $MYVAR
                                       hello

  export    # write this cmd alone to have ALL the env vars (or also export -p)
  env       # the same (with a different output)
  printenv  # the same (with a different output)

To see ALL the bash var (not only the env) use:

    (set -o posix; set)        through this output it's possible to
                               distinguish BASH and C-SHELL, because
                               the C-SHELL puts spaces in var = value
                                                             ^ ^

____________________________________________________________
POSITIONAL PARAMETERS
____________________________________________________________

Arguments passed to the script:  $0, $1, $2, $3 . . .

    $0 : the name of the script itself,
    $1 : the first argument, ...  after $9, must be enclosed in brackets, ${10}, ${11}, ${12}.
         not any shell understands ${10} so in that case remains with 1 digit & use 'shift'
         (see below)
    $# : the NUMBER of passed parameters
    $* : the string with ALL the positional parameters, (seen as a single word)
    $@ : the same of $* but each parameter is a quoted (each parameter is seen as a separate word).
         the separation is 1st char in IFS (99% is a space, anyhow it's on IFS)

         As the difference between S* and $@ is that the second quotes the words (between IFS)
         the difference arises when quoting them (ex using "$*"  "$@")
         the first produces 1 single word, the second many.
         ex. suppose I have a function xxx that receives some args,
             and then forwards all of them to another function zzz:
                         zzz  "${@}"    <--- OK        in zzz are defined $1 $2 $3 ...
                         zzz  "${*}"    <--- NOT OK    in zzz is defined only a BIG S1
             N.B. If I want to forward only some skipping the first X (ex. 2)
                  I'll do
                         zzz "${@:2}"      # or more generally    zzz "${@:$X}"

  ex.
   args=$#               # Number of args passed.
   lastarg=${!args}      # Note: This is an *indirect reference*

The shift command reassigns the parameters :

$1 <--- $2 $2 <--- $3                    old $1 disappears. $0 never change.
ex.
                until [ -z "$1" ]
                do
                  echo -n "$1 "
                  shift
                done

shift can take a numerical parameter indicating how many positions to shift. (ex. shift 3)

     To go through an array $a is
     for i in $a
     do ...
     done

     the simple:
                    for i            (omitting 'in $a')
                    do  ...          means I'm cycling through the args of the script
                    done

set       the set fun. allows to overwrite what was the args to the script.
          ex. a="1 2 3 4 5"; set $a         will set $1=1 $2=2 ....
          nb.  the better way when setting through a variable (like here $a) instead
               a normal text, is with '--'
               set -- $a

          the most used form is however with the (command substitution) form
          set `.... cmd .....`   (ex.  set `uname -a`)

          set           (alone, with neither args or options)
                        list the env vars

getopts   is a builtin, used to manage options and their args
          It only works with LETTERS not for LONG-name options (for that there is
          a command (not builtin) getopt(1))
          The syntax is   getops ":ab:c..."  xxx <---  var used (normally in a while)
                                   ^
                                   the list of option letters.
                                   If an option is followed by an arg ex (-f filename)
                                   there must be a ':' after (f:)
                                   A starting ':'  (:ab ...)  suppresses ERROR msg
                                   in case a option is unknown
                                   $OPTARG is the name of var that stores the arg
                                   (ex filename in -f filename)
                                   $OPTIND is the number of the argv[] to process
                                   after getops finished.
                                       cmd -ab xxx    $OPTIND=3
                                       cmd -a -b xxx  $OPTIND=4
                                   So normally there is a shift $(($OPTIND - 1))

          getops is normally to be used inside a while:

          | while getopts ":ab:c" opt; do
          |     case $opt in
          |         a ) process option -a
          |         ;;
          |         b ) process option -b
          |             $OPTARG is the option's argument
          |         ;;
          |         c ) process option -c
          |         ;;
          |         \? ) echo 'usage: $0 [-a] [-b barg] [-c] args.
          |         exit 1
          |         esac
          | done
          | shift $(($OPTIND - 1))

____________________________________________________________
EXIT STATUS
____________________________________________________________
     Every command returns an exit status. On success = 0.  On errors = 1-255
     $? reads the exit status.
     When a script ends with exit with no parameter:
            exit
     the exit status will be the one of the last command in the script.

     Reserved values:
          1	general errors	(such as "divide by zero": let "var1 = 1/0")
          2	Misuse of shell builtins (ex. Missing keyword or permission problem
                                     (diff failed on binary file comparison)).
          126	Permission problem or command not an exe(ex. invoke /dev/null)
          127	"command not found"	(ex.Possible problem with $PATH or a typo)
          128	Invalid argument to exit (exit with value out of 0-255)
          128+n	reserved for signals values (ex. kill -9 $PPID of script  $? returns 137 (128 + 9))
          130	Script terminated by Control-C	(N.B. signal 2, (130 = 128 + 2)

     Book Author suggest to use values in range: 64 - 113

     Take care on exit values. If the value seems odd, probably it is.
     Values X > 255 become (X mod 256) on exit
     ex:
        exit 300 --> echo $? : 44

 _______________________
 _______ IF ELIF ELSE FI

        . if ......  <---- it checks the EXIT-STATUS of LAST cmd in a list (0 = TRUE)
                           So it is different from many languages


          if ...                                      if ....; then <--- on a single line with ;
          then     <--- on a new line without ;
          fi


          if  cmd1 && cmd2           in case cmd1 has EXIT-STATUS=0 --> exec cmd2
                                     and in case its EXIT STAUS=0 then do ...


          if  cmd1 || cmd2           in case cmd1 fails, run cmd2



 _______________________
 _______ test and [ ]

         said that if ONLY CHECKs EXIT STATUSES, a syntax improvement
         is done by 'test' builtin:

              test xxx                  (or alias [ xxx ]  <-- spaces required)
              test string1 = string2    (or alias [ string1 = string2 ])

         they just transform the included BOOLEAN xxx CONDITION into an EXIT STATUS
         ex.
             > [ "" ]       echo $?   -->  1
             > [ " " ]      echo $?   -->  0


         if test condition1       # using a form with the 'test' keyword
         if [ condition1 ]        # usign a form with [ alias for test keyword
         if [[ condition1 ]]      # usign the better [[ ]] than []
         if condition1            # allow to use nothing
         if (( ))                 # when evaluates arithmetic expression. N.B. (( )) and 'let'
                                   works on arithmetic. If expression gives 0, its exit status = 1 --> FALSE.
                                   This is in marked contrast to using the test and [ ]
         then
            command1
            command2
            command3
         elif [ condition2 ]    # Same as else if
         then
            command4
            command5
         else
            default-command
         fi


         ____________________________________________________________
         EXAMPLES
         ____________________________________________________________

         Following an if, neither the test nor the brackets [ ]  [[ ]] are strictly necessary.

         if [ 0 ]
         then         # 0 is true.
         ......
         if [ 1 ]
         then          # 1 is true.
         ......
         if [ -1 ]
         then          # -1 is true.
         ......
         if [ ]        # NULL (empty condition)
         then
         else          # NULL is false.
         ......
         xyz=          # Initialized, but set to null value.
         if [ -n "$xyz" ]
         then
         else          # Null variable is false
         ......
         if [ xyz ]    # string
         then          # Random string is true.
         ......
         if [ $xyz ]   # $xyz an uninitialized variable.
         then
         else          # Uninitialized variable is false.
         ......
         if cmp a b &> /dev/null
         then echo "Files a and b are identical."
         ......
         if grep -q Bash file
           then echo "File contains at least one occurrence of Bash."
         ____________________________________________________________

         ____________________________________________________________
         TEST ON INTEGER
         ____________________________________________________________

         -eq     is equal to                        if [ "$a" -eq "$b" ]
         -ne     is not equal to                    if [ "$a" -ne "$b" ]
         -gt     is greater than                    if [ "$a" -gt "$b" ]
         -ge     is greater than or equal to        if [ "$a" -ge "$b" ]
         -lt     is less than                       if [ "$a" -lt "$b" ]
         -le     is less than or equal to           if [ "$a" -le "$b" ]
         <       is less than                (within double parentheses)       (("$a" < "$b"))
         <=      is less than or equal to    (within double parentheses)       (("$a" <= "$b"))
         >       is greater than             (within double parentheses)       (("$a" > "$b"))
         >=      is greater than or equal to (within double parentheses)       (("$a" >= "$b"))

         ____________________________________________________________
         TEST ON STRING
         ____________________________________________________________

         Using an unquoted string normally works, however, this is an unsafe practice.
         Always quote a string.

         =       is equal to       if [ "$a" = "$b" ]
                                   Note the whitespace    if [ "$a"="$b" ] is not equivalent
         ==      is equal to       if [ "$a" == "$b" ]   This is a synonym for =.
                                   The == behaves differently within [[]] []

                                       [[ $a == z* ]]   # True if $a starts with a "z" (pattern matching).
                                       [[ $a == "z*" ]] # True if $a is equal to z*    (literal matching).

                                       [ $a == z* ]     # File globbing and word splitting take place.
                                       [ "$a" == "z*" ] # True if $a is equal to z* (literal matching).

         !=      is not equal to   if [ "$a" != "$b" ]
                 This operator uses pattern matching within a [[ ... ]] construct.
         <       is less than, in ASCII alphabetical order
                  if [[ "$a" < "$b" ]]
                  if [ "$a" \< "$b" ]            Note that the "<" needs to be escaped within a [ ]
         >       is greater than, in ASCII alphabetical order
                  if [[ "$a" > "$b" ]]
                  if [ "$a" \> "$b" ]
         -z      string is null, (zero length)

                       String=''   # Zero-length ("null") string variable.

                       if [ -z "$String" ]
                       then
                         echo "\$String is null."
                       else
                         echo "\$String is NOT null."
                       fi     # $String is null.

         -n      string is not null.

         ____________________________________________________________
         TEST ON FILES
         ____________________________________________________________

         file=/etc/passwd

         if [[ -e $file ]]
         then
           echo "Password file exists."
         fi

         -e            file exists
         -a            file exists (like -e. "deprecated" and its use discouraged).
         -f            file is a regular file (not a directory or device file)
         -s            file is not zero size
         -d            file is a directory
         -b            file is a block device
         -c            file is a character device
         -p            file is a pipe
         -h            file is a symbolic link
         -L            file is a symbolic link
         -S            file is a socket
         -t            file (descriptor) is associated with a terminal device
                       This test option may be used to check whether the stdin [ -t 0 ]
                       or stdout [ -t 1 ] in a given script is a terminal.
         -r            file has read permission    (for the user running the test)
         -w            file has write permission   (for the user running the test)
         -x            file has execute permission (for the user running the test)
         -g            set-group-id (sgid) flag set on file or directory
                       If a directory has the sgid flag set, then a file created within that directory
                       belongs to the group that owns the directory,
                       not necessarily to the group of the user who created the file.
         -u            set-user-id (suid) flag set on file    (an s in its permissions)
                       An executable owned by root with set-user-id flag set runs with
                       root privileges, even when an ordinary user invokes it.
                       This is useful for executables (such as pppd and cdrecord)
                       that need to access system hardware.
                       Lacking the suid flag, these binaries could not be invoked by a non-root user.
         	           -rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd

         -k            sticky bit set  (a t in its permissions)
                       the save-text-mode flag permission.
                          If set on a file: that file will be kept in cache memory, for quicker access.
                          If set on a directory: restricts write permission.
                          Olny the owner of a file can alter or delete files in that directory.
         	           drwxrwxrwt    7 root         1024 May 19 21:26 tmp/
                       On Linux systems, the sticky bit is no longer used for files, only on directories.
         -O            you are owner of file
         -G            group-id of file same as yours
         -N            file modified since it was last read

         f1 -nt f2     file f1 is newer than f2
         f1 -ot f2     file f1 is older than f2
         f1 -ef f2     files f1 and f2 are hard links to the same file


         _______ [[ ]]

                 The [[ ]] construct is the more versatile Bash version of [ ].
                 This is the extended test command, adopted from ksh88.
                 No filename expansion or word splitting takes place between [[ ]],
                 but there is parameter expansion and command substitution.
                 Using [[ ]] rather than [ ] can prevent many logic errors.
                 For example, && || < and > work in [[ ]] despite giving error in [ ]
                 Arithmetic evaluation of octal / hexadecimal constants takes place automatically in [[  ]]

         ____________________________________________________________
         TEST WITH   AND  OR   -a  -o    &&  ||
         ____________________________________________________________

         Tests conditions can be chained with boolena opertors NOT (!)   AND   OR
         Remeber once again that what Bash uses for each test condition is its EXIT STATUS


         -a      logical and          exp1 -a exp2 returns true if both  are true.
         -o      logical or           exp1 -o exp2 returns true if either is true.

         The -o and -a work with test command or within []

         It can also be used the form &&   ||
         && and || work also within [[ ]]       [[ condition1 && condition2 ]]

         if [ "$expr1" -a "$expr2" ]
         then
           echo "Both expr1 and expr2 are true."
         else
           echo "Either expr1 or expr2 is false."
         fi

              &&   (AND logical operator).
                    returns 0 (success) only if both conditions are true.

              a=$(( 0 && 1 )) ; echo $a     # 0
              (( 0 && 1 )) ;    echo $?     # 1


         Caution	:

         [ 1 -eq 1 ] && [ -n "`echo true 1>&2`" ]   # true
         [ 1 -eq 2 ] && [ -n "`echo true 1>&2`" ]   # (no output)
         # ^^^^^^^ False condition. So far, everything as expected.

         # However ...
         [ 1 -eq 2 -a -n "`echo true 1>&2`" ]       # true
         # ^^^^^^^ False condition. So, why "true" output?

         # Is it because both condition clauses within brackets evaluate?
         [[ 1 -eq 2 && -n "`echo true 1>&2`" ]]     # (no output)
         # No, that's not it.

         # Apparently && and || "short-circuit" while -a and -o do not.

 _______________________
 _______ FOR

     FOR can be in 2 forms:

           . for x in LIST
           . for (( i=1; i <= 12 ; i++ ))

       Only the second is like C,
       the 1st, is with a FIXED list

         for x [ in list ]     <--- if list is missing is used "$@"  (script args)
         do ...                     ex:    for i
         done                              do
                                                echo $i
                                           done


                            ex.  for dir in $PATH


         for F in $(ls)
          do [ ! -f $F ] && continue     <--------- if NOT (!) a file, 'continue'  (exist also 'break', like C)
            DT=$(stat $F | grep -i access | tail -1 | cut -d " " -f2)
            echo "$F accessed at $DT"
          done

         look also at this:
         for U in $(lastlog | grep -vi never | awk '{print $1}' )



 _______________________
 _______ WHILE / UNTIL

     ------------ WHILE
        COUNT=10
        while (( COUNT > 0 ))    <-----  not $COUNT (is not required $)  /   exist also "while true" for endless loop
           do
               (( COUNT -- ))    <----- nb. usage of -- and ++
           done
     ------------ UNTL
        until (( SZ < 100 ))
           do
              ..
           done




 _______________________
 _______ CASE

           case expr    in
                pattern)    cmds ;;
           esac        ^_________^____________ NB. ) and ;;



                                     pattern:
                                              . can be any usual regex [] * ?
                                                (even piped:  ex 0 | 1)
                                              . default is *




     ------------  IF                                    case $1 in
     if [[ $1 = "directory" ]]                              "directory")
     then                                                     ..
         find / maxdepth 1 -type d                          ;;
     elif [[ $1 = "file" ]]                                 "file")
     then                                                     ..
         find / maxdepth 1 -type f                          ;;
     elif [[ $1 = "link" ]]                                 "link")
     then                                                     ..
         find / maxdepth 1 -type l                          ;;
     else                                                   *)
        echo "usage: $0 file | directory | link"              ..
     fi                                                     ;;
                                                         esac

                                                         case $V in
                                                         [1-6]* | ?)
                                                            MSG="<10"
                                                            ;;
                                                         [7-8]?)
                                                            MSG="<89"
                                                            ;;
                                                         9[0-9])
                                                            MSG="<99"
                                                            ;;
                                                        *)
                                                            MSG=">=100"

 _______________________
 _______ SELECT

                         to write simple menus

                         Has the SAME-EXACT syntax of FOR  (included the meaning "$@" for a missing list)
                         The static list is displayed like a menu in the form

                                1) aaa       <-- aaa is the first iem of the list
                                2) bbb
                                3) ccc
                                ....


____________________________________________________________

(( 0 ))                   # $? = 1
(( 1 ))                   # $? = 0
(( 5 > 4 ))               # true # $? = 0
(( 5 > 9 ))               # false # $? = 1
(( 5 - 5 ))               # 0 # $? = 1
(( 5 / 4 ))               # Division o.k.  # $? = 0
(( 1 / 2 ))               # Division result < 1  # Rounded off to 0.  # $? = 1
(( 1 / 0 )) 2>/dev/null   # Illegal division by 0.  # $? = 1

____________________________________________________________
STRING  OPERATORS
____________________________________________________________

'#' for len:
       ex.   filename=alice.c  --> ${#filename} = 7

patter matched is REMOVED from var, and the rest RETURNED:

       ${var ## pattern}   longest  match from beginning
       ${var #  pattern}   shortest match from beginning
       ${var %  pattern}       "    match from end
       ${var %% pattern}   longest  match from end

suppose $path    =  /home/cam/book/long.file.name

       ${path##/*/}   long.file.name
       ${path#/*/}    cam/book/long.file.name
       ${path%.*}     /home/cam/book/long.file
       ${path%%.*}    /home/cam/book/long

substitution
       ${var/  pattern/ string}  logest match replaced by string
       ${var// pattern/ string}  1st     "      "      "     "
                                 pattern startw with:
                                   #  match from beginning
                                   %  match from end
          ex. echo -e ${PATH//:/'\n'}

          var=abcABC123ABCabc
          echo ${var/#abc/XYZ}          # XYZABC123ABCabc
          echo ${var/%abc/XYZ}          # abcABC123ABCXYZ

____________________________________________________________
INT  OPERATORS
____________________________________________________________

+    plus
-    minus
*    multiplication
/    division
**   exponential # introduced from Bash version 2.02    let "z=5**3"    # z = 125
%    modulo        bash$ expr 5 % 3  #2
+=
-=
*=
/=
%=

NB: the syntax  2#11101   (so BASE#NUMBER, with base any 2-36)
    can define number using any base:
    declare -i r=2#11101   echo $r   --> 29
____________________________________________________________
BLOCK STATEMENTS
____________________________________________________________

           if ....       while :    until ...    for a in [list]
           then :        do         do           do
           else            ...        ...         ...
           elif          done       done         done
           fi:


____________________________________________________________
IFS
____________________________________________________________

  Stays for 'Internal Field Seperator'
  and it's the LIST of characters that when found terminates a WORD
____________________________________________________________
MAIL
____________________________________________________________

  $MAIL       = ENV var, path of my mailbos
  $MAILCHECK  = num of sec, mailbox is checked for mails
                (ex. 600 : 10 min,
                       0 : at each prompt)

____________________________________________________________
TO MANIPULATE TXT FILES
____________________________________________________________

   cat                            (the opposite is tac print from last line up to the 1st)
       -s    group + more blank lines in only 1
       -n    print line nume
       -v    show-nonprinting
       -E    print $  at end of lines
       -T    print ^I for tabs
       -A    equivalent to -vET

   cut     cut vertical slice identified as
        -f2     print 2nd field (fields are separated by tab
                                 to use a different separator use -d
                ex cut -d: -f1 /etc/passwd
        -c  only these columns
                ex cut -b "1 2 3 4"   /etc/passwd

   join     with 2 files f1 f2 which have the same values in each line
            (like the same key) join produce a file where each line is
            obtained from the line of f1 and f2 (appended)
             with the same value for the key

   paste    like join but work on line without any key
            so 1 outpute line is line f1 + append line f2

   expand     tab into spaces (default 8)        (the opposite is unexpand -a -t)
        -t4   to define another values instead of 8
        -i    only first tab on a line

   split    creates more files each containing n lines
        -n  num of lines (default 1000)

   tr  s1 s2     changes string s1 with corresponding char fo s2 (s1 len = s2  len)
            It doesn't operate on files, and it's usually chained in a pipe
            So s1, comes from the pipe.

        -c  complement (all the char different from s2)
        -d  deletes the char indicated in s2
        -s  compress to 1 any sequance of more chars

         $ cat file1 | tr a-z A-Z               convert to UPPERCASE
         $ cat file1 | tr -s '[:blank:]'        more spaces are zipped into 1
         $ cat file1 | tr -dc '[:print:]\n'     delete all non printing char (preserve only \n)
____________________________________________________________
OPERATE ON FILES
____________________________________________________________

   bzip2
        -d   decompress
        -1 .. -9  100k ... 900k (block size)
                  -1 fast (larger size)

   cpio     creates archives .cpio (with no compression)
            It uses -o with > to create the archive

               cpio < [filenames ...] > [archive]
               ls | cpio –ov > /tmp/archive.cpio

            It uses -i with < to extract the archive
               cpio –i < [archive]
               cpio –iv < /tmp/archive.cpio

   dd
        one of the few cmd that operates on disk without filesystem
        copy files
        -if=file
        -ibs=n    block size to read if
        -of=file
        -obs=m    block size to write of
        -conv=list   perform the conversion specified in 'list'

        dd if=/tmp/file of=/tmp/file2 conv=lcase

   tee
        write both on stndio and in a file specified
        so that in a pipe:

        cmd1 | cmd2 | cmd3 > file1

        I can intercept some output and store in a file

        cmd1 | tee file_cmd1 | cmd2 | cmd3 > file1

        The output of cmd1 still travels through the pipe, but
        it's also saved in file_cmd1

____________________________________________________________
JOB & PROCESSES
____________________________________________________________

     find . -iname xxx &        --> [1] 104
                       ^             ^   ^
                       |         job-id  proc-id
                   background

   proc-id: is the number that identifies each proc running in the OS
            regardless in which shell was executed
   job-id   is a number assigned by the current shell to a command
            executed in background (starts from 1)
            Any other cmd executed before [1] is finished
            will receive job-id [2] [3] ...



   'jobs'   to list all jobs
            -l    long list (with proc-ids)
            -p    ONLY proc-ids

   the    | fg           moves in foreground the LAST proc pushed in background &
   same   | fg %find     to call a job by name (use %name) if there are 2 names (ex 2 'find')
   for    |                                                will be taken the last submitted
   'bg'   | fg %2                      by job-id
 -------->| fg 104                     by proc-id
   after  | fg %?xxx                   by the string xxx matched somewhere in the rest of command line
   a      | fg %+                      the last  (the same as fg)
   CTRL-Z | fg %-                      the last-1 (proc before the last)


--------------- signals & kill
kill -x PID       send signal -x to proces with that PID    (-x  can be the number (ex 2) or the name (ex SIGINT))
kill -l           to have the list of signal names:
kill    PID       kill with no signal is by default 2 SIGINT (CTRL-C)

     1) SIGHUP         2) SIGINT         3) SIGQUIT         4) SIGILL         5) SIGTRAP
     6) SIGABRT        7) SIGBUS         8) SIGFPE          9) SIGKILL       10) SIGUSR1
    11) SIGSEGV       12) SIGUSR2       13) SIGPIPE        14) SIGALRM       15) SIGTERM
    16) SIGSTKFLT     17) SIGCHLD       18) SIGCONT        19) SIGSTOP       20) SIGTSTP
    21) SIGTTIN       22) SIGTTOU       23) SIGURG         24) SIGXCPU       25) SIGXFSZ
    26) SIGVTALRM     27) SIGPROF       28) SIGWINCH       29) SIGIO         30) SIGPWR
    31) SIGSYS        34) SIGRTMIN      35) SIGRTMIN+1     36) SIGRTMIN+2    37) SIGRTMIN+3
    38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6     41) SIGRTMIN+7    42) SIGRTMIN+8
    43) SIGRTMIN+9    44) SIGRTMIN+10   45) SIGRTMIN+11    46) SIGRTMIN+12   47) SIGRTMIN+13
    48) SIGRTMIN+14   49) SIGRTMIN+15   50) SIGRTMAX-14    51) SIGRTMAX-13   52) SIGRTMAX-12
    53) SIGRTMAX-11   54) SIGRTMAX-10   55) SIGRTMAX-9     56) SIGRTMAX-8    57) SIGRTMAX-7
    58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4     61) SIGRTMAX-3    62) SIGRTMAX-2
    63) SIGRTMAX-1    64) SIGRTMAX

kill -l 15    returns 'TERM' from its number, the signal name (without SIG).

       SIGHUP     1          Hangup
       SIGINT     2          Interrupt from keyboard   CTRL-C
       SIGKILL    9          Kill signal
       SIGTERM    15         Termination signal
       SIGSTOP    17,19,23   Stop the process          CTRL-Z


      TERM (15)  should be the 1st try as proc can execute its 'clean' code if it has any
      INT  (2)   CTRL-C    2nd try
      KILL (9)             last try


killall         like kill but can kill all instances of a proc with a given 'name'
pkill, pgrep    advanced feature:  can kill processes from other than your own user ID and
                                   specifying processes by name


SIGHUP  (1)   when a shell receives SIGHUP it exits
              (to exit shell with PID 3456:    kill -1 3456)

A SHELL that exits (for having received SIGHUP or for other reasons), sends SIGHUP to all
its jobs (whichever state, running or suspended)
This feature (huponexit) can be 'on' or 'off'  (see below)
--------------------------------------------------- shopt
shopt        shows the option settings of the shell

autocd                  off
cdable_vars             off
cdspell                 off
checkhash               off
checkjobs               off
checkwinsize            off
cmdhist                 on
compat31                off
compat32                off
compat40                off
compat41                off
compat42                off
complete_fullquote      on
direxpand               off
dirspell                off
dotglob                 off
execfail                off
expand_aliases          off
extdebug                off
extglob                 off
extquote                on
failglob                off
force_fignore           on
globstar                off
globasciiranges         off
gnu_errfmt              off
histappend              off
histreedit              off
histverify              off
hostcomplete            on
huponexit               off  <--------------
interactive_comments    on
lastpipe                off
lithist                 off
login_shell             off
mailwarn                off
no_empty_cmd_completion off
nocaseglob              off
nocasematch             off
nullglob                off
progcomp                on
promptvars              on
restricted_shell        off
shift_verbose           off
sourcepath              on
xpg_echo                off

--------------------------------------------------- trap
trap intercepts the signals. The syntax is:
     trap '.....; .....; .....'     SIG1 SIG2 SIG3



so trap + some commands + the signals trapped, which can be as usual:
                - the numbers   (ex 15)
                - the name (without SIG)
                - the special value 0 or EXIT, which means when that script ends
                - the special value DEBUG (the commands inside the trap '....' are executed on each cmd')
                  moreover variables defined with the more specific syntax:
                                declare -t VAR=val
                  instead of the normal
                                           VAR=val
                  will be logged or 'traced' (t)
                - the special value ERR (the commands inside the trap '....' are executed on each exit != 0)
                  (in some cases, inside if, while, ... this is not always true, so check to be sure)
ex1.
     trap "echo Booh!" INT TERM
ex2.
     FILE=/tmp/$(basename $0).pid
     trap 'rm $FILE' EXIT
     trap 'echo "receiving SIG to stop";  exit 3'  15  <----- if a kill -15 is sent to this script,
     if [ -e $FILE ]                                          it will sent itself an exit 3,
     then                                                     which will be trapped, above,
            echo "cannot run if file is present"              so the file is removed
            exit 2
     fi
     echo $$ > $FILE
     sleep 10
     exit 0


____________________________________________________________
TO MANIPULATE PROC
____________________________________________________________

  both ps and top allow to see the column PRI (the priority)
  to use for nice and renice


   ps
       -f  to see also the args passed to a cmd  (anoher way strings -1 /proc/$pid/cmdline)
       -x  to see also daemons

   pstree     show the tree of proc (parent / childs)
       -a  show args of each proc
       -p  include PID in the output
       -n  sort by PID (instead alphabetically)

   top     uses var $TERM  (if this var is not set top not works)
       -d  delays between screen refresh
       -n  display n refresh then exit (do not go forevere)
       -i  ignore idle proc  (they do not use sys resources)
       -b  batch (useful with -n, to pass the output in a file)

       k  kill the process (I must specify PID)
       q  quit
       r  renice the proc (change priority)
       s  change delays

       top –bi -n 5 -d 1 > file1

   free      show the RAM usage
       -m, -g, -h to see in Mega, Giga, human readable

   uptime  info on how long sys is running / logged users /
       average of blocked proc (waiting for resouces) (average on last 1,5,15 min)
       A system relatively busy (web server) presents something as:

       1:20pm up 3 days 15:49, 1 user, load average: 1.47, 1.10, 0.83

       high value there means there is a problem to investigate

   kill
       signals     (to see the names run kill -l 2   -->  INT)

                 2  INT   stop  (sent with ^C)
                15  TERM  stop nicely
                 9  KILL  stop badly
                20  TSTP  suspend (sent with ^Z)
                18  CONT  resume  (sent with fg, bg)
                 1  HUP   used by many daemon to reread conf file
                          kill -HUP `cat /var/run/httpd.pid`

                          if you want to run a cmd that will never respond to HUP
                          run as
                          nohup [options] [command] [args...]

   jobs  show proc (indication if they are active or zombie)
       -l  list also PID

   nice   a proc is nice with respect to the other procs if it decreases its priority
          Thus the term nice to indicate with positive num (more niceness) I want
          less priority. Negative num, increment the priority (only superuser can do)

          nice -n val cmd     val -20 +19  (each proc start with 0. default value is 10)
          nice -val   cmd     -n can be omitted and give only the value with a -

              nice -n -10 vi /etc/hosts.deny
              nice --10 vi /etc/hosts.deny    nb. -- (1st to not have -n, 2nd is the minus)

          nice is used only when the cmd is launched. When a proc is already running
          the cmd is 'renice'.
              renice [+-]n -p PID / -u user   (I can renice a single PID
                                               or any proc of user)

____________________________________________________________
GREP / SED
____________________________________________________________

   grep -E   or egrep    (GNU extensions of grep)
                          grep            egrep
                          \?                ?
                          \+                +
                          \{n,m}           {n,m}
                          \|                |
                          \(regex\)        (regex)   to catch vars \1 .. \9

   sed
       -e  'cmd'                      sed '3,5d' file
       -f  file_with_sed_cmds         sed '1~2d' file      n~m  is a GNU extension for addressing lines
                                                                it means start at line n and go at step m
       s/pat/replace/[flags]                                    so 1~2 are any odd lines
                        ^
                        g       all inst not just the 1st
                        n       only inst nth  (default 1)
                        p       print
                        w file  save to file
                        y       translate (similar tr)


      nb. cmds are executed 1 AFTER the other (so operates on output of previous)
          if I write a script like
          1,10{                   to replace 3th and 4th " in first 10 lines with ( and )
          s/"/(/3                 it wouldn't work as expected, as
          s/"/)/4                 once the 3th " has been changed to (
          }                       what was the 4th " is now the 3th!!!

____________________________________________________________
TO MANIPULATE TXT FILES
____________________________________________________________
____________________________________________________________
TO MANIPULATE TXT FILES
____________________________________________________________
____________________________________________________________
TO MANIPULATE TXT FILES
____________________________________________________________
____________________________________________________________
TO MANIPULATE TXT FILES
____________________________________________________________
____________________________________________________________
TO MANIPULATE TXT FILES
____________________________________________________________














