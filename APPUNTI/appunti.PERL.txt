                          PERL CORE is context (ctx) SCALAR or LIST

         _____________________________________________________________________________
        |   ()  <-- $          SCALAR in LIST   ctx:        LIST of 1                 |
        |                                                                             |
        |    $  <-- @          ARRAY  in SCALAR ctx:        LEN                       |
        |    $  <-- %          HASH   in SCALAR ctx:        used/avail buckets        |
        |    $  <-- ()         LIST   in SCALAR ctx:        LAST elem                 |
        |                                                                             |
        |          **EMPTY** LIST()/HASH%/ARRAY@ GIVES SCALAR 0   $x = ()  <-- x:0    |
        |                                                                             |
        |    $  <-- ()=()      LIST-ASSIGN in SCALAR ctx: num of ASSIGNs              |
        |                      @a=(1,2,3);                                            |
        |                        '---------> $s= ($x,$w,$y,$k,$j)=@a   s:3            |
        |_____________________________________________________________________________|

         _____________________________________________________________________________
        |  AUTOVIVIFICATION:     .......... =      <--- whatever on the LEFT          |
        |                                               is always first CREATED       |
        |                                               if undefined/missing          |
        |_____________________________________________________________________________|



PERL SPECIAL VARs
     Most of the special vars have an english long name (ex, $! =  $OS_ERROR)
     Remember to add a line "use English;"

_____________ SCALAR

     LONG NAME

$_     $ARG                            The default
                                                  - input (the line read from a file)
                                                  - pattern-searching space.
                                                  - built-in iterator used instead of normal $i in a for / foreach ...
                                       In other words, if you read from a file at the top of a
                                       while, for or foreach
                                       $_ is set up for you.
                                       Then any regular expression matches, chops (and lcs and many more)
                                       without a parameter, and even 'print' assume you want to work on $_. Thus:
                                       it can be omitted:

                                           while ($line = <FH>) {          while (<FH>) {
                                             if ($line =~ /Perl/) {          /Perl/ and
                                                 print FHO $line;                print FHO ;
                                             }                               print uc;
                                             print uc $line;               }
                                           }

                                          ex1        print foreach @array;
                                          ex2        foreach ( @array ) { next unless defined; }
                                          ex3        --b{(/(\w+)/)[0]}  <----  1. \w+ : returns the first word matched in $_
                                                                               2. (..)  it's managed in a list context
                                                                               3. [0]   it's the 1st (and only) el of the list
                                                                               4. b{..} it's the key to enter hash b
                                                                               5. --    that hash entry is decremented


$.     $NR                             The current input line num of the last filehandle that was read.
                                       An explicit close on the filehandle resets the line number.
$/     $RS                             The input record separator; newline by default.
                                       If set to the null string, it treats blank lines as delimiters.
$,     $OFS                            The output field separator for the print operator.
$\     $ORS                            The output record separator for the print operator.
$"     $LIST_SEPARATOR                 Like "$," except that it applies to list values interpolated into
                                       a double-quoted string (or similar interpreted string).
                                       Default is a space: $a = join( $", @ARGV );   .
$;    $SUBSCRIPT_SEPARATOR             The subscript separator for multidimensional array emulation. Default is "\034".
$^L   $FORMAT_FORMFEED                 What a format outputs to perform a formfeed. Default is "\f".
$:    $FORMAT_LINE_BREAK_CHARACTERS    The current set of characters after which a string may be broken
                                       to fill continuation fields (starting with ^) in a format. Default is "\n"".
$^A   $ACCUMULATOR                     The current value of the write accumulator for format lines.
$#    $OFMT                            Contains the output format for printed numbers (deprecated).
$?    $CHILD_ERROR                     The status returned by the last pipe close, backtick (``) command, or system operator.
$!    $OS_ERROR or $ERRNO              If used in a numeric context, yields the current value of the errno variable,
                                       identifying the last system call error.
                                       If used in a string context, yields the corresponding system error string.
$@    $EVAL_ERROR                      The Perl syntax error message from the last eval command.
$$    $PROCESS_ID or $PID              The pid of the Perl process running this script.
$<    $REAL_USER_ID or $UID            The real user ID (uid) of this process.
$>    $EFFECTIVE_USER_ID or $EUID      The effective user ID of this process.
$(    $REAL_GROUP_ID or $GID           The real group ID (gid) of this process.
$)    $EFFECTIVE_GROUP_ID or $EGID     The effective gid of this process.
$0    $PROGRAM_NAME                    Contains the name of the file containing the Perl script being executed.
$[                                     The index of the first element in an array and
                                       of the first character in a substring.
                                       Default is 0.
$]    $PERL_VERSION                    Returns the version plus patchlevel divided by 1000.
$^D   $DEBUGGING                       The current value of the debugging flags.
$^E   $EXTENDED_OS_ERROR               Extended error message on some platforms.
$^F   $SYSTEM_FD_MAX                   The maximum system file descriptor, ordinarily 2.
$^H                                    Contains internal compiler hints enabled by certain pragmatic modules.
$^I   $INPLACE_EDIT                    The current value of the inplace-edit extension. Use undef to disable inplace editing.
$^M                                    The contents of $M can be used as an emergency memory pool in case Perl dies
                                       with an out-of-memory error.
                                       Use of $M requires a special compilation of Perl.
                                       See the INSTALL document for more information.
$^O   $OSNAME                          Contains the name of the operating system that the current Perl binary was compiled for.
$^P   $PERLDB                          The internal flag that the debugger clears so that it doesn't debug itself.
$^T   $BASETIME                        The time at which the script began running, in seconds since the epoch.
$^W   $WARNING                         The current value of the warning switch, either true or false.
$^X   $EXECUTABLE_NAME                 The name that the Perl binary itself was executed as.
$ARGV                                  Contains the name of the current file when reading from <ARGV>.

_____________ ARRAY

@_ $#_        is the list of incoming parameters to a sub.
              If the array name is '_' so its elem 0 is $_[0] the second is $_[1] and so on.
              And you can refer to $#_ as the index number of the last parameter:
@ARGV         The array containing the command-line arg for the script.
@INC          The array containing the list of places to look for Perl scripts to be evaluated by the do, require, or use constructs.


_____________ HASH

%INC          The hash containing entries for the filename of each file that has been included via do or require.
%ENV          The hash containing your current environment. Ex. $ENV{PATH}  # /usr/local/bin:/usr/bin:/sbin:/usr/sbin
%SIG          The hash used to set signal handlers for various signals.




_____________ FILEHANDLES

ARGV          The special filehandle that iterates over command line filenames in @ARGV.
              Usually written as the null filehandle in <>.
STDERR        The special filehandle for standard error in any package.
STDIN         The special filehandle for standard input in any package.
STDOUT        The special filehandle for standard output in any package.
DATA          The special filehandle that refers to anything following the __END__ token
              in the file containing the script.
              Or, the special filehandle for anything following the __DATA__ token
              in a required file, as long as you're reading data in the same package __DATA__ was found in.
_             (underscore) The special filehandle used to cache the information
              from the last stat, lstat, or file test operator.

$|    $OUTPUT_AUTOFLUSH          If set to nonzero, forces an fflush(3)
                                 after every write or print on the currently selected output channel.
$%    $FORMAT_PAGE_NUMBER        The current page number of the currently selected output channel.
$=    $FORMAT_LINES_PER_PAGE     The current page length (printable lines)
                                 of the currently selected output channel. Default is 60.
$-    $FORMAT_LINES_LEFT         The number of lines left on the page
                                 of the currently selected output channel.
$~    $FORMAT_NAME               The name of the current report format for the currently selected output channel.
                                 Default is the name of the filehandle.
$^    $FORMAT_TOP_NAME           The name of the current top-of-page format for the currently selected output channel.
                                 Default is the name of the filehandle with _TOP appended.
_____________ CONSTANTS

__END__       Indicates the logical end of your program.
              Any following text is ignored, but may be read via the DATA filehandle.
__FILE__      Represents the filename at the point in your program where it's used.
              Not interpolated into strings.
__LINE__      Represents the current line number. Not interpolated into strings.
__PACKAGE__   Represents the current package name at compile time, or undefined
              if there is no current package. Not interpolated into strings.

_____________ REGULAR EXPRESSION

$digit                    usual $1 $2 $3 ...
$&   $MATCH               The string matched by the last successful pattern match.
$`   $PREMATCH            The string preceding whatever was matched by the last successful pattern match.
$'   $POSTMATCH           The string following whatever was matched by the last successful pattern match.
$+   $LAST_PAREN_MATCH    The last bracket matched by the last search pattern.
                          This is useful if you don't know which of a set of alternative patterns was matched.
                          For example: /Version: (.*)|Revision: (.*)/ && ($rev = $+);



--------------------------
PERL DISTRIBUTIONs     (http://perldoc.perl.org/perlpolicy.html)
--------------------------                      ^^^^^^^^^^
only the last 2 are supported
    ex. 5.20   5.22
when is released 5.24,
5.20 will be no more supported.

pragma: special Modules (ex. use strict)
                             use v5.10    <--- version of Perl: includes many features
                                               ex. say wrt print (which adds a \n for me)

---------
INSTALL                                                       another way is perlenv
---------                         |                              /
 > tar zxf latest.tar.gz          | install from  CPAN App::perlbrew <----- allows to have more PERL versions
 > cd perl–5.22.2                 |                                         and switch between them
 > sh Configure –des              | ~/perl5/perlbrew/bin/perlbrew install perl–5.22.2
 > make test && make install      |

       enhanced distributions wrt standard one:
          - ActivePerl  free Win/Mac/Linux   $ Unix (Solaris..)
          - Strawberry       Win only
          - Citrus      free  Win/Mac/Linux  bundles wxPer to distribute app with GUI







 perl -MData::Dumper -e 'print Dumper \@INC'      to see the INC value.
                                                  also a simple     perl -V
                                                  or even           perl -E "say @INC"

                                                  to add a path in INC ex to use A::B
                                                  perl -I A  (<--- it's the dir)
                                                  or inside the code (use lib "/.../.../A";  or use lib qw(...)
                                                                      use A::B;)
                                                  nb. I can also push on the array @INC:
                                                      push(@INC, (...))
                                                      but in such a way, my dirs will be searched
                                                      as last option, that is not what I want.

--------------------------
START A SCRIPT
--------------------------

       for portability (not sure where perl is located)
                   #!/usr/bin/env perl
       as normally env is always in /usr/bin/env
               ________________________________
               |                              |
       #!/usr/bin/perl                  #!/usr/bin/perl
       print "Hello, world!\n";         use 5.010;     <-----------
                                        say "Hello World!";   <------ say put '\n'


--------------------------
SIGILs   (the reserved symbols for the var TYPE)
--------------------------
Scalar      $   stays for the S of Scalar
Array       @   stays for the A of Array
Hash        %   a pair of ° (separated by a /) indicating key/value
Typeglob    *   *foo     (Everything named foo in the Symbol Table:  $foo  @foo   %foo  &foo )
Subroutine  &   before v5 it was &fun() to call a user-defined function fun()
                wrt built-in function (ex print()) that doesn't want it.
                Now it's optional. It must be used only when assigning the name
                of the function to a reference: $r=\&fun;

nb. 'glob' is the nick name for *. ('globally') In the unix shell it means FILE-glob,
     all files in a dir. TYPE-glob means all entries in a Symbol Table.

symbol-table:  - where the compiler stores symbols (variables, filehandles, and subroutines)
               - is implemented in Perl using a normal HASH.
               - there is 1 symbol-table for each package (to give its own namespace).

PRECEDENCE:
   - The sigils are not operators.
   - They come always FIRST!
   - They identify a TERM.
   - Once the TERM is identified operators apply
     (with the usual Operator-Precedence-list (-> first, ....)).


--------------------------
SCALAR VARIABLES
--------------------------
            can contain
                1. undef      <-----   ANY scalar var before any assignment is automatically init with value 'undef'
                2. a number
                3. a string  (concatenated with '.')
                4. a reference
                5. a file handle

        In Perl, the operator determines both
          - the context: SCALAR / LIST
          - the TYPE for scalars: (string / num)

        For example $x + $y is always a numeric addition of 2 SCALARs,
        and if $x or $y do not contain numbers, an attempt is made to convert them to number first.
        ($x == $y I'm comparing 2 nums,  $x eq $y I'm comparing 2 strings)

    Operators are:
        # Numerical operators:  <,  >, <=, >=, ==, !=, <=>, +, *
        # String operators:    lt, gt, le, ge, eq, ne, cmp, ., x
        nb. x for string. (ex. print "–" x 80;)
            In LIST context instead of the strings, it replicates the LIST.
            This is useful to init an array or hash
                              @ones = (1) x 80;      #init with 80 1
                              @ones = (5) x @ones;   #change all 80 to 5
                              @keys = qw(aaa bbb ccc);
                              @h{@keys} = ("") x @keys;    #h{aaa}="", h{bbb}="", h{ccc}=""

        <=> cmp returns  -1 0 +1 if $a < = > $b


        my $str1 = "4G";
        my $str2 = "4H";

        print $str1 .  $str2; # "4G4H"
        print $str1 +  $str2; # "8" with two warnings
        print $str1 eq $str2; # "" (empty string, i.e. false)
        print $str1 == $str2; # "1" with two warnings
        print "yes" == "no";  # "1" with two warnings;
                                    both values evaluate to 0
                                    when used as numbers

    __________________________________
    |    INTERPOLATION   (string with " and ')
    |__________________________________
        is the term used by Perl (bash uses 'string substitution')
        to specify that in "---val of $a"   $a is replaced by its value
        "" performes INTERPOLATION
        '' suppresses  ...

        As in bash ' is STRONG quote:
        print "Hello \$string"; # "Hello $string"
        print 'Hello $string';  # "Hello $string"

        nb. ' is a valid —though archaic— character
            replaced by the more visually distinct :: . That means that
            $main'var and $main::var are the same thing.
    __________________________________
    |    notes on  N U M
    |__________________________________
    |arbitrary precision on numbers: to have it, add
    |    use bigint, bigrat or bignum
    |    or at command line -M...
    |    ex >perl -Mbigrat -E 'say 10/3 == 1/3*10 ? "Y":"N"' ---> Y
    |
    | literals used as rvalue in $x = ... can use
    |        0x.. ( for hex)
    |        0... (     oct)
    |        0b.. (     bin)
    |        _    (ex 4_294_967_296)
    |
    | Automatic conversion from string (ex "0x56f") to num (1391)
    | not works for these formats:
    |     $a = 0x56f   + 1   #1392 ok
    |     $a = "0x56f" + 1   #1    NOT OK
    |     $a = 071   wrt "071"
    |          0b111 wrt "0b111"
    |          1_004 wrt "1_004"
    | So these numeric literals  CANNOT be used if the rvalue
    | comes from another source (ex an input string)
    | In that case use an explicitly conversion
    |              hex("0x56f")
    |              oct("071")
    |              oct("0b111") <---- nb. for binary I still use oct!!!       OCT for all!
    |              oct("0x56f") <---- nb. for hex    I can still use oct!!!   OCT for all!
    |_________________________________
    __________________________________
    |    notes on  S T R I N G
    |__________________________________
    |   $var is INTERPOLATED inside ".."
    |   that means "aaa $var bbb"  is the same as "aaa".$var."bbb"
    |   where I can avoid to use explicit concatenatios with '.'
    |   INTERPOLATION woks only for $scalar and @array NOT %hash
    |   for array means concatenate all el with a $" (usually a space)
    |   print "@a"  is like  $a = join( $", @ARGV ); print $a;
    |
    |   {} can be used to better separate a var ex "aaa${var}rrr"  without is a mess "aaa$varrrr"
    |   this because a var inside {} is forced to a be a STRING
    |   that's why in a HASH $h{"feb"} is the same written as $h{feb}
    |   Sometimes the short syntax is ambygous so an explict "" is required
    |   $h{27 feb}  #error    $h{"27 feb"}  #ok
    |
    |   {} is also better to use in a reg. exp.
    |   ex /${foo[bar]}/  better than only  /$foo[bar]/
    |   where [bar] could be intended as range of 3 letters b a r
    |_________________________________
-------
lower UPPER case
-------
    there are interesting escape sequences
        \l  \u              lower UPPER case only the following char
        \L   \U .... \E       "    "     "   ALL the chars up to \E (optional if till the end)
    ex
        $a="arREFD67hhff"; $b="\U$a\E";    #ARREFD67HHFF  also only $b="\U$a";

    the usage is normally in regex
        $a="ID"; print (($a=~/\Uid/) ? "yes" : "no")   #yes
-------
q qq qw qx
-------
     They are the alternative to:

     ''    q   (NO   interpolation, as they are '')
     ""    qq  (YES     "         ) qq/a b c/ --> "a b c" <--- a SCALAR: $a=qq..
     ``    qx  (YES     "         ) execute a command
     ()    qw  (NO      "         ) qw/a b c/ --> ("a", "b", "c") <-- a LIST: @a=qw..
                                        ^ ^           ^    ^            ^
                                      spaces          commas            $a=qw/a b c/ returns "c"
                                                                        that is a LIST evaluated as a SCALAR
  nb. any not alphanum char is OK as separator
      ex. q//   q()     q!!

  qr   is the last of the family. It can define a PATTERN as
       a string var, to use later in pattern match.
       ex
            $re = qr/$pattern/;
            $s =~ /foo${re}bar/;    # can be interpolated in other patterns
            $s =~ $re;              # or used standalone
            $s =~ /$re/;            # or this way

-------
BAREWORD
-------
   unquoted terms (ex. print hello;) should be avoided, as error prone.
   a way is:
            use strict "subs";
   that has anyhow the limits of:
            - lasts its scope only
            - a    no strict "subs";    can turn it effects off
   so the best is to write (at least)
            use v5.12;
--------------------------
BOOLEAN VARIABLES
--------------------------
            A scalar is 'false' when:

            1. undef
            2. number 0
            3. string ""
            4. string "0".

            nb. "0.00"    is true   (not "" neither "0")
                "0.00" +0 is false  (+ is num-operator so string is converted to num and result is 0)

     Boolean operators are both &&  ||  !       from C       + precedence over ,
                                and or  not     from BASIC   -    "            ,

     Both works as short-circuit, which means the evaluation
     is stopped as soon as possible. Any remaining right part is not conisdered.
     Besides the precedence the 2 families behave identically.

     //           // operator is exactly the same as ||,
                  except that it tests DEFINEDNESS instead of TRUTH.
                  EXPR1 // EXPR2 returns EXPR1 if it's defined, otherwise EXPR2.
                  (EXPR1 is evaluated in scalar context,
                   EXPR2 in the context of // itself).
                  Usually, this is the same result as defined(EXPR1) ? EXPR1 : EXPR2
                  (except that the ternary-operator can be used as a lvalue, while EXPR1 // EXPR2 cannot).
                  This is very useful for providing default values for variables.
                  If you actually want to test if at least one of $a and $b is defined,
                  use defined($a // $b).

--------------------------
ARRAY
--------------------------
            my @array = (
                "print",
                "A",
                "B", # <-- last comma is ok
            );

            print $array[0]; # "print"
            print $array[1]; # "A"
            print $array[2]; # "B"
            print $array[3]; # returns undef, prints "" and raises a warning

    - negative indices to retrieve from the end

            print $array[-1]; # "B"
            print $array[-2]; # "A"
            print $array[-3]; # "print"
            print $array[-4]; # returns undef, prints "" and raises a warning

    - add on demand (no dimension required on declaration, like in C)
            my @home;
            $home[0] =  "couch";
            $home[1] =  "chair";

    - len
            scalar @array
            $#array

    - slice of arrays
            @days[3, 4, 5]     Array slice containing ($days[3], $days[4], $days[5])
            @days[4..6]        Array slice containing ($days[4], $days[5], $days[6])

    - print
            it's interpolated into strings
            print "@array";        # "print A B"

--------------------------
HASH
--------------------------
            a list of scalars indexed by strings.

   keys:    are always STRING
   values:  are SCALAR (: string or numbers)

   Linguistically, a hash relationship is genitive or possessive, ( “of” in English)
   The wife of Adam is Eve: $wife{"Adam"} = "Eve";

undef:   accessing a key that doesn't exist or accessing outside
         the hash gives  'undef'

            my %scientists = (                  %h = ('foo', 35, 'bar', 12.4, 2.5, 'hello',
                "Newton"   => "Isaac",                'wilma', 1.72e30, 'betty', "bye\n");
                "Einstein" => "Albert",
                "Darwin"   => "Charles",        $h{'foo'}    = 36;            # modify a key already present
            );                                  $h{'fred'}   = 'flintstone';  # add 2 keys new ...
                                                $h{'barney'} = 'rubble';      # ... not present before
            => is called a "fat comma"
            syntactic sugar which allows to not use ','
            and see the key/value with ease.

            print $scientists{"Newton"};   # "Isaac"
            print $scientists{"Einstein"}; # "Albert"
            print $scientists{"Darwin"};   # "Charles"
            print $scientists{"Dyson"};    # returns undef, prints "" and raises a warning

            We have seen that {} is a STRING operator, that forces what inside to be a STRING
            so you can omit quotes:  $hash{key} instead of $hash{"key"}
            ("" are required if the key has spaces).

    - HASH into SCALAR   $s = %H                                   $ <-- %
            $s = 0   if the HASH is EMPTY. Usefull in tests!!
            otherwise (HASH not EMPTY) return a vale x/y (ex 5/8) which is
            the situation of the hash table (5 used buckets on a total of 8 available)

    - slice of hashes
            Given a HASH %H, a subset %h could be identified by a LIST of keys, ex ("a", "b", "f") or better qw/a b f/
            An instruction like H{ qw/a b f/} is the array of values so it's @H{ qw/a b f/}
            To have a hash it's:

            my %h;
            @h{qw/a b f/} = @H{qw/a b f/};     or   with the map function    my %h = map { $_ => $H{$_} } qw/a b f/;

            Starting with Perl 5.20.0 it's possible the same short form as array:
                 my %h = %H{qw/a b f/};

    - array to hash
            I used this trick to convert an array
            (where I loaded the lines of a file: @lines=<$fh> <--- 1 single command)
            into and hash:
            %lines = map { $_ => 1 } @lines;
            the lines are the keys and the values (useless) are all 1.
            This can be usefull for fast search/test:
                 if (exists $lines {$k}) {


----------- HASH FUNCTIONS
keys / values: they return 2 ARRAYs
             my @k = keys   %hash;        N.B. order not assured:  k[0] could be any and so on
             my @v = values %hash;

exist:  if (exists $books{"dino"}) {   # Test if such a key is presnt

delete: delete $books{$person};        # Remove that pair key / value

reverse: %ip_address = reverse %host_name;
                               create a new hash were the keys are
                               the values of the first, and the values
                               are the old keys.
                               N.B. as keys must be unique, if old hash
                               had equal value for different keys, they overwrite
                               each others(: the later items in the list
                               overwrites any earlier one).

while / foreach:
            while ( ($key, $value) = each %hash ) {  | foreach $key (sort keys %hash) {
                 print "$key => $value\n";           |  print "$key => $hash{$key}\n";
            }                                        | }

----------- OLD MULTDI-DIM EMULATION
A feature was originally implemented to support a2p, the awk-to-Perl trans-
lator. It allows to emulate a multi-dim hash with the syntax of a list of keys
inside { }, (separated by commas) : %h { k1, k2, k3}. They form a super-key
that is the string with all the key concatenated with the special var $;
       %h { k1, k2, k3} =  %h { join $; => $k1, k2, k3}

 perl -e 'print $;' | od -c    # 034
--------------------------
ARRAY & HASH
--------------------------
            [ ]: square brackets to retrieve from an array.
                 they are effectively a numerical operator
                 as each elem is identified by a num, it can be sayed they
                 are ORDERED list
            { }: braces to retrieve from a hash.
                 they are effectively a string operator.
                 (are UNORDERED list)

           The fact that the index supplied is a number or a string
           is of absolutely no significance:

               my $data = "orange";
               my @data = ("purple");
               my %data = ( "0" => "blue");

               print $data;      # "orange"
               print $data[0];   # "purple"
               print $data["0"]; # "purple"
               print $data{0};   # "blue"
               print $data{"0"}; # "blue"

           Hash is just an array with an even pair of elements, separated
           in pairs with the comma ',' and inside the pair with the fat comma '=>'

           So you can convert a hash to an array with twice as many entries,

                my @scientists = %scientists;

           nb.  The order is not guaranted.
                They will be returned in whatever order is more efficient.
                It's only guaranted that each key comes before its value.

--------------------------
LIST
--------------------------
            Is a sequence of values separated by
                  ,
            or
                  =>           #Remember that => is just , (fat comma)
            enclosed in ( )
            That are the braces not used
            neither by the array [] nor by the hash {}.
            A list is not a variable.
            A list is an ephemeral value which can be assigned to
            an array or a hash var. This is why the syntax
            for array and hash is identical.

            The following are just lists. Identical lists.
            ("one",   1, "three",   3, "five", 5)
            ("one" => 1, "three" => 3, "five" => 5)

     empty list:  ()
             can be used to declare an empty array or an empty hash

     list assignments: are called the assignments like:
             my ($a, $b, $c) = @x;   # assign to scalars, vals from an array
             ($a, $b) = ($b, $a);    # swap 2 vars

     NOT LIKE LISP:     List values cannot be nested.
     -------------      Perl manages it as A SINGLE LONG LIST.

             my @array = (                    |
                           "apples",          |
                           "bananas",         |print $array[0]; # "apples"
                           (                  |print $array[1]; # "bananas"
                               "inner",       |print $array[2]; # "inner"
                               "list",        |print $array[3]; # "list"
                               "several",     |print $array[4]; # "several"
                               "entries",     |print $array[5]; # "entries"
                           ),                 |print $array[6]; # "cherries"
                           "cherries",        |
                        );                    |

             The same is true whether the fat comma is used or not:

                    my %hash = (
                        "beer" => "good",           raises a warning because the hash
                        "bananas" => (              was declared using a 7-element list
                            "green"  => "wait",
                            "yellow" => "eat",
                        ),
                    );
             this makes it easy to concatenate multiple arrays together:

                my @bones   = ("humerus", ("jaw", "skull"), "tibia");
                my @fingers = ("thumb", "index", "middle", "ring", "little");
                my @parts   = (@bones, @fingers, ("foot", "toes"), "eyeball", "knuckle");

             Nesting is acted with references.
--------------------------
CONTEXT
--------------------------
            Perl code is context-sensitive.
            Every expression is evaluated in SCALAR or LIST context,
            depending on whether it is expected to produce a SCALAR or a LIST.

       1  - A SCALAR assignment
                     my $scalar =
            evaluates in scalar context.

       2  - An ARRAY or HASH assignment
                     my @array =
                     my %hash  =
            evaluates in list context.

       3  - A scalar evaluated in list context                                        ()  <-- $
            is silently converted into a 1-ELEMENT LIST:

               my @array = "Mendeleev";
               # same as 'my @array = ("Mendeleev");'

       4  - An array evaluated in scalar context                                       $  <-- @
            returns the LEN:

               my @array = ("Alpha", "Beta", "Gamma", "Pie");
               my $scalar = @array;
               print $scalar; # "4"

       5  - Already seen that an HASH into a scalar                                    $  <-- %
            returns the used/avail buckets

       6  - A list-EXPRESSION (a list is different from an array, remember?)           $  <-- ()
            evaluated in scalar context returns
                    not the len of the list
            but
                    the LAST scalar in the list:

            my $scalar = ("Alpha", "Beta", "Gamma", "Pie");
            print $scalar; # "Pie"                    ^

            SO AT THE END: AN EMPTY LIST()/HASH%/ARRAY@ GIVES SCALAR 0   $x = ()  <-- x:0
            ------------------------------------------------------

       7  - A list-ASSIGNMENT evaluated in scalar context returns                     $  <-- ()=()
            the number of list elem. assigned
            if (my ($k,$v) = $string =~ m/(\w+)=(\w*)/) {
                         1.  =~  has higher precedence wrt =
              =~ ______> 2.  in LIST context =~ returns the STRINGS matched <------ N.B.
                         3.  =, the list-assignemnt is done
                         4.  as it's done in scalar context, if(), it returns 2 the num of elem list assigned
                             ex. DB<1> $a="aaa bbb"
                                 DB<2> $s=my($k,$v)=$a=~/(\w+) (\w+)/
                                 DB<3> p $s    2

            ------- example with nested array
            ARRAY and HASH, as depend on list, cannot be nested.
            my @outer = ("......, ....);
            my @inner = ("Earth", "Moon");

            $outer[3] = @inner; <-- an array evaluated in scalar context
                                    so returns its len.
            print $outer[3]; # "2"

   nb.      when the compiler parses the code, it figures out the context
            and generates the proper binary opcode. Later, at runtime
            those internal opcodes are actually interpreted in that context.
--------------------------
REFERENCES
--------------------------
            Perl uses references to allow building complex data struct.
            (nesting scalar array and hash in whatever order)
            A ref is a scalar.

        CREATE a ref:  use '\' before the var you want to refer

            my $colour        = ....;
            my @colours       = (...);
            my %atomicWeights = (...);

            my $scalarRef = \$colour;
            my $arrayRef  = \@colours;
            my $hashRef   = \%atomicWeights;

        ACCESS its value: use {} around
                          if it's not ambiguous, you can omit {}
                          while for array and hash you can also use ->

                          nb.  We have seen that {} is a STRING operator,
                               that forces what inside to be a STRING
                               it's the way to have the "name" of the pointed var:

                               perl -e '$b=2; $a=b; print "$a = ${$a}\n"'   # b = 2

                               and here I never used a reference syntax.

                          nb.  symbolic reference: is what I've used above:
                          a var whose value is the name of another var or subroutine.

                         SYMBOLIC REFERENCES ARE ILLEGAL UNDER use strict "refs" .

                               perl -e 'use strict "refs"; $b=2; $a=b; print "$a = ${$a}\n"'
                               Can't use string ("b") as a SCALAR ref while "strict refs" in use at -e line 1.

            print ${ $scalarRef };   or only        print $$scalarRef;

            print $colours[0];       # direct array access
            print ${ $arrayRef }[0]; or only        print $arrayRef->[0];

            print $atomicWeights{"Helium"}; # direct hash access
            print ${ $hashRef }{"Helium"};  or only print $hashRef->{"Helium"};

        ___________________________________________
        | ANONYMOUS ARRAY and HASH  (and function)
        |
        |    Use [ ] for an anonymous ARRAY and
        |        { } for an anonymous HASH.
        |    The value returned in each case is a REFERENCE:
        |___________________________________________

      my $ary = \@myarray;    # reference to a named array                   my $ary = [1,2,3,4,5];            # reference to an unnamed array
      my $hsh = \%myhash;     # reference to a named hash                    my $hsh = {Na => 19, Cl => 35};   # reference to an unnamed hash
      my $sub = \&mysub;      # reference to a named subroutine              my $sub = sub { print $state };   # reference to an unnamed subroutine


      ----------------------------------------------------------------------------------------------
             declaration                                         retrieve back
      ----------------------------------------------------------------------------------------------
           my %o1 = (                     |                                   |               |
               "name" => "Santa Claus",   |           (6 instruct.)           |  (5 instr.)   |  (3 instr.)
               "DOB"  => "1882-12-25",    |                                   |               |
           );                             |   my $r    = $account{"owners"};  |  ...          |  -
                                          |   my @o    = @{ $r  };            |  -            |  = @{ $account{"owners"} };
           my %o2 = (                     |   my $r1   = $o[0];               |  = $r->[0];   |  -
               "name" => "Mickey Mouse",  |   my $r2   = $o[1];               |  = $r->[1];   |  .
               "DOB"  => "1928-11-18",    |   my %o1    = %{ $r1 };           |  ...          | = %{ $o[0] };
           );                             |   my %o2    = %{ $r2 };           |  ...          | = %{ $o[1] };
                                          |                                   |               |
           my @o = ( \%o1, \%o2 );        |   $account{"number"}              |               |
                                          |   $account{"opened"}              |               |
           my %account = (                |                                   |               |
               "number" => "12345678",    |   $o1{"name"}   $o1{"DOB"}|       |               |
               "opened" => "2000-01-01",  |   $o2{"name"}   $o2{"DOB"}|       |               |
               "owners" => \@o,           |                                   |               |
           );      ^
                   |
                 %account is the first 'struct' that we see.
                 HASH comes ready to define a C-like-struct
                 the 'members' are the key names and the values are their type.


      ----------------------------------------------------------------------------------------------
             long form                                           short
      ----------------------------------------------------------------------------------------------
      my $owner1Ref = {                              |  my %account = (
          "name" => "Santa Claus",                   |      "number" => "31415926",
          "DOB"  => "1882-12-25",                    |      "opened" => "3000-01-01",
      };                                             |      "owners" => [
                                                     |          {
      my $owner2Ref = {                              |              "name" => "Philip Fry",
          "name" => "Mickey Mouse",                  |              "DOB"  => "1974-08-06",
          "DOB"  => "1928-11-18",                    |          },
      };                                             |          {
                                                     |              "name" => "Hubert Farnsworth",
      my $ownersRef = [ $owner1Ref, $owner2Ref ];    |              "DOB"  => "2841-04-09",
                                                     |          },
      my %account = (                                |      ],
          "number" => "12345678",                    |  );
          "opened" => "2000-01-01",
          "owners" => $ownersRef,
      );
--------------------------
REFERENCES
--------------------------
INDIRECTION:    it's the problem to access a variable through another variable

                ex.  $v='B';

                     $x = 'v';    'symbolic' reference .....................................
                     $x = \$v;    'hard'     reference  ($x is pointing directly to 'B')    |
                                    ^                                                       |
                                    |                                                       |
                                    so now we know: the '\' creates a HARD ref              |
                                                                                            |
                     perl -e '$b=2; $a=b; print "$a = ${$a}\n"'   # b = 2  <----------------'

POINTER:        in C for example it's solved, with the pointer type,
                a var storing the memory address of the other.

REFERENCE (hard)  in Perl
                - it's the 3rd basic type (after 'number' and 'string')
                - it's a scalar
                - it can point to ANY data type ($calar, @rray, %ash, &unction)

REFERENT        is 'what' a reference is pointing to.

                          x ----->  B
                          ^         ^
                     referenCE      referenT

                     - A referenT doesn’t really have a name of its own, apart from the references to it.
                     - A referenT is only DESTROYED when ALL the referenCEs to it are eliminated.
                       you can determine the underlying refcount with the Devel::Peek module, bundled with
                       Perl.
                       Devel::Peek contains functions which allows raw Perl datatypes to be manipulated
                       from a Perl script. This is used by those who do XS programming to check that the data
                       they are sending from C to Perl looks as they think it should look.

SYMBOL TABLES   variable name lives in some kind of symbol table,
                that hold 1 HARD referenCE to its underlying (otherwise nameless) referenT.

CREATE          - the operator \ (like the & in C) it gives the memory address.
  1               So the 1st way to create a scalar-var of TYPE 'reference' is:

                                $scalarref  =  \$foo;       <-- to a scalar
                                $constref   =  \186_282.42; <-- even not common can be to 'anonymous' constants (7 or "camel")
                                $arrayref   =  \@ARGV;      <-- to an array
                                $hashref    =  \%ENV;       <-- to a  hash
                                $coderef    =  \&handler;   <-- to a  sub
                                $globref    =  \*STDOUT;    <-- to a  glob (symbol table section)

                  NB.1 with the \ mode, we are creating a 2nd referenCE to a referenT.
                      In fact, apart from the 'anonymous' case, the others cases are of the form:
                      $a = \$b;    so $a, after $b, is a 2nd reference name to the same referenT.

                  NB.2 WHEN USED ON A LIST, '\' RETURNS A LIST AS WELL (IT APPLIES TO ALL ELEMs):

                       @r = \($s, @a %h, &f);     <--- the same as  @r = (\$s, \@a, \%h, \&f);
                       @r = \(@x);                <--- When 1 array or 1 hash is written inside ()
                                                       the '\' is executed on each of their elem.
                                                       the same as:  @r = map { \$_ } @x
                                                       (NB. for a HASH, also for the keys, that is not
                                                            what you would expect)
                       @r = \fx();                <--- If a fun returns a list.
                                                       It's the same as: @r = map { \$_ } fx();
                                                       The same with a list of more fun:
                                                         @r = \( fx(), fy(), fz() );
                                                         @r = ( \fx(), \fy(), \fz() );
                                                         @r = map { \$_ } fx(), fy(), fz();

                  NB.3 '\' always supplies LIST context to its operands.
                       If it's itself in scalar context, you’ll
                       end up with a reference to only the last elem:
                       @reflist = \localtime();  # Ref to each of 9 time elements
                       $lastref = \localtime();  # Ref to whether it's daylight savings time
                       ^
                  scalar context

                       So, as all the others LIST operator,
                       use an explicit 'scalar' to force what follows into scalar context:

                       $dateref = \scalar localtime(); # \"Tue Oct 18 07:23:50 2011"




ANONYMOUS DATA  - in the following cases we create a reference to a zone of memory
  2               that had no other previous 'named' reference.
                  This is what happen normally with instructions defining 'inline' (in that point,
                  so, it would be anonymous without that reference)

                  $constref   =  \7;
                  $arrayref   = [1, 2, 3]
                  $arrayref   = [1, 2, ["a", "b", "c", "d"]];
                  $hashref    = {
                               "Adam"   => "Eve",
                               "Clyde"  => $bonnie,
                               "Antony" => "Cleo" . "patra",
                               };
                  $coderef    = sub { print "a" };    <--- note the ';' (that is optional
                                                                         in a normal function definition)


                  NB.1
                     with he above definition, we have associated a new semantic meaning to both [ ]
                     and { }. Up to now they were ACCESSIBLE-OPERATORS ('numerical' and 'string' operators)
                     to a TERM xxx, accessing it: $xxx[3]  $xxx{'key'}
                     The above gives them also a CREATOR-OPERATOR meaning.

                     When Perl is expecting an xxx TERM that is missing, in that case they act as CREATION-OPERATORs

                  NB.2
                     since the '{' has also a 3rd meaning to delimit 'blocks' of CODE
                     there are cases where to disambiguate must bu use +{ or 'return'.
                     ex
                     I want to define a function that returns a reference to a created anonymous HASH
                     from the received args array (@_)
                         ex:  sub f { {@_}}        # it returns the array @_ so it's wrong
                              sub f { return {@_}} # it creates an anonymous HASH and returns the reference
                              sub f { +{@_}}       #       "                  "                     "

                  NB.3  'AUTOVIVIFICATION'               l = ...
                     Is the process to automatic create (lvalues) if they are not defined.
                     and regardless their complexity (so any required nested struct is created)
                     ex
                         $a = 5   $a is a lvalue and if not yet defined is created now.
                                  No magic till here.

                         $a[2][2][2] = "t"
                                                              [0
                                                               1] --->[0
                                                                       1] --->[0
                                                                               1] --->  "t"

                     if not yet defined all is create now. So Perl creates 3 scalar-storage-locations,
                     the first 2 of these 3 locations store refs to
                               2 anonymous arrays
                               the last scalar stores "t"
                     But the point of autovivification is that we don’t have to worry about it.

                     Suppose now that $array[3] is undefined. The following statement is still legal:
                     $array[3]–>{"English"}–>[0] = "January";
                     As a (lvalue), everything is first created, and the (rvalue) "January" is assigned.

                     If the same instruction is an (rvalue):
                           print $array[3]–>{"English"}–>[0]
                     the auto-creation occurs till $array[3]–>{"English"} then stops (
                     the final element is not an lvalue). (The fact that it defines the first two at all in
                     a rvalue context could be considered a bug. We may fix that someday.)



PERL-1-DIMENSIONAL   references, as 'scalars', (so 1 dimensional) are what allows Perl, to
                    still be internally 1-dimensional, but building up complex data structures
                    of array-of-array-of-hashes......

a real POINTER      Perl references are like real C pointers, so if $b is a reference to $a
                    and $a changes it's value, then dereferencing $b (that is $$b) I get the
                    updated last $a value:

                       use Devel::Peek;
                       $a=51;                 <----- here $a stored an integer
                       $b=\$a;                <----- here I create $b reference to the $a val
                       $a="four";             <----- here $a is changed to a string
                       Dump $a;
                       print $a . "\n";
                       print $b . "\n";
                       print $$b;
                       --------------GENERATES THIS:

                                         SV = PVIV(0x2329800) at 0x232ea88 <----- head addr & body (232ea88) addr
                                           REFCNT = 2                      <----- ref count is 2 (through both $a and $b)
                                           FLAGS = (POK,IsCOW,pPOK)
                                           IV = 51                         <----- wow stores also OLD value !!!!!!
                                           PV = 0x2334470 "four"\0
                                           CUR = 4
                                           LEN = 10
                                           COW_REFCNT = 1
                                         four                    <---- print $a
                                         SCALAR(0x232ea88)       <---- print $b  (stores the body addr)
                                         four                    <---- print $$b .... wow it's up-to-date


BLESS               bless ($r, PACKAGE_NAME)   bless ($r)

                    it is a function which makes referenT pointed by the referenCE $r to
                    be an object in package PACKAGE_NAME (current Package, if 2nd arg is missing)
                    Then returns for convenience again $r

                    ----- file A.pm:
                    package ..:: ...

                      sub  new {
                                 my $c = shift;  <---- the PACKAGE_NAME is the 1st arg passed in a create:
                                                       $o = PACKAGE_NAME–>new(a => "xxxx", b => "yyy");      1
                                                                ^
                                 my %attrs = @_;  <--  here the remaining hash-args.
                                                       nb the array @_ is now again
                                                          an even number of elements with the actual key-arg pairs
                                                          passed in the new() call
                                 my $r = { %attrs }; <--- here an anonymous hash is recreated and $r
                                                          is the scalar reference to it.
                                 return bless($r, $c); <--as bless returns again $r, then having a 'return bless ..'
                                                          normally the ending way in a 'new', the 'new' itself
                                                          returns a reference.


NEW                 as an Object-creator(), it can be used any function name.
                    new() is only normally found as programmers have the habit from other languages.
                    Any of the 4 following syntaxes can be used, even if the last pair with :: at the end
                    is to prefer as less ambiguos.

                    $o_ref   =   PACK_NAME–>new(a => "xxxx", b => "yyy");      1
                    $o_ref   =   new PACK_NAME  a => "xxxx", b => "yyy";       2

                    $o_ref   =   PACK_NAME::–>new(a => "xxxx", b => "yyy");    1::
                    $o_ref   =   new PACK_NAME::  a => "xxxx", b => "yyy";     2::


ref                 The ref operator (ex. ref($r))
                    receives the scalar ref, and returns the "string" of the TYPE.
                    The basic types are:
                        SCALAR , ARRAY , HASH , CODE , GLOB , REF , VSTRING , IO , LVALUE ,
                        FORMAT , and REGEXP
                    The Object-user-defined-type are dumped in both (external and  internal type):
                        ex: MyType=HASH(0x20d10)

REF cast to STRING  A ref in "string" context, dumps TYPE and ADDRESS in the form:
                                        ref_TYPE '(' mem_address ')'
                    ex.
                                        SCALAR(0x1fc0e)

                    Is not possible to 'cast'-back from the string.
                    This is because internally a ref var stores other info (like
                    the ref count) and not only the TYPE and the address.

                    So refs cannot be used, for instance, as hash-keys if you want them back,
                    because they are unique, so good for keys, but to retrieve them back
                    you need something like:
                         $r = \@a;
                         $x{ $r } = $r;    both as keys and values.
                              ^      ^




REF to FILE HANDLE  References to file-handle are created by referencing the typeglob
                    (\*STDOUT \*STDIN)
                    Perl is able to manage with some implicit dereferencing
                    file-handles passed as strings, typeglobs (*STDOUT), or refs (\*STDOUT)
                    anyhow there are some little differences.
                    If I pass the bare typeglob (*STDIN, *STDOUT) (that is the old Perl style
                    still of course supported) I cannot bless it.
                    If I pass the refs (\*STDIN, \*STDOUT) (I can’t pass them out of the scope
                    of a localized typeglob)



REF to SYMBOL TAB   when a ref is created referencing typeglobs in a Symbol Tab,
                    the syntax is $r = *a

                          $a=51;
                          sub a {
                              print "in_fun\n";
                          }

                          $r = *a;    <--- here I create a $ref to any entry "a" of the Symbol Tab

                          print $$r;  <--- 51      using the 'scalar'   section of the Symbol Tab for "a"

                          &$r;        <--- in_fun  using the 'function' section of the Symbol Tab for "a"

                    If I want to create a reference to a specific section only of the Symbol table
                    I have this syntax:

                     $scalarref    =    *foo{SCALAR};      #    or better \$foo
                     $arrayref     =    *ARGV{ARRAY};      #    or better \@ARGV
                     $hashref      =    *ENV{HASH};        #    or better \%ENV
                     $coderef      =    *handler{CODE};    #    or better \&handler
                     $globref      =    *foo{GLOB};        #    or better \*foo     <--- actually is the above case: $r = *a

                     even never practically used the full list is:
                     $ioref        =    *STDIN{IO};        #    -
                     $formatref    =    *foo{FORMAT};      #    -

DE-REFERENCE         Briefly if $r is a reference $$r is the value.
                     Remind that a REFERENCE is a TYPE in Perl (after num, string, undef, file-hndl)
                     so it doesn't become the 'value' you expect to use, if you don't say to Perl
                     to explicitly dereference (nothing new here, still C-similarity &p and *p apply)

                     $r  as a reference we know it's a scalar.

                     here the (trite) syntax to derefence according to the TYPE it points to:
                              - it points to a scalar:  $$r
                              -       "        array :  @$r
                              -       "        hash  :  %$r
                              -       "        sub   :  &$r

                     NB.1 $$array_ref[0] = "ta";     stands for:

                              ${$array_ref}[0]     # actually nothing special here

                              not for ${$array_ref[0]}    which will dereference entry 0 of
                                                          (not existent) array @array_ref

                     NB.2 nothing special on using many levels of ref (and deref)
                                  $r = \\\"Bye";
                                  print $$$$r;         <--- with the braces is: print ${${${$r}}};


->                   The arrow operator is syntactic sugar (it's called "infix operator")
                     It means that on the left there is a reference
                                                                      $r ->
                                                                       ^
                     and on the rigth there is what makes Perl undrstand the TYPE
                                                                      $r -> ...
                                                                             ^
                     that is, if the 1st char is:
                          [    it will be considered ref to array
                          {    it will be considered ref to hash
                          (    it will be considered ref to sub


                     Here they are 3 equivalent cases for each TYPE:

                     $  $arrayref  [2] = "Ta";
                     ${ $arrayref }[2] = "Ta";
                        $arrayref–>[2] = "Ta";   <--- short form (missing sigil $ in front)

                     $  $hashref  {KEY} = "Ta";
                     ${ $hashref }{KEY} = "Ta";
                        $hashref–>{KEY} = "Ta";  <--- short form (missing sigil $ in front)

                     &  $coderef  (a => 192);
                     &{ $coderef }(a => 192);
                        $coderef–>(a => 192);    <--- short form (missing sigil & in front)


          ASSOCIATIVITY of -> :    -> is associative left-to-right:
                     print $array[3]–>{"English"}–>[0];
                                    ^
                                    start here:   entry 4th of @array   is a ref to a  hash
                                                  whose entry "English" is a ref to an array


          OPTIONAL  -> : it's optional between [ { (

                     print $array[3]–>{"English"}–>[0];  --->  print $array[3]{"English"}[0];
                     $dispatch{$index}->(1, 2, 3);       --->  $dispatch{$index}(1, 2, 3);

                     SAID OTHERWISE EACH TIME YOU FIND 'attached' [ { (
                     THERE IS A HIDDEN -> in between !!!!!!!!!!!!!!!!!

                     $a[5][1][3] = 4;


REFER (Symbolic)     Symbolic REFERENCES, instead of the address of the var, contain its name.

                          $name = "bam";
                          $$name = 1;               #  Sets $bam
                          $name–>[0] = 4;           #  Sets the first element of @bam
                          $name–>{X} = "Y";         #  Sets the X element of %bam to Y
                          @$name = ();              #  Clears @bam
                          keys %$name;              #  Yields the keys of %bam
                          &$name;                   #  Calls &bam

                     As their usage can be somehow dangerous, it can be blocked as:

                          use strict "refs";


                     and even un-blocked in a scope { } with

                          no strict "refs";


                     Symbolic REF only on GLOBAL-vars:

                        A symbolic reference always goes through the package symbol table
                        to search the name (ex "bam")
                        Only package vars are accessible through symbolic ref,
                        while lexical var (<--'my' = lexical.
                        'my' vars are NEVER  in a package symbol table), are
                        therefore invisible to this mechanism.

${x}  vs  ${"x"}     The first form is the typical UNIX-shell way to keep
                     well isolated (not ambiguos) the  var name.
                     so $x and ${x} are the sam thing,
                     in UNIX shell and also Perl decided to keep this meaning.

                     ${"x"}  is instead intended by Perl as a Symbolic-Ref
                     and so it could produce an error with (use strict "refs")



Weak Reference       standard Perl from v5.8.1.
                     They allow to make a hard-ref weak, so that if its referent
                     it's removed, its value become automatically undef.
                     This allows to not have around dangling-pointer.

                          use Scalar::Util qw(weaken);  <---- load the standard module
                          $ring = {
                              VALUE => undef,
                              NEXT  => undef,
                              PREV  => undef,
                          };
                          $ring–>{NEXT} = $ring;    <--- normal HARD-ref define
                          $ring–>{PREV} = $ring;
                          weaken($ring–>{NEXT});    <--- make it weak.
                          weaken($ring–>{PREV});

                     Besides becoming undef, its second property is that
                     it no longer contributes to the ref-count in its referent
                     data struct.

                     Dangling pointer cause Perl garbage-collector to not free memory
                     ex
                         {
                             my $a;
                             $a = \$a; # make $a point to itself. Memory of $a will not be freed.
                         }

--------------------------
TYPEGLOBS
--------------------------
    They are aliases to GLOBAL vars (not works on var declared 'my' (lexicals) or 'local').
    Assignment to a typeglob is:
         *a = *G
       - G is the actual list of entries { *G } of a certain HASH-Symbo_Table-Package
       - a, will be from now on just an ALIAS to them
            (so $a is alias for $G
                %a for %G, @a for @G,  &a() &G() <--- subroutine of that Package/NameSpace/Symbol_Table)
    If I want to alias just 1 entry (var, subroutine) I use a REFERENCE
         *a = \$G
    This way:
         $a is an alias to $G
         but currently %G @G &G() are not aliased.

IMPORTING vars:
    module Exporter works around this aliasing, as this way you can
    import entries of a package '%oouutt::' into another '%iinn::'
         *iinn::a = \&oouutt::fun;
    inside Namespace iinn:: I can call with a() the function fun()
    defined in the Package oouutt::

    nb:     local *iinn::a = \&oouutt::fun;  <--- with 'local' the alias ends (as normally with a 'local' cmd)
                                                  at the end of that code-SCOPE



_____________________________________
use vars qw($scalar %hash @array);   With perl5.6 you can use the our operator instead:
       our ($scalar, %hash, @array);

This declares the named variables as package globals in the current package.
They may be referred to within the same file and package with their UNQUALIFIED names;
and in different files/packages with their FULLY QUALIFIED names.







    Said otherwise they refer to entries in (global) Symbol tables.
    ex.
         $a = *G;   (or better: *a=\*G)
    means when now I write $a @a %a I'm accessing Symbol table entries
                           $G @G %G
    if I write $a = \$G;  is $a for $G but not @a %a for @G %G.



    Around Typeglob is built the import mechanism of global vars between 2 modules
    somethings hidden normally to developer:
                local *Here::blue = \$There::green;

--------------------------
CONDITIONALS
--------------------------
      if () {cmd}               unlike C, { } are always required even for 1 single cmd.
      cmd  if ()
      if  - elsif  - else       unlike C there is 'elsif'
      unless (A) - else         try to avoid 'unless' block as it's the same as
                                if (not A)  - else
      ? a : b

  LABEL: ....                   we can use   next LABEL        (like the C 'continue')
                                             last              (like the C 'break')
--------------------------
SWITCH
--------------------------
switch has been introduced only from version 5.10 and must be anyhow 'imported'

    use v5.10;                                   | alternative way (ex for perl < 5.10)
    use feature qw(switch); <----- optional      |
    use feature qw(:5.10);  <----- optional      |         for ($string) {
                                                 |             /abc/ and do {$abc    = 1; last;};
    given ($item) {                              |             /def/ and do {$def    = 1; last;};
    when (/a/)     { say "Matched an a" }        |             /xyz/ and do {$xyz    = 1; last;};
    when (/42/)    { say "Matched a 42" }        |             $nothing = 1;
    when (/"bee"/) { say "Matched a bee" }       |        }
    when (/\d+\w*/){ say "Matched a regex" }
    default {  ;  }             \___________nb I can use literal, string, number, regex
    }


--------------------------
LOOPS
--------------------------
            the C-style 'for' is considered old-fashion.
            Where possible use the 'foreach' which can iterate over an ARRAY.

            foreach my $i ( @array ) { print $i; }  <---- the foreach evaluates in LIST context what inside ()
                                                          so a scalar is considered a list of 1

      range operator '..':

            foreach my $i ( 0 .. $#array ) { print $i, ": ", $array[$i]; }

            It's NOT possible to iterate over an HASH,
            BUT the way it's to use the 'keys' fun which return the ARRAY of keys
            and iterate on that.

            foreach my $k (keys %hash) { print $k, ": ", $hash{$k}; }
                            ^

            SORT:  Since a hash has no underlying order,
            the keys may be returned in any order. Use the sort

            foreach my $k (sort keys %hash) { print $k, ": ", $hash{$k}; }
                            ^

      $_  (default iterator):  is the first of the built-in variables. Allows
                               to not used a var (usual $i) as iterator in the loop

                                       foreach ( @array ) { print $_; }

            which can also be written

                                       print $_ foreach @array;

     foreach --> for   as the syntax is anyhow different instead of foreach
                       you can substitute nowadays a simple shorter 'for'.

     nb. Note that the loop variable refers to the real element, not a copy.
         Hence, modifying the loop variable also modifies the original array.

      next, last: are the equivalent of break/continue. A label is optional
                  HERE: while () { ....
                                  next HERE;
                                  last HERE; <-- ex to exit many inner levels

      while  () {}
      untill () {}
      do {} while ();


--------------------------
ARRAY FUNCTIONS
--------------------------
            pop      : pop     @stack;    returns the last
            push     : push    @stack;    append a new el at last pos
            shift    : shift   @stack;    returns the 1' el
            unshift  : unshift @stack;    insert a new el in 1' pos

            splice   : splice(@stack, index, len, "a", "b", ...)    returns the subarray in @stack
                                                                    of len elements starting at index (included)
                                                                    if there are other arguments (here "a", "b", ...)
                                                                    that LIST is also substituted inside @stack
                                                                    which thus, 'loses' a slice but in its place
                                                                    gets another subarray.

                     all pop/.../unshift are 4 simple cases of splice

            join     : join("..", @a)   concat el of @a with the separator provided (1' string arg)
            reverse  : - in list-  context   returns a list in revers order. reverse ("a1","b2") -> (b2, a1)
                       - in scalar-context   first concat all the list as 1 single string
                                             then returns the reversed string. scalar reverse "  -> "2b1a"
            map      : map { .. $_ } @a;     returns an array from @a where each el (_$) has been
                                             modified by the instruct inside the {}
                                             ex map { uc $_ } @a;   convert any el in UPPERCASE
            grep     : grep { ..$_ } @a;     returns an array from @a where each el ($_) is added or not
                                             depending if the test on it { ..$_} is true or false
                                             It can be used to test if an el is present in @a
                                             scalar grep { $_ eq "..." } @a   #"1"/true
            sort     : sort @a               returns an array sorting @a alphabetically
                       sort { $a .. $b } @a  sort @a according to the instruct inside {} that operate
                                             on the built-in var named really $a and $b!!!!!!!!
                                             If I need more code the function can be somewhere else:
                                              sort comparator @a;
                                             anyhow it must always return -1 / 0 / +1
--------------------------
SUB
--------------------------
            sub func {
            }

            - subroutines always accept a LIST of scalars.
                         - that LIST may of course have a single element, or be empty
                         - a single scalar is taken as a LIST with a single element.
                         - a hash with N elements is taken as a LIST with 2N elements.

            - arg are passed by ref. (so a change is on the original)
            - func (..)  but also fun ..      brackets are optional,
              anyhow it should ALWAYS be invoked
              using brackets, even when called with no arguments
            - args are accessible using the built-in array variable @_

              sub func {             |            |              |
                                     |            |              |
                  my $a = shift @_;  | = shift ;  |    = $_[0];  |   multiple scalar assignment
                  my $b = shift @_;  | = shift ;  |    = $_[1];  |   my ($a, $b, $c) = @_;
                  my $c = shift @_;  | = shift ;  |    = $_[2];  |
                        ...
            - It's possible to call passing an HASH, as it's always a list
              but allow the most similar 'parameter' name convenition

              func ("oldString" => "pod", "width" => 10, "padChar" => "+");

              and then 'unpack' the HASH as a double size array where keys are the arg names:

              sub left_pad {
                my %args = @_;
                   ^
                my $newString = ($args{"padChar"} x ($args{"width"} - length $args{"oldString"})) . $args{"oldString"};
              return $newString;
              }

--------------------------
FILE
--------------------------
            As said it's the last possible value for a SCALAR.
            It's the value retrieved with function 'open'
            my $result = open my $fh, "<", "pippo.txt";     $result is FALSE on errors
            close $fh  # to close
                                                        ___file name ("a.txt")
                                                       /
        the general form is with 3 args   open (1  2  3)
                                                |  \_______mode: "<"   to read    "-|"   input pipe
                                                |                ">"   to write   "|-"   output pipe
                                                |                ">>"  to append
                                                |                "< :encoding(UTF–8)"  it's possible to specify the encoding
                                                '                ">> :encoding(MacRoman)"
                                                 \
                                                  \________file handle, a literal open (FILE_HDL ..)
                                                                        a var     open (my $fh   ..) <-- better

        It's possible (not recommended!) to merge the 2nd and 3rd arg:  open (FILE_HDL, "< a.txt")

        readline    read a line of text (use chomp $line to del the '\n')
            (ex $line = readline $fh)
                    returns 'undef' on end of file;

        "-"  STDIN: like unix filename "-"  means STDIO
        <>         (called 'angle operator') like readline   (ex $line = <$fh>)
                    has the file handle inside: <FILE_HDL>   when I used a literal open   open(FILE_HDL, "a.txt");
                                                <$fh>        when I used a var open       open(my $fs, "a.txt");
                   SCALAR context:   $l=<$fh>   read 1 line
                   LIST   context:   @l=<$fh>   read ALL the lines of the files in the array

                   <> (null inside) means read ALL-lines of ALL-files present in the command line (@ARGV)

                    while (<>) {            |     @ARGV = ("-") unless @ARGV; # assume STDIN if empty
                      # code for each line  |     while (@ARGV) {
                     ....                   |         $ARGV = shift @ARGV;
                    }                       |         if (!open(ARGV, '<', $ARGV)) {
                                            |             warn "Can't open $ARGV: $!\n";
                                            |             next;
                         equivalent to      |         }
                         this ------------> |         while (<ARGV>) {
                                            |             ...
                                            |             # code for each line
                                            |         }
                                            |     }

                    ex this works like a cat *.txt:
                            ls *.txt | xargs  perl -e 'while(<>) {print;}'

                    nb. as this magic can be used. I can set @ARGV to a list of files

                        and then call while (<>).
                    nb. As files are read as a happy single one, to manage num_lines
                        correctly, must be tested eof on each one.

        <>  OVERLOAD. An overload meaning of <> is FILE-glob: <*.txt>
                    when used in this case, it returns:
                         a single file at a time (in scalar context)  while (<*.txt>)
                         all the list of files in list context (  @f=<*.txt> )
                    It can be used also the equivalent explicit function 'glob'
                    glob ("*.txt")  scalar or list context in the same way.

        eof         TRUE on eof

               while(1) {                       |  while(!eof $fh) {         | while(<$fh>) {       |
                   $line = readline $fh;        |      $line = readline $fh; |     # process $_...  |
                   last unless defined $line;   |      ....                  | }                    |
                   ....                         |  }                         |                      |
               }                                |                            |                      |

               Each line (also blank lines) has a \n at the end, so it's never FALSE. When reaching the end
               it's returned 'undef' (= FALSE) so without expicit test against eof, while(<$fh>) is the best.

        STDIN / STDOUT / STDERR  (global constants)       print     is short for print STDOUT
                                                          <>        is short for <STDIN>
        -e "pippo.txt"           TRUE if file exists
        -d                            if a dir
        -f                            if a file
        -r                            if readable
        -w                            if writeable
        -x                            if exec
        -T                            if text file
        -C -A -M                      return in $^T ( $BASETIME ) th time of last Change, Access, Modif.
                                      number is a float, so use function int, if required
                                      Moreover if the file changed after the script started, it returns < 0
                                          next unless –M $file > .5;            # files are older than 12 hours
                                          &newfile if –M $file < 0;             # file is newer than process
                                          &mailwarning if int(–A) == 90;        # file ($_) was accessed 90 days ago today

                                      $^T = time;  <---- resets the script’s start time to now.

        Starting with v5.10, as a form of purely syntactic sugar, you can stack file test
        operators, making –f –w –x $file equivalent to –x $file && –w _ && –f _ .

        -------------
        |  chop / chomp
        -------------
        chop      removes last char of a string (whichever it is, [also not a \n])
        chomp     removes any sequence of end-record-markes (usually \n) to the end
                  and return the number removed. It's common this: chomp($l = <STDIN>);
--------------------------
REG EX
--------------------------
        <STRING>  =~   <PATTERN>       the =~ operator returns
                                         'true'  if <PATTERN> mathes <STRING>
                                         'false' otherwise
                                       Said otherwise, it evaluates a <PATTERN> in SCALAR context
                                       (see below what happens when a <PATTERN> is evaluated in LIST context)

        "Hello World" =~ /World/;  # matches

        2 rules: 1) FIRST match wins:
                    "Hello World" =~ /o/;         "That hat is red" =~ /hat/;
                         ^                          ^
                    $_ = "fred xxxxxxx barney";
                    s/x*//;                      it will have absolutely no effect!
                                                 because the x* will match the “nothing” at the beginning of the string.

                 2) matches as many as possible char. (greedy (avido))
                    In Modern Perl you can use ? to switch to nongreedy (as few characters as possible)
                    /.*?/

        !~              reverses =~     if ("Hello World" !~ /World/) { ...

        m<C> ... <C>    to use another char <C> as delimiter instead of //   ex. "Hello World" =~ m!World!
                        Useful when there are a lot of slashes, (to avoid to escape each).
                        ex. =~ m{///}              matches three literal forward slashes,
                            =~ s{^https?://}{}     removes the protocol part of a URL.

        $var            the values of the vars are substituted before the regexp is evaluated
                        $foo = 'house';   'cathouse' =~ /cat$foo/;   'housecat' =~ /${foo}cat/

        m//g (to find another match after the previous one)
              in SCALAR context is 1 at a time
              in LIST   context are all together

            if ($string =~ m/(\w+)\s+(\w+)/) {         # values in $1, $2,

                                     SCALAR context                      LIST context
                               --------------------------------------------------------------------
                               while($string =~ m/(\w+)/g) {          @all = $string =~ m/(\w+)/g;
                                 print "'".$1."'\n";
                                 }

        to SUBSTITUTE    =~ s///    s///g  (to subst. all. RETURNS the num of subst!)
            $string =~ s/[aeiou]//;       #del all vowels

            Instead of 3 char /// !!! if I chose a char of the 'bracket families'  <> () [] {}
            it can be written as 4 char where the second pair could be different: s{foo}(bar)
            and even with a space or a newline s{foo}
                                                (bar)
            s/// allows interpolation (usage of vars $a).
                 you can find the alternative equivalent versions  tr/// y/// that do the same
                 but with no allowed usage of $var in the pattern (they are just char substitution)

        //i    case insensitive
        //x    to contain whitespace \n comments :
                                                   "Hello world" =~ m/
                                                          (\w+) # one or more word characters
                                                          [ ]   # single literal space, stored inside a character class
                                                          world # literal "world"
                                                         /x;
        //a                    to keep your program from being needlessly exposed to full Unicode
                               input text can be only considered ASCII
        //aa                   even more restrictions
        //s                    even more restrictions


        <PATTER>  in LIST context  : it pulls out all the backreferences as a list
                               ex on "12:59:59 am"
                               my ($hour, $min, $sec, $ampm) = /(\d+):(\d+):(\d+) *(\w+)/;
                               my @hmsa = /(\d+):(\d+):(\d+) *(\w+)/;

        use re 'strict'        to be warned, as this find things that, while legal,
                               may not be what you intended.
        ()                     parentheses besides used to then refer the matched string with $1,$2, ..
                               they can also be used to apply a quantifier to more than one char:
                               /bam{2}/ bamm (ok) bambam (not) --> /(bam){2}/
        \1 \2                  similar to vi. I can refer to the mathed substring () while still in the regex
                               "<B>Bold</B>"  --> /<(.*?)>.*?<\/\1>/
                                                                ^
        Named Backreferences.  From v5.10 besides \1 and $1 (called Numbered Group) there are (named Group)

                               Where                  Numbered Group     Named Group
                               -------------------------------------------------------
                               Declare                ( ... )           (?<NAME> ... )
                               Inside same regex      \1                \k<NAME>
                               In regular Perl code   $1                $+{NAME}

                               ex. s/(?<alpha>\S+)\s+(?<beta>\S+)/$+{beta} $+{alpha}/
--------------------------
MODULEs / PACKAGEs
--------------------------
        MODULE:  a normal perl code file like .pl but .pm
                 It's intended to be included in another file, thus as it's read from top to bottom
                 it's required a return TRUE (so they end as "1;")

              require  AAA::BBB      'require' it's the keyword to include a file AAA/BBB.pm

              PERL5LIB : perl uses this var to know the list of dir to search into.
                         (usually so in .bashrc there is    export PERL5LIB=- : - : ...)
                         'relative' to each of them perl searches a file ./AAA/BBB.pm

        THE PROBLEM: having now a way to include files inside others, there is a problem as any included file
                     can have 1 or more other 'require', so when calling a function
                                       WHERE is it?
                     There could be even more with the same name, so
                                       WHICH is it?

        PACKAGE: it's a namespace.

                 each line of code written belongs to 1 package. At the beginnig of execution the package starts
                 in the 'main' pack. but each 'package' cmd changes it

              package  AAA::BBB     switch to a namespace AAA::BBB. Unfortunately it's used the same
                                    :: as separator, but here AAA::BBB must not be a file AAA/BBB somewhere!!!
                                    It only says all the code from now on belong to namspace AAA::BBB.
                                    So if a fun() is defined now, in any other place it will be called
                                    as AAA::BBB::fun(). Perl will open the file (whichever was the name)
                                    and executes fun().

        THE SOLUTION: to avoid possible mess, perl programmers use these 2 rules:
                      1. a 'package' cmd must never be in a .pl file
                      2. a  module.pm must always have 1 and only 1 'package' cmd with exactly its
                         relative pathname

---------------____________________

PACKAGES and NAMESPACES:   wherever it is, every LINE of CODE is inside 1 certain PACKAGE
                           called NAMESPACE. This way variables & functions can have the same name
                           if they are in 2 different PACKAGES.

'Package'                  The 'Package' directive starts a new Namespace, that will be considered
                           the 'current' till it will not be changed by another 'Package' cmd.

'main' Package             The default Namesace is 'main'.
                           It's the root Namespace, changed as soon as the first 'Package' cmd is found.

SYMBOL TABLE             - It's the set of (vars + functions) of 1 PACKAGE.
                           So there is 1 SYMBOL TABLE for 1 PACKAGE
                         - is a HASH table (where:
                               - (vars + functions)-NAMES are the string-keys,
                               - the value is the TYPE-globs associated( $xxxx, %xxxx, @xxxx )
                           The  HASH table name is  PACKAGE-NAME + '::'
                           '%main::'  can be written as only '%::'

ACCESSING A VAR            So to refer to a var $xxxx defined in a certain LINE of CODE
                           I must:
                               - discover which is the PACKAGE of that LINE of CODE
                               - access that HASH (%PACKAGE::) to have the xxxx-value
                                 ($PACKAGE::{"xxxx"})

                           ex:
                                 foreach $x (sort keys %main::) {
                                 local *i = $main::{$x};  <------------------------ using a TYPE-glob to match any type
                                        print "\$$x is defined\n" if defined $i;
                                        print "\@$x is nonnull\n" if @i;
                                        print "\%$x is nonnull\n" if %i;
                                 }

SYMBOL TABLES relations    1 SYMBOL TABLE (so a HASH %xxxxx::) can 'include' another SYMBOL TABLE, that is
                           implemented as a 'reference' to the other one.
                           "%main::" contains references to all the others (included itself, so be carefull
                           if programmatically parsing from %main::, as there is no end to
                                %main::main::main:: ...




PACKAGES are independent of files:
                  - You can have many packages in a single file,
                  - or a single package that spans several files,

MODULE:     1 module = 1 file .pm

'use'       the way you use a module is with the 'use' command,
            it is a COMPILER DIRECTIVE that controls the import of
                                 - subroutines
                                 - and variables
            from a module.
--------------------------
OO
--------------------------
                  "Perl is not a great language for OO programming.
                   Perl's OO capabilities were grafted on after the fact, and this shows."

        object: is a reference. To use it as a refence to a class "CLASSNAME" use 'bless'
                bless $o "CLASSNAME";  (it's like a cast in C)

        method: an object-method is a fun whose 1' arg is an object    (and can be called as $o-> fun()
                a  class -method is a fun whose 1' arg is a  pack name (            "       ex Package::Name-> fun())
                in both cases it ends as     '-> fun()'
                Perl has no private methods. Usually a method intended for private use is named with a leading '_'

        class:  is a package containing methods

        constructor: a class-method returning a new obj. It can have any name even if usually it's 'new'
                sub new {
                    my $class = shift @_;     <----- receiving a string like ex "CLASSNAME"
                    return bless { "legs" => 4, "colour" => "brown" }, $class;
                 }               ^
                                 here an anomym. ref to an HASH casted to "CLASSNAME"

                 ex.  $o = new Package::Name -> new();

        INHERITANCE:   use parent ("Animal"); <---------- to add in the son file (ex Koala.pm)
                       nb.  use parent accepts a list of parent class names, so Perl supports multiple inheritance,
                       (with all the benefits and horrors this entails).

--------------------------
BEGIN
--------------------------
        BEGIN blocks are ignored at execution time. They are executed during the 1st parsing of the
        file before parsing the rest. Even if they can be any number and anywhere in the file, put
        only 1 at the beginnng.

--------------------------
USE
--------------------------

         are respectively equivalent:
         ----------------------------------------|----------------------------|-------------------
         use Caterpillar ("crawl", "pup");       |   use Caterpillar ();      |   use Caterpillar;
         ----------------------------------------|----------------------------|-------------------
         BEGIN {                                 |   BEGIN {                  |   BEGIN {
             require Caterpillar;                |       require Caterpillar; |       require Caterpillar;
             Caterpillar->import("crawl", "pup");|   }                        |       Caterpillar->import();
         }                                       |                            |   }
         ----------------------------------------|----------------------------|-------------------

            nb. require Caterpillar      : loads a 'module' (a file named Caterpillar.pm)
                Carterpillar-> imnport() : calls a class-method ('package' Caterpillar)

                  so it works only if module and package respects the rule

            import: is not a built-in fun. It's a method that must be defined by the user
                    which any args and doing whatever.
                    The most common way to define an import() method is to inherit it from Exporter.pm
                    Exporter is a Perl core module.

--------------------------
EXPORTER
--------------------------
        import() In Exporter's implementation of import(), the list of arguments
                 is interpreted as a list of subroutine names
                 Those subs besides their original pack, become available also in the current pack
                 this means I can call them shortly as subx() instead the "longhand" AAA::BBB::subx()

        @EXPORT  it's a var in Exporter that can also contain a list of sub names
                                 our @EXPORT = ("crawl", "eat", "pup");
                 they are exported if import is called with no args:    import()


--------------------------
SYMBOL TABLEs / LEXICAL SCOPEs
--------------------------
varibale-names  are stored in memory in 2 different places, both called
"name-spaces", and then one space called "symbol tables" and the other
"lexical-scopes". Each space then allocates different sub-area for the
different 'sigil': so var of type $, @, %, &, go in separate area
(that's the reason why $a @a %a &a do not conflict each other)

lexical scopes: store 'local' vars.
                That is, vars inside blocks { }, of type
                my, our, state.
symbol tables:  called also 'package' var, store 'global vars.

qualified name: is the long name of a var that allows to distinguish from others

                ex. $Santa::Helper::Reindeer::Rudolph::nose  <---- 1 name = {many 'term'}
                      ^       ^         ^       ^       ^
                     term    term      term    term    term

Name Lookups:   is the process that Perl uses to find from the simple term (ex. $a)
                the qualified name. It is:

                        1. starts searching in the lexical scope of that block
                        2. goes on upper blocks
                        3. goes to the largest possible lexical scope (compilation unit)
                           that is:
                              - the file (normally)
                              - the STRING passed to an 'eval': in this case
                                is still is not found in the runtime STRING, Perl
                                restart from point 2, considering the lexical scope
                                of the block where the 'eval' is written.

                        4. pass to search for global vars, searching again from point 1 to 3
                           but for the nearest 'package' instruction which will be
                           prepended to the front of the variable.
                        5. If there is no package declaration in any surrounding lexical scope,
                           Perl looks for the variable name in the unnamed top-level package,
                           (called 'main')
--------------------------
GRAMMARS - TERMS & OPERATORS
--------------------------
term     HIGHEST precedence!!!
         they are:
                 . vars
                 . quoted ops (any kind)  <--- A fun is nothing but an operator with args inside (): f (...)
                 . braces     (any kind)                                                              \___ 'operator'

operators:
      01 - Terms and List Operators (Leftward)
      02 - The Arrow Operator                          : on the right there are not [] {} or ()
      03 - Autoincrement and Autodecrement             : ++ only (not --) has some magic on strings
                                                         incrementing the char
                                                         $a = "a9";   ++$a;  "b0"
                                                         $a = "Az";   ++$a;  "Ba"
                                                         $a = "zz";   ++$a;  "aaa"
      04 - Exponentiation                              : binds even more tightly than unary minus, so –2**4 is –(2**4)
      05 - Unary Operators                             : ! + - ~
      06 - Binding Operators
      07 - Multiplicative Operators
      08 - Additive Operators
      09 - Shift Operators
      10 - Named Unary and File Test Operators
      11 - Relational Operators
      12 - Equality Operators
      13 - Smartmatch Operator
      14 - Smartmatching of Objects
      15 - Bitwise Operators
      16 - C-Style Logical (Short-Circuit) Operators
      17 - Range Operators
      18 - Conditional Operator
      19 - Assignment Operators
      20 - Comma Operators
      21 - List Operators (Rightward)
      22 - Logical and, or, not, and xor
      23 - C Operators Missing from Perl



--------------------------
USEFUL MODULES
--------------------------
CPAN: Comprehensive Perl Archive Network

                       The CGI.pm module comes with Perl, so you should be able to read its documentation:
                                $ perldoc CGI

ExtUtils::MakeMake:      comes with Perl. It handles a module instalation by:
                     $ perl Makefile.PL
                 $ make install

                 $ perl Makefile.PL INSTALL_BASE=/Users/fred/lib        # option INSTALL_BASE for another dir

Module::Build:      another way to install a module:
                 $ perl Build.PL
                 $ ./Build install

                 $ perl Build.PL --install_base=/Users/fred/lib

CPAN.pm:            come with Perl to manage when modules depends on others.
                     $ perl -MCPAN -e shell

                    It can be a little complicated, so a while ago was written a little script 'cpan'


cpan:      The cpan command that comes with Perl can create an autobundle, (a list of everything you
           have installed, along with the version numbers:
                                                             $ cpan -a

                                               $ cpan Module::CoreList LWP CGI::Prototype

bundle :   A file that some CPAN clients can use to reinstall everything you already have installed,
           either on the same machine or a different machine

cpanm:     it doesn’t come with Perl  (download from http://xrl.us/cpanm)
           Once you have cpanm, you simply tell it which module to install:
              $ cpanm DBI WWW::Mechanize\

local::lib:  to keep additional Perl modules in their own directories (having no permission to install in Perl dir)
             (download from CPAN as doesn’t come with Perl)
              $ perl  -Mlocal::lib
            export  PERL_LOCAL_LIB_ROOT="/Users/fred/perl5";
            export  PERL_MB_OPT="--install_base /Users/fred/perl5";
            export  PERL_MM_OPT="INSTALL_BASE=/Users/fred/perl5";
            export  PERL5LIB="...";
            export  PATH="/Users/brian/perl5/bin:$PATH";


            $ cpan -I Set::Crossproduct     <---- option -I  for cpan   when used the above dir settings

            $ cpanm --local-lib HTML::Parser  <--  with the cpanm way

      set this in your CPAN.pm configuration, it adds them every time it tries to install a module.
            $ cpan
            cpan> o conf makepl_arg INSTALL_BASE=/Users/fred/perl5
            cpan> o conf mbuild_arg "--install_base /Users/fred/perl5"
            cpan> o conf commit


      use local::lib;            # to write inside your Perl program so that it finds local modules.
                                 # During compilation, Perl sees that line and loads the module

perldoc:   perldoc File::Basename       # to see information on what the module does.
use ....:
           use File::Basename                 # import and load some functions
                                                use 'perldoc File::Basename' to see which.
           use File::Basename qw/ /;          # import without loading ....
           use File::Basename ();             # ... ALL the functions

           use File::Basename qw/ basename /; # import and load only 1 function (here 'basename'

           my $dirname = File::Basename::dirname $name; # call here a fucntion ('dirname') with full name.

File::Spec
            use File::Spec;

            my $new_name = File::Spec->catfile($dirname, $basename); # use od -> as it's a CLASS

CGI.pm      To make all the CGI stuff easy (do not reinvent the wheel. Use what it's tested and debugged)

            use CGI qw(:all);                             <------ load all functions from CGI module
            print header(),
            start_html("This is the page title"),
            h1( "Input parameters" );
            my $list_items;
            foreach my $param ( param() ) {
               $list_items .= li( "$param: " . param($param) );
            }
            print ul( $list_items );
            print end_html();

DBI.pm      Once you install DBI , you also have to install a DBD (Database Driver, from the long
            list on CPAN [the version ok for your server]).

            use DBI;
            $dbh = DBI->connect($data_source, $username, $password);

            my $sth = $dbh->prepare("SELECT * FROM foo WHERE bla");
            $sth->execute();
            my @row_ary = $sth->fetchrow_array;
            $sth->finish;

            $dbh->disconnect();

Dates and Times
            my $dt = DateTime−>from_epoch( epoch => time );

            print $dt−>ymd;            # 2011−04−23
            print $dt−>ymd('/');       # 2011/04/23
            print $dt->ymd('');        # 20010423

            y $dt1 = DateTime->new(
               year => 1987,
               month => 12,
               day => 18,
            );
            my $dt2 = DateTime->new(
               year => 2011,
               month => 5,
               day => 1,
            );
            my $duration = $dt2 - $dt1;

            my @units = $duration->in_units( qw(year month day) );
            printf '%d years, %d months, and %d days', @units;       # 23 years, 4 months, and 14 days

--------------------------
INSTALL MODULES
--------------------------
'distributions'                 is the name how 'packages' are called in CPAN
                                they are a tar.gz file containing 1 or more .pm
                                in a dir-tree structure

'intstall by hand'              download the tar.gz, unpack and run

                                          BUILD.PL         or if there is Makefile.PL

                                       1. perl Build.PL             1. perl Makefile.PL
                                       2. ./Build                   2. make
                                       3. ./Build test              3. make test
                                       4. ./Build install           4. make install

                                at step 2. the compilation create the .pm files in a dir .blib
                                at step 4 (the .pm files are copied into a dir of @INC) that can
                                be specified as --installdirs option at step 1)
                                perl Makefile.PL PREFIX=/home/me/perl INSTALLDIRS=perl


install in a specific dir:      ex. you are not root and cannot write in system dir
                                       perl Makefile.PL PREFIX=~/lib LIB=~/lib
                                change ~/lib to a preferred value

'dependencies'                  the module M, needs module A, which needs B, ....
                                to avoid installing all by hand, use CPAN client like cpan or newer cpanm

'cpan'                          is already available in core perl distribution.
                                Anyhow you can update as >cpan CPAN

~/.cpan ~/.cpanm                are the default dir used by cpan and cpanm
                                to created a repository.
                                The configuration file is usually stored in
                                    ~/.cpan/CPAN/MyConfig.pm
                                and it's something like:
                                    $CPAN::Config = {
                                         '...' =>  q[...]   ex 'http_proxy' => q[],
                                         '...' =>  q[...]      'prefer_installer' => q[MB],
                                    };
                                    1;
prefer_installer                MB means that if there are both a Makefile.PL and a Build.PL
                                the command 'make' must act as a simple wrapper around the Build.PL
                                (so actually running always Build.PL)

cpan[1]>                        Once run the command 'cpan', I'm inside the cpan shell
                                and that is the prompt.
     -o conf                    command to edit the MyConfig.pm through the cpan shell.
     -o conf commit             to save the changes
     -h                         for the help
     -o conf init               to see all the values (and the meaning!!) of each param.
                                nb. I see the 'current' value not the 'factory' default.
                                To see the original value, rename MyConfig.pm,
                                and run -o conf init like it was the first time.

--------------------------
MORE PERL versions on the same PC
--------------------------
The already installed PERL version (RedHat, Ubuntu, ...) arrived customized
and it's better not to mess it up. The vendor's system perl scripts are tested agaist that.
To install a different version download the perl.gz distribution and run its 'Configure'
with the required -Dprefix=... (ex -Dprefix=${HOME}/perl_vers/5.10.1/)

PERL5LIB :      this env variable must be set when I need to add additional dirs besides @INC.
                Perl does not require that the PERL5LIB variable be set.
                Typically, the variable will not be set to any value.
                Anyhow I can set PERL5LIB so that Perl looks for modules in a private directory.

       % export PERL5LIB=~/my_debug_lib
       % mkdir -p ~/my_debug_lib/Net/
       % cp `perldoc -l Net::SMTP` ~/my_debug_lib/Net/.
       % vi ~/my_debug_lib/Net/SMTP.pm

local::lib     this module can be downloaded and compiled with its option --bootstrap=
                   $ perl Makefile.PL --bootstrap=~/.perl  <---- set here the dir you want
                   $ make test && make install
               and allows to have an archive of CPAN Modules in the specified dir.
               It's behavoìiour is to print the required variables (e.g. PERL5LIB)
               and the command is usually:

                   perl -I$HOME/.perl/lib/perl5 -Mlocal::lib=$HOME/.perl

               which prints:
                   export MODULEBUILDRC="/home/you/.perl/lib/perl5/.modulebuildrc" <---- vars used by Module::Build and
                   export PERL_MM_OPT="INSTALL_BASE=/home/you/.perl/lib/perl5"      <--- ExtUtils::MakeMaker when they need to target
                   export PERL5LIB="/home/you/.perl/lib/perl5/lib/perl5:$PERL5LIB"       a tree on a MODULE installation
                   export PATH="/home/you/.perl/lib/perl5/bin:$PATH"

              you can add those lines in ~/.bashrc as
              echo 'eval $(perl -I$HOME/.perl/lib/perl5 -Mlocal::lib=$HOME/.perl)' >> ~/.bashrc

perlbrew      to manage multiple Perl installations in your $HOME directory.
              They are completely isolated perl universes.

              Install as   sudo apt-get install perlbrew                 <----- works but as root then
              or           \curl -L http://install.perlbrew.pl | bash    <----- works for user
                                                                                is installed as
                                                                                ~/perl5/perlbrew/bin/perlbrew


              then install a Perl distribution as  perlbrew install perl-5.16.0

              perlbrew list        to see the installed versions

              to switch to a Perl version:
              perlbrew switch perl-5.16.0  (works for ANY shells: PERMANENT, till a new switch or use)
              perlbrew use    perl-5.16.0  (works   temporarily  on current shell only)



--------------------------
DEBUGGERS
--------------------------

            perl5db.pl


strict / warnings:    use use use  use them:                % perl -Mstrict -Mwarnings program

print:
       print "The value of var before is [$var]\n"     # use braces to limit values of a var (to see also spaces)

       warn "The value of var after is [$var]";        # use var to have also line no
                                                       # The value of var before is [...] at program.pl line 123

       Carp                                            # alternative warn and die for modules

       use Data::Dumper qw(Dumper);                    # use Data::Dumper to print Objects and limit with < .. >
       warn "The value of the hash is <\n" . Dumper( \%hash ) . "\n>";

Hook::LexWrap::wrap :    Encapsulates a function in a wrapper and allows to inspect args and ret val.

       use Hook::LexWrap qw(wrap);
       my $n = shift @ARGV;
       my $m = $ARGV[0];
       wrap add,
           pre  => sub { print "I got the arguments: [@_]\n" },
           post => sub { print "The return value is going to be $_[-1]\n"
       ;
       print "The sum of $n and $m is " . add( $n, $n ) . "\n";    # <----- this is the error ( passing 2 n)
       sub add {
                  my( $n, $m ) = @_;
                  my $sum = $n + $m;
                  return $sum;
       }

perl -d :    normal perl debugger (% perl -d add_numbers.pl 5 6)


Alternative Debuggers :    Are all under Devel::
                        - Devel::Trace                % perl -d:Trace program.pl
                        - Devel::ptkdb  <--- GREAT    % perl -d:ptkdb program.pl
                        - Devel::ebug                 % perl -d:ebug  program.pl
                        - Devel::hdb    mini web server (its web interface, lets me debug on a remote server)

IDE        -  EPIC       (Eclipse Perl Integration) is the Perl plug-in for Eclipse.
           -  Komodo     (started on Microsoft. Now available on Solaris, Linux, and Mac)
                          handles Perl as well as other languages, (Tcl, Ruby, PHP, Python)



---------- Perl 4ed Oreilly [2012] - PREFACE

   name:  PERL = Practical Extraction and Report Language

   CAMEL:  a camel is a horse designed by a committee

   key features
        - PORTABLE: more than C / C++ / JAVA / ...
                    on Windows and Unix

   - WEB SITE: perl.org
   - CPAN    : cpan.org   (lot of more FAST mirrors: cpan.org/SITES.html)
                          (both ftp / HTTP                              )
   - Perl Folks: perlmonks.org.

   - SUPPORTED RELEASES: 2  (the current and the previous)
               they are even num.
               ex. If last is 5.18 --> [5.18 + 5.16]
                                        5.14 is the 1' UN-supported

   - DOWNLOAD + INSTALL
               Besides a already installed Perl version, others version can
               be installed and compiled with different options (and where
               store libs)
               1. wget http://www.cpan.org/src/5.0/maint.tar.gz
               2. tar zxf
               3. sh Configure -des     (assumes DEFAULT answers)
               4. make test && make install  (requires sudo privil.)
      to test other vers. without sudo privil.
      install from CPAN App::perlbrew
               1. curl –L http://xrl.us/perlbrewinstall | bash      (download + install)
               2. ~/perl5/perlbrew/bin/perlbrew install perl–5.14.2
                                         ^        ^         ^
                                       exec.    inst.    of perl v.5.14

   - DOCUMENTATION  there is a "perldoc"  cmd besides the normal "perl"
                    try "perldoc perl"

            1  perl         What perl manpages are available        Perlfaq1     General questions about Perl
            2  perldata     Data types                              Perlfaq2     Obtaining and learning about Perl
            3  perlsyn      Syntax                                  Perlfaq3     Programming tools
            4  perlop       Operators and precedence                Perlfaq4     Data manipulation
            5  perlre       Regular expressions                     Perlfaq5     Files and formats
            6  perlvar      Predefined variables                    Perlfaq6     Regular expressions
            7  perlsub      Subroutines                             Perlfaq7     General Perl language issues
            8  perlfunc     Built-in functions                      Perlfaq8     System interaction
            9  perlmod      How perl modules work                   Perlfaq9     Networking
           10  perlref      References
           11  perlobj      Objects
           12  perlipc      Interprocess communication
           13  perlrun      How to run Perl commands, plus switches
           14  perldebug    Debugging
           15  perldiag     Diagnostic messages

           “ perl –V:man.dir ”   To see the value to set in MANPATH in the UNIX man doesn't go properly.

---------- Perl 4ed Oreilly Ch1
           =            <---- a line started with a '='
           =cut               start a pod section up to a '=cut'
                              a way to have 'muli-line comments


           $x = $y <--- rvalue  (value on the r-ight)
            ^
            lvalue (because in a value on the l-eft)


           $x = $y + 1
            ^   ^^^^^^
         lvaluw      a temporary value built by 2 rvalues
                     and put on a 'stack'
                     The pushes and pops all balance out
                     by the time the expression is done

         names : are defined as ? xxxxx
                                ^
                                called sigil can be
                                        $ for scalar   $foo
                                        @ for array    @foo  (no conflict with $foo or %foo)
                                        % for hash     %foo  (no conflict with $foo or @foo)
                                        * for any ($,@,%) is called typeglob like in bash
                                                          it matches all
        reserved words: they are usually lowercase

        xxxxx   the actual identifier can be formed by
                - up 251 symbols [_0-9a-Z] but also
                  unicode (~ 100k symbols). When using Unicode
                  add a line 'use utf8'  at the beginning, to say to the Perl compiler
                  that through the code there are Unicode chars

        all the terms that starts with a sigil ($,@,%) cannot be confused
        with reserved words (so ex $for is a possible name, for the same
        reason a var $123 is ok)
        Terms with no leading sigil (ex. label or FILE handle, or package names)
        it's better to start with an UPPERCASE so still they cannot be confused.

        BAREWORDs      any term not quoted "" that is not recognized as
                       a reserved word, is then assumed as a STRING (quoted)
                       use strict "subs" in a scope to force quoting
                       a (no strict "subs") in a inner scope can turn it off
                       thus put (use v5.12;) in the top most file.

        __XXX__        reserved literals:
                       __LINE__    as in C
                       __FILE__    as in C
                       __PACKAGE__ the package in which that line of code is compiled
                       __END__     mark end of script to compiler (any further text is ignored)
                       __DATA__

        SYMBOL TABLES: the names that belong to SYMBOL TABLES are the global
                       var, also called PACKAGE VARs. They live inside their package,
                       and are so fully qualified by the :: path and so are
                       accessible from outside with the long full name
        LEXYCAL VAR:   are local var, whose scope is ex. a function body
                       they are identified by keyords: local, my, our, state.
                       (our usually to avoid)
                       The largest LEXYCAL scope is the file. Any lexycal scope
                       var is never seen outside that file.

        HERE doc       It's a way to set a STRING with a 'document' inline
                       that starts from a specified <<keyowrd up to the same keyword

                       print <<SSS;   print<<'SSS';    print<<"SSS"         print<< ;
                       .....             with ''         with ""                   ^ a space (deprecated)
                       SSS            SSS              SSS                           go up to 1st blank line (I can avoid any SSS)


                       print <<"" x 10               print << x 10                     print <<"SSS", <<"TTT";
                          10 times this line            10 times this line             ....
                                                     (with space)                        SSS           I can 'stack' many
                                                     (deprecated)                      ...
                                                                                         TTT

                       print (<<SSS);                             ($quote = <<'SSS') =~ s/^\s+//gm;
                       .....       the brace if I like                   I indented this text
                       SSS                                               with the code, so I remove the spaces
                                                                  SSS


                      my @a = <<SSS;                              my @a = <<SSS =~ m/(\S.*\S)/g;
                       .....       I assign to an array            .....       I assign to an array removing spaces
                       SSS                                         SSS




---------- Perl 4ed Oreilly Ch2
---------- Perl 4ed Oreilly Ch3
---------- Perl 4ed Oreilly Ch4
---------- Perl 4ed Oreilly Ch5
---------- Perl 4ed Oreilly Ch6
---------- Perl 4ed Oreilly Ch7
---------- Perl 4ed Oreilly Ch8
---------- Perl 4ed Oreilly Ch9
---------- Perl 4ed Oreilly Ch10
---------- Perl 4ed Oreilly Ch10
---------- Perl 4ed Oreilly Ch12
---------- Perl 4ed Oreilly Ch13
---------- Perl 4ed Oreilly Ch14
---------- Perl 4ed Oreilly Ch15
---------- Perl 4ed Oreilly Ch16
---------- Perl 4ed Oreilly Ch17
---------- Perl 4ed Oreilly Ch18
---------- Perl 4ed Oreilly Ch19
---------- Perl 4ed Oreilly Ch20
---------- Perl 4ed Oreilly Ch21
---------- Perl 4ed Oreilly Ch22
---------- Perl 4ed Oreilly Ch23
---------- Perl 4ed Oreilly Ch24

\d      matches a Unicode digit, not just [0-9] but also other Unicode math digits (ARABIC INDIC symbols)
\D      is a negated \d; [^\d]
\s      matches a whitespace character, the set [\ \t\r\n\f] and others
\S      is a negated \s; [^\s]
\w      matches a word character (alphanumeric or _), not just [0-9a-zA-Z_] but also other Unicode digits
\W      is a negated \w; [^\w]
.       matches any character but "\n"
\N      like '.' but it does so regardless of whether the modifier //s is in effect.
\b      word anchor, matches a boundary between a word char and a non-word char  /cat\b/;  # matches cat in 'housecat'
\b{wb}  light form of \b for natural language (ex. apostrophes are included in words, like in "don't")


---------- Perl 4ed Oreilly Ch25
---------- Perl 4ed Oreilly Ch26
---------- Perl 4ed Oreilly Ch27
---------- Perl 4ed Oreilly Ch28
---------- Perl 4ed Oreilly Ch29



//a              to match inside the ASCII subset of Unicode.
                 Ex \d in ASCII is only [0-9] while in Uniocde
                 matches other matemathical digits (ex. ARABIC INDIC)
                 so use /\d/a
//aa             When using ignorecase //i, Perl must consider UPPERCASE Uniocode val
                 and lowercase Uniocde val. If one val (UPPER or lower) is in ASCII range and
                 the other is not, when testing with //ia as one macthes, the result is true.
                 To restrict on these cases use //iaa
//s   //m        stand for single-line multi-line and they determine whether a string
                 is to be treated as one continuous string, or as a set of lines.
                 They affect 1) how the '.' is defined, 2) where ^ and $ are able to match.

                              .                ^                                   $
                 //      any != \n        only 1st char of ALL STR    only last char of ALL STR
                 //s     any (also \n)    only 1st char of ALL STR    only last char of ALL STR
                 //m     any != \n        any STR start               any STR end or before \n
                 //sm    any (also \n)    any STR start               any STR end or before \n

                 regardless of all the cases with
                      \A is always  "only 1st  char of ALL STR"
                      \Z is always  "only last char of ALL STR (with or without \n)"
                      \z is always  "only last char of ALL STR (different from  \n)"




                 the ASCII val, it matches
                 (so matching also



                 to match inside the ASCII subset of Unicode.


---------- plenv
1. install plenv
           git clone https://github.com/tokuhirom/plenv.git ~/.plenv
           put it in $PATH:                                            echo 'export PATH="$HOME/.plenv/bin:$PATH"' >> ~/.bash_profile
           add `penv init` in bash_profile                             echo 'eval "$(plenv init -)"' >> ~/.bash_profile
           install pre-build                                           git clone https://github.com/tokuhirom/Perl-Build.git ~/.plenv/plugins/perl-build/
           plenv rehash

2. install 5.18.2
           plenv install 5.18.2 -Dusethreads                           (the  -Dusethreads is required so that then a perl --V will show a x86_64-linux-thread-multi)

3. set it as the default one
           plenv local 5.18.2

4. install cpanm
           plenv install-cpanm

3. with cpanm install ubic
           cpanm Ubic                     (if it fails:  cpanm Ubic --force)

3. with ubic see which services are off
           ubic status





------------ redirect debugger output (to a file)
once in the debugger (at the prompt), set a 'pager':
 o pager=">my_file"
 or ">>" to append
 then execute the command to save with a pipe ahead
 |c
 |x %big_var


