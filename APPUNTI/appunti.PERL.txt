namespaces:
pragma: special Modules (ex. use strict)
                             use v5.10    <--- version of Perl: includes many features 
                                               ex. say wrt print (which adds a \n for me)






PERL SPECIAL VARs
     Most of the special vars have an english long name (ex, $! =  $OS_ERROR)
     Remember to add a line "use English;"

_____________ SCALAR

     LONG NAME 

$_     $ARG                            The default 
                                                  - input (the line read from a file)
                                                  - pattern-searching space.  
                                                  - built-in iterator used instead of normal $i in a for / foreach ... 
                                       In other words, if you read from a file at the top of a 
                                       while, for or foreach 
                                       $_ is set up for you. 
                                       Then any regular expression matches, chops (and lcs and many more) 
                                       without a parameter, and even prints assume you want to work on $_. Thus:
                                       it can be omitted:  

                                           while ($line = <FH>) {          while (<FH>) {
                                             if ($line =~ /Perl/) {          /Perl/ and
                                                 print FHO $line;                print FHO ;
                                             }                               print uc;
                                             print uc $line;               }
                                           }

                                          ex1        print foreach @array;
                                          ex2        foreach ( @array ) { next unless defined; }
                                          ex3        --b{(/(\w+)/)[0]}  <----  1. \w+ : returns the first word matched in $_
                                                                               2. (..)  it's managed in a list context
                                                                               3. [0]   it's the 1st (and only) el of the list
                                                                               4. b{..} it's the key to enter hash b
                                                                               5. --    that hash entry is decremented
                                                                      

$.     $NR                             The current input line num of the last filehandle that was read. 
                                       An explicit close on the filehandle resets the line number.
$/     $RS                             The input record separator; newline by default. 
                                       If set to the null string, it treats blank lines as delimiters.
$,     $OFS                            The output field separator for the print operator.
$\     $ORS                            The output record separator for the print operator.
$"     $LIST_SEPARATOR                 Like "$," except that it applies to list values interpolated into 
                                       a double-quoted string (or similar interpreted string). 
                                       Default is a space: $a = join( $", @ARGV );   .
$;    $SUBSCRIPT_SEPARATOR             The subscript separator for multidimensional array emulation. Default is "\034".
$^L   $FORMAT_FORMFEED                 What a format outputs to perform a formfeed. Default is "\f".
$:    $FORMAT_LINE_BREAK_CHARACTERS    The current set of characters after which a string may be broken 
                                       to fill continuation fields (starting with ^) in a format. Default is "\n"".
$^A   $ACCUMULATOR                     The current value of the write accumulator for format lines.
$#    $OFMT                            Contains the output format for printed numbers (deprecated).
$?    $CHILD_ERROR                     The status returned by the last pipe close, backtick (``) command, or system operator.
$!    $OS_ERROR or $ERRNO              If used in a numeric context, yields the current value of the errno variable, 
                                       identifying the last system call error. 
                                       If used in a string context, yields the corresponding system error string.
$@    $EVAL_ERROR                      The Perl syntax error message from the last eval command.
$$    $PROCESS_ID or $PID              The pid of the Perl process running this script.
$<    $REAL_USER_ID or $UID            The real user ID (uid) of this process.
$>    $EFFECTIVE_USER_ID or $EUID      The effective user ID of this process.
$(    $REAL_GROUP_ID or $GID           The real group ID (gid) of this process.
$)    $EFFECTIVE_GROUP_ID or $EGID     The effective gid of this process.
$0    $PROGRAM_NAME                    Contains the name of the file containing the Perl script being executed.
$[                                     The index of the first element in an array and 
                                       of the first character in a substring. 
                                       Default is 0.
$]    $PERL_VERSION                    Returns the version plus patchlevel divided by 1000.
$^D   $DEBUGGING                       The current value of the debugging flags.
$^E   $EXTENDED_OS_ERROR               Extended error message on some platforms.
$^F   $SYSTEM_FD_MAX                   The maximum system file descriptor, ordinarily 2.
$^H                                    Contains internal compiler hints enabled by certain pragmatic modules.
$^I   $INPLACE_EDIT                    The current value of the inplace-edit extension. Use undef to disable inplace editing.
$^M                                    The contents of $M can be used as an emergency memory pool in case Perl dies 
                                       with an out-of-memory error. 
                                       Use of $M requires a special compilation of Perl. 
                                       See the INSTALL document for more information.
$^O   $OSNAME                          Contains the name of the operating system that the current Perl binary was compiled for.
$^P   $PERLDB                          The internal flag that the debugger clears so that it doesn't debug itself.
$^T   $BASETIME                        The time at which the script began running, in seconds since the epoch.
$^W   $WARNING                         The current value of the warning switch, either true or false.
$^X   $EXECUTABLE_NAME                 The name that the Perl binary itself was executed as.
$ARGV                                  Contains the name of the current file when reading from <ARGV>.

_____________ ARRAY

@_ $#_        is the list of incoming parameters to a sub. 
              If the array name is '_' so its elem 0 is $_[0] the second is $_[1] and so on. 
              And you can refer to $#_ as the index number of the last parameter:
@ARGV         The array containing the command-line arg for the script.
@INC          The array containing the list of places to look for Perl scripts to be evaluated by the do, require, or use constructs.


_____________ HASH

%INC          The hash containing entries for the filename of each file that has been included via do or require.
%ENV          The hash containing your current environment. Ex. $ENV{PATH}  # /usr/local/bin:/usr/bin:/sbin:/usr/sbin
%SIG          The hash used to set signal handlers for various signals.

         


_____________ FILEHANDLES

ARGV          The special filehandle that iterates over command line filenames in @ARGV. 
              Usually written as the null filehandle in <>.
STDERR        The special filehandle for standard error in any package.
STDIN         The special filehandle for standard input in any package.
STDOUT        The special filehandle for standard output in any package.
DATA          The special filehandle that refers to anything following the __END__ token 
              in the file containing the script. 
              Or, the special filehandle for anything following the __DATA__ token 
              in a required file, as long as you're reading data in the same package __DATA__ was found in.
_             (underscore) The special filehandle used to cache the information 
              from the last stat, lstat, or file test operator.

$|    $OUTPUT_AUTOFLUSH          If set to nonzero, forces an fflush(3)
                                 after every write or print on the currently selected output channel.
$%    $FORMAT_PAGE_NUMBER        The current page number of the currently selected output channel.
$=    $FORMAT_LINES_PER_PAGE     The current page length (printable lines)
                                 of the currently selected output channel. Default is 60.
$-    $FORMAT_LINES_LEFT         The number of lines left on the page
                                 of the currently selected output channel.
$~    $FORMAT_NAME               The name of the current report format for the currently selected output channel.
                                 Default is the name of the filehandle.
$^    $FORMAT_TOP_NAME           The name of the current top-of-page format for the currently selected output channel.
                                 Default is the name of the filehandle with _TOP appended.
_____________ CONSTANTS

__END__       Indicates the logical end of your program. 
              Any following text is ignored, but may be read via the DATA filehandle.
__FILE__      Represents the filename at the point in your program where it's used. 
              Not interpolated into strings.
__LINE__      Represents the current line number. Not interpolated into strings.
__PACKAGE__   Represents the current package name at compile time, or undefined 
              if there is no current package. Not interpolated into strings.

_____________ REGULAR EXPRESSION

$digit                    usual $1 $2 $3 ...
$&   $MATCH               The string matched by the last successful pattern match.
$`   $PREMATCH            The string preceding whatever was matched by the last successful pattern match.
$'   $POSTMATCH           The string following whatever was matched by the last successful pattern match.
$+   $LAST_PAREN_MATCH    The last bracket matched by the last search pattern. 
                          This is useful if you don't know which of a set of alternative patterns was matched. 
                          For example: /Version: (.*)|Revision: (.*)/ && ($rev = $+);



--------------------------
PERL DISTRIBUTIONs     (http://perldoc.perl.org/perlpolicy.html)
--------------------------                      ^^^^^^^^^^
only the last 2 are supported
    ex. 5.20   5.22     
when is released 5.24,
5.20 will be no more supported.

--------- 
INSTALL                                                       another way is perlenv
---------                         |                              /
 > tar zxf latest.tar.gz          | install from  CPAN App::perlbrew <----- allows to have more PERL versions 
 > cd perl–5.22.2                 |                                         and switch between them
 > sh Configure –des              | ~/perl5/perlbrew/bin/perlbrew install perl–5.22.2
 > make test && make install      |
 
       enhanced distributions wrt standard one:
          - ActivePerl  free Win/Mac/Linux   $ Unix (Solaris..)
          - Strawberry       Win only
          - Citrus      free  Win/Mac/Linux  bundles wxPer to distribute app with GUI
 
 
 
 



 perl -MData::Dumper -e 'print Dumper \@INC'      to see the INC value.
                                                  also a simple     perl -V
                                                  or even           perl -E "say @INC"

                                                  to add a path in INC ex to use A::B
                                                  perl -I A  (<--- it's the dir)
                                                  or inside the code (use lib "/.../.../A";  or use lib qw((...)
                                                                      use A::B;)
                                                  nb. I can also push on the array @INC:
                                                      push(@INC, (...))
                                                      but in such a way, my dirs will be searched 
                                                      as last option, that is not what I want.

--------------------------
START A SCRIPT
--------------------------

       for portability (not sure where perl is located) 
                   #!/usr/bin/env perl
       as normally env is always in /usr/bin/env 
               ________________________________
               |                              |
       #!/usr/bin/perl                  #!/usr/bin/perl                  
       print "Hello, world!\n";         use 5.010;     <-----------
                                        say "Hello World!";   <------ say put '\n'


--------------------------
SIGILs   (the reserved symbols for the type of var)
--------------------------
Scalar      $   stays for the S of Scalar
Array       @   stays for the A of Array
Hash        %   a pair of ° (separated by a /) indicating key/value
Typeglob    *   *struck  (Everything named struck)
Subroutine  &   before v5 it was &fun() to call a user-defined function fun()
                wrt buil-in function (ex print()) that don't want it.
                Now it's optional. It must be used only when assigning the name
                of the function to a reference: $r=\&fun;

nb. 'glob' is the nick name for *. ('globally') In the unix shell it means FILE-glob,
     all files in a dir. TYPE-glob means all entries in a Symbol Table.

symbol table: where the compiler remembers symbols (variables, filehandles, and subroutines) 
              A table, which is implemented in Perl using a hash table. 
              1 symbol table for each package to give its own namespace.
--------------------------
SCALAR VARIABLES
--------------------------
            can contain
                1. undef      <-----   ANY scalar var before any assignment is automatically init with value 'undef'
                2. a number
                3. a string  (concatenated with '.')
                4. a reference
                5. a file handle
                
        In Perl, the operator\function determines both 
          - the context: SCALAR / LIST
          - the TYPE for scalars: (string / num)
        For example $x + $y is always a numeric addition of 2 SCALAR, 
        and if $x or $y do not contain numbers, an attempt is made to convert them to numbers first.
        ($x == $y I'm comparing 2 nums,  $x eq $y I'm comparing 2 strings)

    Operators are:
        # Numerical operators:  <,  >, <=, >=, ==, !=, <=>, +, *
        # String operators:    lt, gt, le, ge, eq, ne, cmp, ., x
        nb. x for string. (ex. print "–" x 80;)
            in list context instead of the strings, it replicates the list.
            This is useful to init an array or hash
                              @ones = (1) x 80;      #init with 80 1
                              @ones = (5) x @ones;   #change all 80 to 5
                              @keys = qw(aaa bbb ccc);
                              @h{@keys} = ("") x @keys;    #h{aaa}="", h{bbb}="", h{ccc}=""


        my $str1 = "4G";
        my $str2 = "4H";

        print $str1 .  $str2; # "4G4H"
        print $str1 +  $str2; # "8" with two warnings
        print $str1 eq $str2; # "" (empty string, i.e. false)
        print $str1 == $str2; # "1" with two warnings
        print "yes" == "no";  # "1" with two warnings; 
                                    both values evaluate to 0 
                                    when used as numbers
   
    __________________________________
    |    INTERPOLATION   (string with " and ')
    |__________________________________
        is the term used by Perl (bash uses 'string substitution')
        to specify that in "---val of $a"   $a is replaced by its value
        "" performes INTERPOLATION
        '' suppresses  ...

        As in bash ' is STRONG quote:
        print "Hello \$string"; # "Hello $string"
        print 'Hello $string';  # "Hello $string"

        nb. ' is a valid —though archaic— character 
            replaced by the more visually distinct :: . That means that
            $main'var and $main::var are the same thing.
    __________________________________
    |    notes on  N U M
    |__________________________________
    |arbitrary precision on numbers: to have it, add 
    |    use bigint, bigrat or bignum
    |    or at command line -M... 
    |    ex >perl -Mbigrat -E 'say 10/3 == 1/3*10 ? "Y":"N"' ---> Y
    |
    | literals used as ravlue in $x = ... can use 
    |        0x.. ( for hex) 
    |        0... (     oct) 
    |        0b.. (     bin)
    |        _    (ex 4_294_967_296)
    |
    | Automatic conversion from string (ex "0x56f") to num (1391)
    | not works for these formats:
    |     $a = 0x56f   + 1   #1392 ok
    |     $a = "0x56f" + 1   #1    NOT OK
    |     $a = 071   wrt "071"    
    |          0b111 wrt "0b111"   
    |          1_004 wrt "1_004"
    | So these numeric literals  CANNOT be used if the rvalue
    | comes from another source (ex an input string)
    | In that case use an explicitly conversion 
    |              hex("0x56f")
    |              oct("071")
    |              oct("0b111") <---- nb. for binary I still use oct!!!       OCT for all!
    |              oct("0x56f") <---- nb. for hex    I can still use oct!!!   OCT for all!
    |_________________________________
    __________________________________
    |    notes on  S T R I N G
    |__________________________________
    |   $var is INTERPOLATED inside ".."
    |   that means "aaa $var bbb"  is the same as "aaa".$var."bbb"
    |   where I can avoid to use explicit concatenatios with '.'
    |   INTERPOLATION woks only for $scalar and @array NOT %hash
    |   for array means concatenate all el with a $" (usually a space)
    |   print "@a"  is like  $a = join( $", @ARGV ); print $a;   
    |   
    |   {} can be used to better separate a var ex "aaa${var}rrr"  without is a mess "aaa$varrrr"
    |   this because a var inside {} is forced to a be a STRING
    |   that's why in a HASH $h{"feb"} is the same written as $h{feb}
    |   Sometimes the short syntax is ambygous so an explict "" is required
    |   $h{27 feb}  #error    $h{"27 feb"}  #ok
    |   
    |   {} is also better to use in a reg. exp.
    |   ex /${foo[bar]}/  better than only  /$foo[bar]/  
    |   where [bar] could be intended as range of 3 letters b a r
    |_________________________________
-------
lower UPPER case
-------
    there are interesting escape sequences
        \l  \u              lower UPPER case only the following char
        \L   \U .... \E       "    "     "   ALL the chars up to \E (optional if till the end)
    ex
        $a="arREFD67hhff"; $b="\U$a\E";    #ARREFD67HHFF  also only $b="\U$a";

    the usage is normally in regex
        $a="ID"; print (($a=~/\Uid/) ? "yes" : "no")   #yes
-------
q qq qw qx  
-------
     They are the alternative to:

     ''    q   (NO   interpolation, as they are '') 
     ""    qq  (YES     "         ) qq/a b c/ --> "a b c" <--- a SCALAR: $a=qq..
     ``    qx  (YES     "         ) execute a command  
     ()    qw  (NO      "         ) qw/a b c/ --> ("a", "b", "c") <-- a LIST: @a=qw..
                                        ^ ^           ^    ^            ^
                                      spaces          commas            $a=qw/a b c/ returns "c"
                                                                        that is a LIST evaluated as a SCALAR
  nb. any not alphanum char is OK as separator
      ex. q//   q()     q!!

  qr   is the last of the family. It can define a PATTERN as
       a string var, to use later in pattern match.
       ex
            $re = qr/$pattern/;
            $s =~ /foo${re}bar/;    # can be interpolated in other patterns
            $s =~ $re;              # or used standalone
            $s =~ /$re/;            # or this way

-------
BAREWORD
-------
   unquoted terms (ex. print hello;) should be avoided, as error prone.
   a way is:
            use strict "subs";
   that has anyhow the limits of:
            - lasts its scope only
            - a    no strict "subs";    can turn it effects off
   so the best is to write (at least)
            use v5.12;
--------------------------
BOOLEAN VARIABLES
--------------------------
            A scalar is 'false' when:

            1. undef
            2. number 0
            3. string ""
            4. string "0".

            nb. "0.00"    is true   (not "" neither "0")
                "0.00" +0 is false  (+ is num-operator so string is converted to num and result is 0)
     
     Boolean operators are both &&  ||  !       from C       + precedence over ,
                                and or  not     from BASIC   -    "            ,

     Both works as short-circuit, which means the evaluation
     is stopped as soon as possible. Any remaining right part is not conisdered.
     Besides the precedence the 2 families behave identically.


--------------------------
ARRAY
--------------------------
            my @array = (
                "print",
                "A",
                "B", # <-- last comma is ok
            );

            print $array[0]; # "print"
            print $array[1]; # "A"
            print $array[2]; # "B"
            print $array[3]; # returns undef, prints "" and raises a warning

    - negative indices to retrieve from the end

            print $array[-1]; # "B"
            print $array[-2]; # "A"
            print $array[-3]; # "print"
            print $array[-4]; # returns undef, prints "" and raises a warning

    - add on demand (no dimension required on declaration, like in C)
            my @home;
            $home[0] =  "couch";
            $home[1] =  "chair";

    - len
            scalar @array
            $#array

    - slice of arrays
            @days[3, 4, 5]     Array slice containing ($days[3], $days[4], $days[5])
            @days[4..6]        Array slice containing ($days[4], $days[5], $days[6])

    - print 
            it's interpolated into strings
            print "@array";        # "print A B"
                
--------------------------
HASH
--------------------------
            a list of scalars indexed by strings. 

   keys:    are always STRING
   values:  are SCALAR (: string or numbers)

   Linguistically, a hash relationship is genitive or possessive, ( “of” in English)
   The wife of Adam is Eve: $wife{"Adam"} = "Eve";

undef:   accessing a key that not exits or accessing outside 
         the hash gives  'undef'

            my %scientists = (                  %h = ('foo', 35, 'bar', 12.4, 2.5, 'hello',
                "Newton"   => "Isaac",                'wilma', 1.72e30, 'betty', "bye\n");
                "Einstein" => "Albert",         
                "Darwin"   => "Charles",        $h{'foo'}    = 36;            # modify a key already present 
            );                                  $h{'fred'}   = 'flintstone';  # add 2 keys new ...
                                                $h{'barney'} = 'rubble';      # ... not present before
            => is called a "fat comma"    
            syntactic sugar which allows to not use ','
            and see the key/value with ease.

            print $scientists{"Newton"};   # "Isaac"
            print $scientists{"Einstein"}; # "Albert"
            print $scientists{"Darwin"};   # "Charles"
            print $scientists{"Dyson"};    # returns undef, prints "" and raises a warning

            We have seen that {} is a STRING operator, that forces what inside to be a STRING
            so you can omit quotes:  $hash{key} instead of $hash{"key"} 
            ("" are required if the key has spaces).

    - HASH into SCALAR   $s = %H
            $s = 0   if the HASH is EMPTY. Usefull in tests!!
            otherwise (HASH not EMPTY) return a vale x/y (ex 5/8) which is
            the situation of the hash table (5 used buckets on a total of 8 available)

    - slice of hashes
            Given a HASH %H, a subset %h could be identified by a LIST of keys, ex ("a", "b", "f") or better qw/a b f/
            An instruction like H{ qw/a b f/} is the array of values so it's @H{ qw/a b f}
            To have a hash it's:

            my %h;
            @h{qw/a b f/} = @H{qw/a b f/};     or   with the map function    my %h = map { $_ => $H{$_} } qw/a b f/;

            Starting with Perl 5.20.0 it's possible the same short form as array:
                 my %h = %H{qw/a b f/};

    - array to hash
            I used this trick to convert an array 
            (where i loaded the lines of a file: @lines=<$fh> <--- 1 single command)
            into and hash: 
            %lines = map { $_ => 1 } @lines;   
            the lines are the keys and the values (useless) are all 1.
            This can be usefull for fast serach/test: 
                 if (exists $lines {$k}) {
            

----------- HASH FUNCTIONS 
keys / values: they return 2 ARRAYs
             my @k = keys   %hash;        N.B. order not assured:  k[0] could be any and so on
             my @v = values %hash;                   

exist:  if (exists $books{"dino"}) {   # Test if such a key is presnt

delete: delete $books{$person};        # Remove that pair key / value

reverse: %ip_address = reverse %host_name;
                               create a new has were the keys are
                               the values of the first, and the values
                               are the old keys.
                               N.B. as keys must be unique, if old hash
                               had equal value for different keys, they overwrite
                               each others(: the later items in the list
                               overwrite any earlier ones).

while / foreach:
            while ( ($key, $value) = each %hash ) {  | foreach $key (sort keys %hash) { 
                 print "$key => $value\n";           |  print "$key => $hash{$key}\n";
            }                                        | }
         
----------- OLD MULTDI-DIM EMULATION
A feature was originally implemented to support a2p, the awk-to-Perl trans-
lator. It allows to emulate a multi-dim hash with the syntax of a list of keys
inside { }, (separated by commas) : %h { k1, k2, k3}. They form a super-key
that is the string with all the key concatenated with the special var $;  
       %h { k1, k2, k3} =  %h { join $; => $k1, k2, k3}

 perl -e 'print $;' | od -c    # 034
--------------------------
ARRAY & HASH
--------------------------
            [ ]: square brackets to retrieve from an array. 
                 they are effectively a numerical operator 
                 as each elem is identified by a num, it can be sayed they
                 are ORDERED list
            { }: braces to retrieve from a hash. 
                 they are effectively a string operator. 
                 (are UNORDERED list)
            
           The fact that the index supplied is a number or a string 
           is of absolutely no significance:

               my $data = "orange";
               my @data = ("purple");
               my %data = ( "0" => "blue");

               print $data;      # "orange"
               print $data[0];   # "purple"
               print $data["0"]; # "purple"
               print $data{0};   # "blue"
               print $data{"0"}; # "blue"

           Hash is just an array with an even pair of elements, separated
           in pairs with the comma ',' and inside the pair with the fat comma '=>'
           
           So you can convert a hash to an array with twice as many entries, 

                my @scientists = %scientists;
           
           nb.  The order is not guaranted. 
                They will be returned in whatever order is more efficient.
                It's only guaranted that each key comes before its value. 

--------------------------
LIST
--------------------------
            Is a sequence of values separated by  
                  , 
            or
                  =>           #Remember that => is just , (fat comma)
            enclosed in ( )
            That are the braces not used 
            neither by the array [] nor by the hash {}.
            A list is not a variable. 
            A list is an ephemeral value which can be assigned to 
            an array or a hash variable. This is why the syntax 
            for array and hash is identical. 

            The following are just lists. Identical lists.
            ("one",   1, "three",   3, "five", 5)
            ("one" => 1, "three" => 3, "five" => 5)

     empty list:  ()
             can be used to declare an empty array or an empty hash 

     list assignments: are called the assignments like:
             my ($a, $b, $c) = @x;   # assign to scalars val from an array
             ($a, $b) = ($b, $a);    # swap 2 vars

     List values cannot be nested.            |Perl has no way of knowing so 
             my @array = (                    |it manages it as a single long list.
                           "apples",          |
                           "bananas",         |print $array[0]; # "apples"
                           (                  |print $array[1]; # "bananas"
                               "inner",       |print $array[2]; # "inner"
                               "list",        |print $array[3]; # "list"
                               "several",     |print $array[4]; # "several"
                               "entries",     |print $array[5]; # "entries"
                           ),                 |print $array[6]; # "cherries" 
                           "cherries",        |
                        );                    |

             The same is true whether the fat comma is used or not:

                    my %hash = (
                        "beer" => "good",           raises a warning because the hash 
                        "bananas" => (              was declared using a 7-element list 
                            "green"  => "wait",
                            "yellow" => "eat",
                        ),
                    ); 
             this makes it easy to concatenate multiple arrays together:

                my @bones   = ("humerus", ("jaw", "skull"), "tibia");
                my @fingers = ("thumb", "index", "middle", "ring", "little");
                my @parts   = (@bones, @fingers, ("foot", "toes"), "eyeball", "knuckle");

             Nesting is acted with references.
--------------------------
CONTEXT
--------------------------
            Perl code is context-sensitive. 
            Every expression is evaluated in scalar or list context, 
            depending on whether it is expected to produce a scalar or a list. 

          - A scalar assignment 
                     my $scalar = 
            evaluates in scalar context. 

          - An array or hash assignment 
                     my @array = 
                     my %hash  = 
            evaluates in list context. 

          - A scalar evaluated in list context 
            is silently converted into a 1-element list:

               my @array = "Mendeleev"; 
               # same as 'my @array = ("Mendeleev");'

          - An array evaluated in scalar context 
            returns the len:

               my @array = ("Alpha", "Beta", "Gamma", "Pie");
               my $scalar = @array;
               print $scalar; # "4"

          - A list expression (a list is different from an array, remember?) 
            evaluated in scalar context returns 
                    not the len of the list 
            but 
                    the final scalar in the list:

            my $scalar = ("Alpha", "Beta", "Gamma", "Pie");
            print $scalar; # "Pie"

          - A list-assignment evaluated in scalar context returns 
            the number of list elem. assigned
            if (my ($k,$v) = $string =~ m/(\w+)=(\w*)/) {
                         1.  =~  has higher precedence wrt =
                         2.  in list context =~ returns the strings matched
                         3.  =, the list-assignemtn is done
                         4.  as it's done in scalar context, if(), it returns 2 the num of elem list assigned
                             ex. DB<1> $a="aaa bbb"
                                 DB<2> $s=my($k,$v)=$a=~/(\w+) (\w+)/
                                 DB<3> p $s    2

            ------- example with nested array
            ARRAY and HASH, as depend on list, cannot be nested.
            my @outer = ("......, ....); 
            my @inner = ("Earth", "Moon");

            $outer[3] = @inner; <-- an array evaluated in scalar context
                                    so returns its len.
            print $outer[3]; # "2"

   nb.      when the compiler parses the code, it figures out the context
            and generates the proper binary opcode. Later, at runtime 
            those internal opcodes are actually interpreted in that context.
--------------------------
REFERENCES
--------------------------
            Perl uses references to allow building complex data struct.
            (nesting scalar array and hash in whatever order)
            A ref is a scalar.

        CREATE a ref:  use '\' before the var you want to refer

            my $colour        = ....;
            my @colours       = (...);
            my %atomicWeights = (...);

            my $scalarRef = \$colour;
            my $arrayRef  = \@colours;
            my $hashRef   = \%atomicWeights;

        ACCESS its value: use {} around
                          if it's not ambiguous, you can omit {}
                          while for array and hash you can also use -> 

                          nb.  We have seen that {} is a STRING operator, 
                               that forces what inside to be a STRING
                               it's the way to have the "name" of the pointed var:

                               perl -e '$b=2; $a=b; print "$a = ${$a}\n"'   # b = 2
                                
                               and here I never used a reference syntax.

                          nb.  symbolic reference: is what I've used above:
                          a var whose value is the name of another var or subroutine. 
                          Symbolic references are illegal under use strict "refs" .
                               perl -e 'use strict "refs"; $b=2; $a=b; print "$a = ${$a}\n"'
                               Can't use string ("b") as a SCALAR ref while "strict refs" in use at -e line 1.

            print ${ $scalarRef };   or only        print $$scalarRef;

            print $colours[0];       # direct array access
            print ${ $arrayRef }[0]; or only        print $arrayRef->[0];   

            print $atomicWeights{"Helium"}; # direct hash access
            print ${ $hashRef }{"Helium"};  or only print $hashRef->{"Helium"};    

        ___________________________________________
        | ANONYMOUS ARRAY and HASH  (and function)
        |
        |    Use [ ] for an anonymous ARRAY and 
        |        { } for an anonymous HASH. 
        |    The value returned in each case is a REFERENCE:
        |___________________________________________

      my $ary = \@myarray;    # reference to a named array                   my $ary = [1,2,3,4,5];            # reference to an unnamed array
      my $hsh = \%myhash;     # reference to a named hash                    my $hsh = {Na => 19, Cl => 35};   # reference to an unnamed hash
      my $sub = \&mysub;      # reference to a named subroutine              my $sub = sub { print $state };   # reference to an unnamed subroutine
      
      
      ----------------------------------------------------------------------------------------------
             declaration                                         retrieve back
      ----------------------------------------------------------------------------------------------
           my %o1 = (                     |                                   |               |            
               "name" => "Santa Claus",   |           (6 instruct.)           |  (5 instr.)   |  (3 instr.)
               "DOB"  => "1882-12-25",    |                                   |               |
           );                             |   my $r    = $account{"owners"};  |  ...          |  -
                                          |   my @o    = @{ $r  };            |  -            |  = @{ $account{"owners"} };
           my %o2 = (                     |   my $r1   = $o[0];               |  = $r->[0];   |  -
               "name" => "Mickey Mouse",  |   my $r2   = $o[1];               |  = $r->[1];   |  .
               "DOB"  => "1928-11-18",    |   my %o1    = %{ $r1 };           |  ...          | = %{ $o[0] };  
           );                             |   my %o2    = %{ $r2 };           |  ...          | = %{ $o[1] };  
                                          |                                   |               |
           my @o = ( \%o1, \%o2 );        |   $account{"number"}              |               |
                                          |   $account{"opened"}              |               |
           my %account = (                |                                   |               |
               "number" => "12345678",    |   $o1{"name"}   $o1{"DOB"}|       |               | 
               "opened" => "2000-01-01",  |   $o2{"name"}   $o2{"DOB"}|       |               | 
               "owners" => \@o,           |                                   |               |
           );      ^
                   |    
                 %account is the first 'struct' that we see.
                 HASH comes ready to define a C-like-struct
                 the 'members' are the key names and the values are their type.

            
      ----------------------------------------------------------------------------------------------
             long form                                           short
      ----------------------------------------------------------------------------------------------
      my $owner1Ref = {                              |  my %account = (
          "name" => "Santa Claus",                   |      "number" => "31415926",
          "DOB"  => "1882-12-25",                    |      "opened" => "3000-01-01",
      };                                             |      "owners" => [
                                                     |          {
      my $owner2Ref = {                              |              "name" => "Philip Fry",
          "name" => "Mickey Mouse",                  |              "DOB"  => "1974-08-06",
          "DOB"  => "1928-11-18",                    |          },
      };                                             |          {
                                                     |              "name" => "Hubert Farnsworth",
      my $ownersRef = [ $owner1Ref, $owner2Ref ];    |              "DOB"  => "2841-04-09",
                                                     |          },
      my %account = (                                |      ],
          "number" => "12345678",                    |  );
          "opened" => "2000-01-01",                  
          "owners" => $ownersRef,
      );
--------------------------
TYPEGLOBS
--------------------------
    they are aliases to GLOBAL vars (not lexicals or local).
    Said otherwise thy refer to entries in (global) Symbol tables.
    ex.
         $a = *G;   (or better: *a=\*G)
    means when now I write $a @a %a I'm accessing Symbol table entries
                           $G @G %G
    if I write $a = \$G;  is $a for $G but not @a %a for @G %G.
    
    Around Typeglob is built the import mechanism of global vars between 2 modules
    somethings hidden normally to developer:
                local *Here::blue = \$There::green;
    
--------------------------
CONDITIONALS
--------------------------
      if () {cmd}               unlike C, { } are always required even for 1 single cmd.
      cmd  if ()
      if  - elsif  - else       unlike C there is 'elsif'
      unless (A) - else         try to avoid 'unless' block as it's the same as 
                                if (not A)  - else
      ? a : b

  LABEL: ....                   we can use   next LABEL        (like the C 'continue')
                                             last              (like the C 'break')
--------------------------
SWITCH
--------------------------
switch has been introduced only from version 5.10 and must anyhow 'imported'

    use v5.10;                                   | alternative way (ex for perl < 5.10)
    use feature qw(switch); <----- optional      | 
    use feature qw(:5.10);  <----- optional      |         for ($string) {
                                                 |             /abc/ and do {$abc    = 1; last;};
    given ($item) {                              |             /def/ and do {$def    = 1; last;};
    when (/a/)     { say "Matched an a" }        |             /xyz/ and do {$xyz    = 1; last;};
    when (/42/)    { say "Matched a 42" }        |             $nothing = 1;
    when (/"bee"/) { say "Matched a bee" }       |        }
    when (/\d+\w*/){ say "Matched a regex" }     
    default {  ;  }             \___________nb I can use literal, string, number, regex
    }                                          


--------------------------
LOOPS
--------------------------
            the C-style 'for' is considered old-fashion.
            Where possible use the 'foreach' which can iterate over an ARRAY.

            foreach my $i ( @array ) { print $i; }  <---- the foreach evaluates in LIST context what inside ()
                                                          so a scalar is considered a list of 1

      range operator '..':

            foreach my $i ( 0 .. $#array ) { print $i, ": ", $array[$i]; }

            It's NOT possible to iterate over an HASH, 
            BUT the way it's to use the 'keys' fun which return the ARRAY of keys
            and iterate on that.
            
            foreach my $k (keys %hash) { print $k, ": ", $hash{$k}; }
                            ^

            SORT:  Since a hash has no underlying order, 
            the keys may be returned in any order. Use the sort 

            foreach my $k (sort keys %hash) { print $k, ": ", $hash{$k}; }
                            ^

      $_  (default iterator):  is the first of the built-in variables. Allows
                               to not used a var (usual $i) as iterator in the loop

                                       foreach ( @array ) { print $_; }

            which can also be written 

                                       print $_ foreach @array;

     foreach --> for   as the syntax is anyhow different instead of foreach
                       you can substitute nowadays a simple shorter 'for'.

     nb. Note that the loop variable refers to the real element, not a copy.
         Hence, modifying the loop variable also modifies the original array.

      next, last: are the equivalent of break/continue. A label is optional
                  HERE: while () { ....
                                  next HERE;
                                  last HERE; <-- ex to exit many inner levels

      while  () {}
      untill () {}
      do {} while ();


--------------------------
ARRAY FUNCTIONS
--------------------------
            pop      : pop     @stack;    returns the last  
            push     : push    @stack;    append a new el at last pos
            shift    : shift   @stack;    returns the 1' el
            unshift  : unshift @stack;    insert a new el in 1' pos

            splice   : splice(@stack, index, len, "a", "b", ...)    returns the subarray in @stack
                                                                    of len elements starting at index (included)
                                                                    if there are other arguments (here "a", "b", ...)
                                                                    that LIST is also substituted inside @stack 
                                                                    which thus, 'loses' a slice but in its place
                                                                    gets another subarray.

                     all pop/.../unshift are 4 simple cases of splice
 
            join     : join("..", @a)   concat el of @a with the separator provided (1' string arg)
            reverse  : - in list-  context   returns a list in revers order. reverse ("a1","b2") -> (b2, a1)
                       - in scalar-context   first concat all the list as 1 single string 
                                             then returns the reversed string. scalar reverse "  -> "2b1a" 
            map      : map { .. $_ } @a;     returns an array from @a where each el (_$) has been
                                             modified by the instruct inside the {}
                                             ex map { uc $_ } @a;   convert any el in UPPERCASE
            grep     : grep { ..$_ } @a;     returns an array from @a where each el ($_) is added or not
                                             depending if the test on it { ..$_} is true or false
                                             It can be used to test if an el is present in @a
                                             scalar grep { $_ eq "..." } @a   #"1"/true
            sort     : sort @a               returns an array sorting @a alphabetically
                       sort { $a .. $b } @a  sort @a according to the instruct inside {} that operate
                                             on the built-in var named really $a and $b!!!!!!!!
                                             If I need more code the function can be somewhere else:
                                              sort comparator @a;
                                             anyhow it must always return -1 / 0 / +1
--------------------------
SUB
--------------------------
            sub func {
            }

            - subroutines always accept a LIST of scalars. 
                         - that LIST may of course have a single element, or be empty
                         - a single scalar is taken as a LIST with a single element. 
                         - a hash with N elements is taken as a LIST with 2N elements.

            - arg are passed by ref. (so a change is on the original)
            - func (..)  but also fun ..      brackets are optional, 
              anyhow it should ALWAYS be invoked 
              using brackets, even when called with no arguments
            - args are accessible using the built-in array variable @_

              sub func {             |            |              |
                                     |            |              |
                  my $a = shift @_;  | = shift ;  |    = $_[0];  |   multiple scalar assignment                        
                  my $b = shift @_;  | = shift ;  |    = $_[1];  |   my ($a, $b, $c) = @_;                         
                  my $c = shift @_;  | = shift ;  |    = $_[2];  |                            
                        ...
            - It's possible to call passing an HASH, as it's always a list
              but allow the most similar 'parameter' name convenition

              func ("oldString" => "pod", "width" => 10, "padChar" => "+");

              and then 'unpack' the HASH as a double size array where keys are the arg names:

              sub left_pad {
                my %args = @_;
                   ^
                my $newString = ($args{"padChar"} x ($args{"width"} - length $args{"oldString"})) . $args{"oldString"};
              return $newString;
              }

--------------------------
FILE
--------------------------
            As said it's the last possible value for a SCALAR.
            It's the value retrived with function 'open'
            my $result = open my $fh, "<", "pippo.txt";     $result is FALSE on errors
            close $fh  # to close
                                                        ___file name ("a.txt")
                                                       /   
        the general form is with 3 args   open (1  2  3)
                                                |  \_______mode: "<"   to read    "-|"   input pipe
                                                |                ">"   to write   "|-"   output pipe
                                                |                ">>"  to append
                                                |                "< :encoding(UTF–8)"  it's possible to specify the ecncoding
                                                '                ">> :encoding(MacRoman)"
                                                 \ 
                                                  \________file handle, a literal open (FILE_HDL ..)
                                                                        a var     open (my $fh   ..) <-- better

        It's possible (not recommended!) to merge 2 and 3:  open (FILE_HDL, "< a.txt")

        readline    read a line of text (use chomp $line to del the '\n')
            (ex $line = readline $fh)
                    returns 'undef' on end of file;

        "-"  STDIN: like unix filename "-"  means STDIO
        <>         (called 'angle operator') like readline   (ex $line = <$fh>)
                    has the file handle inside: <FILE_HDL>   when I used a literal open   open(FILE_HDL, "a.txt");
                                                <$fh>        when I used a var open       open(my $fs, "a.txt");
                   SCALAR context:   $l=<$fh>   read 1 line
                   LIST   context:   @l=<$fh>   read ALL the lines of the files in the array 

                   <> (null inside) means read ALL-lines of ALL-files present in the command line (@ARGV)

                    while (<>) {            |     @ARGV = ("-") unless @ARGV; # assume STDIN if empty
                      # code for each line  |     while (@ARGV) {
                     ....                   |         $ARGV = shift @ARGV;
                    }                       |         if (!open(ARGV, '<', $ARGV)) {
                                            |             warn "Can't open $ARGV: $!\n";
                                            |             next;
                         equivalent to      |         }
                         this ------------> |         while (<ARGV>) {
                                            |             ...
                                            |             # code for each line
                                            |         }
                                            |     }

                    ex this works like a cat *.txt:
                            ls *.txt | xargs  perl -e 'while(<>) {print;}'

                    nb. as this magic can be used. I can set @ARGV to a list of files

                        and then call while (<>). 
                    nb. As files are read as a happy single one, to manage num_lines
                        correctly, must be tested eof on each one.

        <>  OVERLOAD. An overload meaning of <> is FILE-glob: <*.txt>
                    when used in this case, it returns:
                         a single file at a time (in scalar context)  while (<*.txt>)
                         all the list of files in list context (  @f=<*.txt> )
                    It can be used also the equivalent explicit function 'glob'
                    glob ("*.txt")  scalar or list context in the same way.

        eof         TRUE on eof

               while(1) {                       |  while(!eof $fh) {         | while(<$fh>) {       |
                   $line = readline $fh;        |      $line = readline $fh; |     # process $_...  |
                   last unless defined $line;   |      ....                  | }                    |
                   ....                         |  }                         |                      |
               }                                |                            |                      |

               Each line (also blank lines) as a \n at the end, so it's never FALSE. When reaching the end
               it's returned 'undef' (= FALSE) so without expicit test against eof, while(<$fh>) is the best.

        STDIN / STDOUT / STDERR  (global constants)       print     is short for print STDOUT
                                                          <>        is short for <STDIN>
        -e "pippo.txt"           TRUE if file exists
        -d                            if a dir
        -f                            if a file
        -r                            if readable
        -w                            if writeable
        -T                            if text file

        -------------
        |  chop / chomp
        -------------
        chop      removes last char of a string (whichever it is, [also not a \n])
        chomp     removes any sequence of end-record-markes (usually \n) to the end
                  and return the number removed. It's common this: chomp($l = <STDIN>);
--------------------------
REG EX
--------------------------
        <STRING>  =~   <PATTERN>       the =~ operator returns
                                         'true'  if <PATTERN> mathes <STRING>
                                         'false' otherwise
                                       Said otherwise, it evaluates a <PATTERN> in SCALAR context
                                       (see below what happens when a <PATTERN> is evaluated in LIST context)

        "Hello World" =~ /World/;  # matches

        2 rules: 1) FIRST match wins:
                    "Hello World" =~ /o/;         "That hat is red" =~ /hat/;
                         ^                          ^
                    $_ = "fred xxxxxxx barney";
                    s/x*//;                      it will have absolutely no effect! 
                                                 because the x* will match the “nothing” at the beginning of the string.

                 2) matches as many as possible char. (greedy (avido))
                    In Modern Perl you can use ? to switch to nongreedy (as few characters as possible)
                    /.*?/

        !~              reverses =~     if ("Hello World" !~ /World/) { ...
        
        m<C> ... <C>    to use another char <C> as delimiter instead of //   ex. "Hello World" =~ m!World!
                        Useful when there are a lot of slashes, (to avoid to escape each). 
                        ex. =~ m{///}              matches three literal forward slashes, 
                            =~ s{^https?://}{}     removes the protocol part of a URL.
        
        $var            the values of the vars are substituted before the regexp is evaluated
                        $foo = 'house';   'cathouse' =~ /cat$foo/;   'housecat' =~ /${foo}cat/

        m//g (to find another match after the previous one)
              in SCALAR context is 1 at a time
              in LIST   context are all together

            if ($string =~ m/(\w+)\s+(\w+)/) {         # values in $1, $2, 

                                     SCALAR context                      LIST context
                               --------------------------------------------------------------------
                               while($string =~ m/(\w+)/g) {          @all = $string =~ m/(\w+)/g;
                                 print "'".$1."'\n";
                                 }

        to SUBSTITUTE    =~ s///    s///g  (to subst. all. RETURNS the num of subst!)
            $string =~ s/[aeiou]//;       #del all vowels

            Instead of 3 char /// !!! if I chose a char of the 'bracket families'  <> () [] {}
            it can be written as 4 char where the second pair could be different: s{foo}(bar)
            and even with a space or a newline s{foo}
                                                (bar)
            s/// allows interpolation (usage of vars $a). 
                 you can find the alternative equivalent versions  tr/// y/// that do the same
                 but with no allowed usage of $var in the pattern (they are just char substitution)

        //i    case insensitive
        //x    to contain whitespace \n comments :
                                                   "Hello world" =~ m/
                                                          (\w+) # one or more word characters
                                                          [ ]   # single literal space, stored inside a character class
                                                          world # literal "world"
                                                         /x;
        //a                    to keep your program from being needlessly exposed to full Unicode
                               input text can be only considered ASCII
        //aa                   even more restrictions 
        //s                    even more restrictions 


        <PATTER>  in LIST context  : it pulls out all the backreferences as a list
                               ex on "12:59:59 am"
                               my ($hour, $min, $sec, $ampm) = /(\d+):(\d+):(\d+) *(\w+)/;
                               my @hmsa = /(\d+):(\d+):(\d+) *(\w+)/;

        use re 'strict'        to be warned, as this find things that, while legal, 
                               may not be what you intended.
        ()                     parentheses besides used to then refer the matched string with $1,$2, .. 
                               they can also be used to apply a quantifier to more than one char:
                               /bam{2}/ bamm (ok) bambam (not) --> /(bam){2}/
        \1 \2                  similar to vi. I can refer to the mathed substring () while still in the regex
                               "<B>Bold</B>"  --> /<(.*?)>.*?<\/\1>/
                                                                ^
        Named Backreferences.  From v5.10 besides \1 and $1 (called Numbered Group) there are (named Group)

                               Where                  Numbered Group     Named Group
                               -------------------------------------------------------
                               Declare                ( ... )           (?<NAME> ... )
                               Inside same regex      \1                \k<NAME>
                               In regular Perl code   $1                $+{NAME}

                               ex. s/(?<alpha>\S+)\s+(?<beta>\S+)/$+{beta} $+{alpha}/
--------------------------
MODULEs / PACKAGEs
--------------------------
        MODULE:  a normal perl code file like .pl but .pm 
                 It's intended to be included in another file, thus as it's read from top to bottom
                 it's required a return TRUE (so they end as "1;")

              require  AAA::BBB      'require' it's the keyword to include a file AAA/BBB.pm

              PERL5LIB : perl uses this var to know the list of dir to search into.
                         (usually so in .bashrc there is    export PERL5LIB=- : - : ...)
                         'relative' to each of them perl searches a file ./AAA/BBB.pm

        THE PROBLEM: having now a way to include files inside others, there is a problem as any included file
                     can have 1 or more other 'require', so when calling a function 
                                       WHERE is it? 
                     There could be even more with the same name, so 
                                       WHICH is it?
         
        PACKAGE: it's a namespace.

                 each line of code written belongs to 1 package. At the beginnig of execution the package starts
                 in the 'main' pack. but each 'package' cmd changes it

              package  AAA::BBB     switch to a namespace AAA::BBB. Unfortunately it's used the same
                                    :: as separator, but here AAA::BBB must not be a file AAA/BBB somewhere!!!
                                    It only says all the code from now on belong to namspace AAA::BBB.
                                    So if a fun() is defined now, in any other place it will be called
                                    as AAA::BBB::fun(). Perl will open the file (whichever was the name)
                                    and executes fun().

        THE SOLUTION: to avoid possible mess, perl programmers use these 2 rules:
                      1. a 'package' cmd must never be in a .pl file
                      2. a  module.pm must always have 1 and only 1 'package' cmd with exactly its 
                         relative pathname
        
--------------------------
OO
--------------------------
                  "Perl is not a great language for OO programming. 
                   Perl's OO capabilities were grafted on after the fact, and this shows."

        object: is a reference. To use it as a refence to a class "CLASSNAME" use 'bless'
                bless $o "CLASSNAME";  (it's like a cast in C)

        method: an object-method is a fun whose 1' arg is an object    (and can be called as $o-> fun()
                a  class -method is a fun whose 1' arg is a  pack name (            "       ex Package::Name-> fun())
                in both cases it ends as     '-> fun()'
                Perl has no private methods. Usually a method intended for private use is named with a leading '_'

        class:  is a package containing methods

        constructor: a class-method returning a new obj. It can have any name even if usually it's 'new'
                sub new {
                    my $class = shift @_;     <----- receiving a string like ex "CLASSNAME"
                    return bless { "legs" => 4, "colour" => "brown" }, $class;
                 }               ^                                
                                 here an anomym. ref to an HASH casted to "CLASSNAME"

                 ex.  $o = new Package::Name -> new();

        INHERITANCE:   use parent ("Animal"); <---------- to add in the son file (ex Koala.pm)
                       nb.  use parent accepts a list of parent class names, so Perl supports multiple inheritance, 
                       (with all the benefits and horrors this entails).

--------------------------
BEGIN
--------------------------
        BEGIN blocks are ignored at execution time. They are executed during the 1st parsing of the 
        file before parsing the rest. Even if they can be any number and anywhere in the file, put 
        only 1 at the beginnng.

--------------------------
USE
--------------------------

         are respectively equivalent:
         ----------------------------------------|----------------------------|-------------------
         use Caterpillar ("crawl", "pup");       |   use Caterpillar ();      |   use Caterpillar;
         ----------------------------------------|----------------------------|-------------------
         BEGIN {                                 |   BEGIN {                  |   BEGIN {
             require Caterpillar;                |       require Caterpillar; |       require Caterpillar;
             Caterpillar->import("crawl", "pup");|   }                        |       Caterpillar->import();
         }                                       |                            |   }
         ----------------------------------------|----------------------------|-------------------

            nb. require Caterpillar      : loads a 'module' (a file named Caterpillar.pm)
                Carterpillar-> imnport() : calls a class-method ('package' Caterpillar)
                   
                  so it works only if module and package respects the rule
            
            import: is not a built-in fun. It's a method that must be defined by the user
                    which any args and doing whatever.
                    The most common way to define an import() method is to inherit it from Exporter.pm
                    Exporter is a Perl core module.

--------------------------
EXPORTER
--------------------------
        import() In Exporter's implementation of import(), the list of arguments 
                 is interpreted as a list of subroutine names
                 Those subs besides their original pack, become available also in the current pack
                 this means I can call them shortly as subx() instead the "longhand" AAA::BBB::subx()

        @EXPORT  it's a var in Exporter that can also contain a list of sub names
                                 our @EXPORT = ("crawl", "eat", "pup");
                 they are exported if import is called with no args:    import()
       

--------------------------
SYMBOL TABLEs / LEXICAL SCOPEs
--------------------------
varibale-names  are stored in memory in 2 different places, both called
"name-spaces", and then one space called "symbol tables" and the other
"lexical-scopes". Each space then allocates different sub-area for the
different 'sigil': so var of type $, @, %, &, go in separate area
(that's the reason why $a @a %a &a do not conflict each other)

lexical scopes: store 'local' vars. 
                That is, vars inside blocks { }, of type
                my, our, state.
symbol tables:  called also 'package' var, store 'global vars.

qualified name: is the long name of a var that allows to distinguish from others

                ex. $Santa::Helper::Reindeer::Rudolph::nose  <---- 1 name = {many 'term'}
                      ^       ^         ^       ^       ^
                     term    term      term    term    term

Name Lookups:   is the process that Perl uses to find from the simple term (ex. $a)
                the qualified name. It is:

                        1. starts searching in the lexical scope of that block
                        2. goes on upper blocks
                        3. goes to the largest possible lexical scope (compilation unit)
                           that is:
                              - the file (normally)
                              - the STRING passed to an 'eval': in this case
                                is still is not found in the runtime STRING, Perl
                                restart from point 2, considering the lexical scope
                                of the block where the 'eval' is written.
                           
                        4. pass to search for global vars, searching again from point 1 to 3
                           but for the nearest 'package' instruction which will be 
                           prepended to the front of the variable.
                        5. If there is no package declaration in any surrounding lexical scope, 
                           Perl looks for the variable name in the unnamed top-level package, 
                           (called 'main')
--------------------------
GRAMMARS - TERMS & OPERATORS
--------------------------
term     HIGHEST precedence!!!
         they are: 
                 . vars 
                 . quoted ops (any kind)  <--- A fun is nothing but an operator with args inside (): f (...)
                 . braces     (any kind)                                                              \___ 'operator'

operators:  
      01 - Terms and List Operators (Leftward)    
      02 - The Arrow Operator                          : on the right there are not [] {} or ()
      03 - Autoincrement and Autodecrement             : ++ only (not --) has some magic on strings
                                                         incrementing the char
                                                         $a = "a9";   ++$a;  "b0"
                                                         $a = "Az";   ++$a;  "Ba"
                                                         $a = "zz";   ++$a;  "aaa"
      04 - Exponentiation                              : binds even more tightly than unary minus, so –2**4 is –(2**4)
      05 - Unary Operators                             : ! + - ~
      06 - Binding Operators
      07 - Multiplicative Operators
      08 - Additive Operators
      09 - Shift Operators
      10 - Named Unary and File Test Operators
      11 - Relational Operators
      12 - Equality Operators
      13 - Smartmatch Operator
      14 - Smartmatching of Objects
      15 - Bitwise Operators
      16 - C-Style Logical (Short-Circuit) Operators
      17 - Range Operators
      18 - Conditional Operator
      19 - Assignment Operators
      20 - Comma Operators
      21 - List Operators (Rightward)
      22 - Logical and, or, not, and xor
      23 - C Operators Missing from Perl

                           

--------------------------
USEFUL MODULES
--------------------------
CPAN: Comprehensive Perl Archive Network

                       The CGI.pm module comes with Perl, so you should be able to read its documentation:
                                $ perldoc CGI

ExtUtils::MakeMake:      comes with Perl. It handles a module instalation by:
                     $ perl Makefile.PL
                 $ make install

                 $ perl Makefile.PL INSTALL_BASE=/Users/fred/lib        # option INSTALL_BASE for another dir

Module::Build:      another way to install a module:
                 $ perl Build.PL
                 $ ./Build install
                 
                 $ perl Build.PL --install_base=/Users/fred/lib

CPAN.pm:            come with Perl to manage when modules depends on others.
                     $ perl -MCPAN -e shell

                    It can be a little complicated, so a while ago was written a little script 'cpan'


cpan:      The cpan command that comes with Perl can create an autobundle, (a list of everything you 
           have installed, along with the version numbers:
                                                             $ cpan -a

                                               $ cpan Module::CoreList LWP CGI::Prototype

bundle :   A file that some CPAN clients can use to reinstall everything you already have installed, 
           either on the same machine or a different machine

cpanm:     it doesn’t come with Perl  (download from http://xrl.us/cpanm)
           Once you have cpanm, you simply tell it which module to install:
              $ cpanm DBI WWW::Mechanize\
               
local::lib:  to keep additional Perl modules in their own directories (having no permission to install in Perl dir)
             (download from CPAN as doesn’t come with Perl)
              $ perl  -Mlocal::lib
            export  PERL_LOCAL_LIB_ROOT="/Users/fred/perl5";
            export  PERL_MB_OPT="--install_base /Users/fred/perl5";
            export  PERL_MM_OPT="INSTALL_BASE=/Users/fred/perl5";
            export  PERL5LIB="...";
            export  PATH="/Users/brian/perl5/bin:$PATH";


            $ cpan -I Set::Crossproduct     <---- option -I  for cpan   when used the above dir settings

            $ cpanm --local-lib HTML::Parser  <--  with the cpanm way

      set this in your CPAN.pm configuration, it adds them every time it tries to install a module.
            $ cpan
            cpan> o conf makepl_arg INSTALL_BASE=/Users/fred/perl5
            cpan> o conf mbuild_arg "--install_base /Users/fred/perl5"
            cpan> o conf commit
            
            
      use local::lib;            # to write inside your Perl program so that it finds local modules.
                                 # During compilation, Perl sees that line and loads the module
            
perldoc:   perldoc File::Basename       # to see information on what the module does.
use ....:
           use File::Basename                 # import and load some functions 
                                                use 'perldoc File::Basename' to see which.
           use File::Basename qw/ /;          # import without loading ....
           use File::Basename ();             # ... ALL the functions

           use File::Basename qw/ basename /; # import and load only 1 function (here 'basename'

           my $dirname = File::Basename::dirname $name; # call here a fucntion ('dirname') with full name.

File::Spec
            use File::Spec;
            
            my $new_name = File::Spec->catfile($dirname, $basename); # use od -> as it's a CLASS
           
CGI.pm      To make all the CGI stuff easy (do not reinvent the wheel. Use what it's tested and debugged)

            use CGI qw(:all);                             <------ load all functions from CGI module
            print header(),
            start_html("This is the page title"),
            h1( "Input parameters" );
            my $list_items;
            foreach my $param ( param() ) {
               $list_items .= li( "$param: " . param($param) );
            }
            print ul( $list_items );
            print end_html();
           
DBI.pm      Once you install DBI , you also have to install a DBD (Database Driver, from the long
            list on CPAN [the version ok for your server]).

            use DBI;
            $dbh = DBI->connect($data_source, $username, $password);
            
            my $sth = $dbh->prepare("SELECT * FROM foo WHERE bla");
            $sth->execute();
            my @row_ary = $sth->fetchrow_array;
            $sth->finish;
            
            $dbh->disconnect();
           
Dates and Times
            my $dt = DateTime−>from_epoch( epoch => time );
            
            print $dt−>ymd;            # 2011−04−23 
            print $dt−>ymd('/');       # 2011/04/23
            print $dt->ymd('');        # 20010423

            y $dt1 = DateTime->new(
               year => 1987,
               month => 12,
               day => 18,
            );
            my $dt2 = DateTime->new(
               year => 2011,
               month => 5,
               day => 1,
            );
            my $duration = $dt2 - $dt1;

            my @units = $duration->in_units( qw(year month day) );
            printf '%d years, %d months, and %d days', @units;       # 23 years, 4 months, and 14 days
            
--------------------------
INSTALL MODULES
--------------------------
'distributions'                 is the name how 'packages' are called in CPAN
                                they are a tar.gz file containing 1 or more .pm
                                in a dir-tree structure

'intstall by hand'              download the tar.gz, unpack and run

                                          BUILD.PL         or if there is Makefile.PL

                                       1. perl Build.PL             1. perl Makefile.PL        
                                       2. ./Build                   2. make
                                       3. ./Build test              3. make test
                                       4. ./Build install           4. make install

                                at step 2. the compilation create the .pm files in a dir .blib
                                at step 4 (the .pm files are copied into a dir of @INC) that can
                                be specified as --installdirs option at step 1)
                                perl Makefile.PL PREFIX=/home/me/perl INSTALLDIRS=perl


install in a specific dir:      ex. you are not root and cannot write in system dir
                                       perl Makefile.PL PREFIX=~/lib LIB=~/lib
                                change ~/lib to a preferred value

'dependencies'                  the module M, needs module A, which needs B, ....
                                to avoid installing all by hand, use CPAN client like cpan or newer cpanm

'cpan'                          is already available in core perl distribution.
                                Anyhow you can update as >cpan CPAN

~/.cpan ~/.cpanm                are the default dir used by cpan and cpanm
                                to created a repository.
                                The configuration file is usually stored in
                                    ~/.cpan/CPAN/MyConfig.pm
                                and it's something like:
                                    $CPAN::Config = {
                                         '...' =>  q[...]   ex 'http_proxy' => q[],
                                         '...' =>  q[...]      'prefer_installer' => q[MB],
                                    };
                                    1;
prefer_installer                MB means that if there are both a Makefile.PL and a Build.PL
                                the command 'make' must act as a simple wrapper around the Build.PL
                                (so actually running always Build.PL)

cpan[1]>                        Once run the command 'cpan', I'm inside the cpan shell
                                and that is the prompt.
     -o conf                    command to edit the MyConfig.pm through the cpan shell.
     -o conf commit             to save the changes
     -h                         for the help
     -o conf init               to see all the values (and the meaning!!) of each param.
                                nb. I see the 'current' value not the 'factory' default.
                                To see the original value, rename MyConfig.pm, 
                                and run -o conf init like it was the first time.
                                
--------------------------
MORE PERL versions on the same PC
--------------------------
The already installed PERL version (RedHat, Ubuntu, ...) arrived customized
and it's better not to mess it up. The vendor's system perl scripts are tested agaist that.
To install a different version download the perl.gz distribution and run its 'Configure'
with the required -Dprefix=... (ex -Dprefix=${HOME}/perl_vers/5.10.1/)

PERL5LIB :      this env variable must be set when I need to add additional dirs besides @INC.
                Perl does not require that the PERL5LIB variable be set. 
                Typically, the variable will not be set to any value. 
                Anyhow I can set PERL5LIB so that Perl looks for modules in a private directory.
                
       % export PERL5LIB=~/my_debug_lib
       % mkdir -p ~/my_debug_lib/Net/
       % cp `perldoc -l Net::SMTP` ~/my_debug_lib/Net/.
       % vi ~/my_debug_lib/Net/SMTP.pm

local::lib     this module can be downloaded and compiled with its option --bootstrap=
                   $ perl Makefile.PL --bootstrap=~/.perl  <---- set here the dir you want
                   $ make test && make install
               and allows to have an archive of CPAN Modules in the specified dir.
               It's behavoìiour is to print the required variables (e.g. PERL5LIB)
               and the command is usually:

                   perl -I$HOME/.perl/lib/perl5 -Mlocal::lib=$HOME/.perl

               which prints:
                   export MODULEBUILDRC="/home/you/.perl/lib/perl5/.modulebuildrc" <---- vars used by Module::Build and 
                   export PERL_MM_OPT="INSTALL_BASE=/home/you/.perl/lib/perl5"      <--- ExtUtils::MakeMaker when they need to target
                   export PERL5LIB="/home/you/.perl/lib/perl5/lib/perl5:$PERL5LIB"       a tree on a MODULE installation
                   export PATH="/home/you/.perl/lib/perl5/bin:$PATH"

              you can add those lines in ~/.bashrc as
              echo 'eval $(perl -I$HOME/.perl/lib/perl5 -Mlocal::lib=$HOME/.perl)' >> ~/.bashrc

perlbrew      to manage multiple Perl installations in your $HOME directory. 
              They are completely isolated perl universes.

              Install as   sudo apt-get install perlbrew                 <----- works but as root then 
              or           \curl -L http://install.perlbrew.pl | bash    <----- works for user
                                                                                is installed as
                                                                                ~/perl5/perlbrew/bin/perlbrew


              then install a Perl distribution as  perlbrew install perl-5.16.0

              perlbrew list        to see the installed versions

              to switch to a Perl version:
              perlbrew switch perl-5.16.0  (works for ANY shells: PERMANENT, till a new switch or use)
              perlbrew use    perl-5.16.0  (works   temporarily  on current shell only)



--------------------------
DEBUGGERS
--------------------------

            perl5db.pl


strict / warnings:    use use use  use them:                % perl -Mstrict -Mwarnings program

print:
       print "The value of var before is [$var]\n"     # use braces to limit values of a var (to see also spaces)

       warn "The value of var after is [$var]";        # use var to have also line no
                                                       # The value of var before is [...] at program.pl line 123

       Carp                                            # alternative warn and die for modules 

       use Data::Dumper qw(Dumper);                    # use Data::Dumper to print Objects and limit with < .. >
       warn "The value of the hash is <\n" . Dumper( \%hash ) . "\n>";

Hook::LexWrap::wrap :    Encapsulates a function in a wrapper and allows to inspect args and ret val.
      
       use Hook::LexWrap qw(wrap);
       my $n = shift @ARGV;
       my $m = $ARGV[0];
       wrap add,
           pre  => sub { print "I got the arguments: [@_]\n" },
           post => sub { print "The return value is going to be $_[-1]\n" 
       ;
       print "The sum of $n and $m is " . add( $n, $n ) . "\n";    # <----- this is the error ( passing 2 n)
       sub add {
                  my( $n, $m ) = @_;
                  my $sum = $n + $m;
                  return $sum;
       }

perl -d :    normal perl debugger (% perl -d add_numbers.pl 5 6)
      

Alternative Debuggers :    Are all under Devel::
                        - Devel::Trace                % perl -d:Trace program.pl
                        - Devel::ptkdb  <--- GREAT    % perl -d:ptkdb program.pl
                        - Devel::ebug                 % perl -d:ebug  program.pl
                        - Devel::hdb    mini web server (its web interface, lets me debug on a remote server)

IDE        -  EPIC       (Eclipse Perl Integration) is the Perl plug-in for Eclipse.
           -  Komodo     (started on Microsoft. Now available on Solaris, Linux, and Mac)
                          handles Perl as well as other languages, (Tcl, Ruby, PHP, Python)
      


---------- Perl 4ed Oreilly [2012] - PREFACE

   name:  PERL = Practical Extraction and Report Language

   CAMEL:  a camel is a horse designed by a committee

   key features
        - PORTABLE: more than C / C++ / JAVA / ...
                    on Windows and Unix

   - WEB SITE: perl.org
   - CPAN    : cpan.org   (lot of more FAST mirrors: cpan.org/SITES.html)
                          (both ftp / HTTP                              )
   - Perl Folks: perlmonks.org.

   - SUPPORTED RELEASES: 2  (the current and the previous)
               they are even num. 
               ex. If last is 5.18 --> [5.18 + 5.16]
                                        5.14 is the 1' UN-supported
                  
   - DOWNLOAD + INSTALL
               Besides a already installed Perl version, others version can
               be installed and compiled with different options (and where
               store libs)
               1. wget http://www.cpan.org/src/5.0/maint.tar.gz
               2. tar zxf
               3. sh Configure -des     (assumes DEFAULT answers)
               4. make test && make install  (requires sudo privil.)
      to test other vers. without sudo privil.
      install from CPAN App::perlbrew
               1. curl –L http://xrl.us/perlbrewinstall | bash      (download + install)
               2. ~/perl5/perlbrew/bin/perlbrew install perl–5.14.2
                                         ^        ^         ^
                                       exec.    inst.    of perl v.5.14

   - DOCUMENTATION  there is a "perldoc"  cmd besides the normal "perl"
                    try "perldoc perl"

            1  perl         What perl manpages are available        Perlfaq1     General questions about Perl
            2  perldata     Data types                              Perlfaq2     Obtaining and learning about Perl
            3  perlsyn      Syntax                                  Perlfaq3     Programming tools
            4  perlop       Operators and precedence                Perlfaq4     Data manipulation
            5  perlre       Regular expressions                     Perlfaq5     Files and formats
            6  perlvar      Predefined variables                    Perlfaq6     Regular expressions
            7  perlsub      Subroutines                             Perlfaq7     General Perl language issues
            8  perlfunc     Built-in functions                      Perlfaq8     System interaction
            9  perlmod      How perl modules work                   Perlfaq9     Networking
           10  perlref      References
           11  perlobj      Objects
           12  perlipc      Interprocess communication
           13  perlrun      How to run Perl commands, plus switches
           14  perldebug    Debugging
           15  perldiag     Diagnostic messages
           
           “ perl –V:man.dir ”   To see the value to set in MANPATH in the UNIX man doesn't go properly.

---------- Perl 4ed Oreilly Ch1
           =            <---- a line started with a '='
           =cut               start a pod section up to a '=cut'
                              a way to have 'muli-line comments
          

           $x = $y <--- rvalue  (value on the r-ight)
            ^
            lvalue (because in a value on the l-eft)


           $x = $y + 1
            ^   ^^^^^^
         lvaluw      a temporary value built by 2 rvalues
                     and put on a 'stack'
                     The pushes and pops all balance out
                     by the time the expression is done

         names : are defined as ? xxxxx
                                ^       
                                called sigil can be
                                        $ for scalar   $foo
                                        @ for array    @foo  (no conflict with $foo or %foo)
                                        % for hash     %foo  (no conflict with $foo or @foo)
                                        * for any ($,@,%) is called typeglob like in bash
                                                          it matches all
        reserved words: they are usually lowercase

        xxxxx   the actual identifier can be formed by 
                - up 251 symbols [_0-9a-Z] but also
                  unicode (~ 100k symbols). When using Unicode
                  add a line 'use utf8'  at the beginning, to say to the Perl compiler
                  that through the code there are Unicode chars

        all the terms that starts with a sigil ($,@,%) cannot be confused
        with reserved words (so ex $for is a possible name, for the same
        reason a var $123 is ok)
        Terms with no leading sigil (ex. label or FILE handle, or package names) 
        it's better to start with an UPPERCASE so still they cannot be confused.

        BAREWORDs      any term not quoted "" that is not recognized as 
                       a reserved word, is then assumed as a STRING (quoted)
                       use strict "subs" in a scope to force quoting
                       a (no strict "subs") in a inner scope can turn it off
                       thus put (use v5.12;) in the top most file.

        __XXX__        reserved literals:
                       __LINE__    as in C
                       __FILE__    as in C
                       __PACKAGE__ the package in which that line of code is compiled
                       __END__     mark end of script to compiler (any further text is ignored)
                       __DATA__

        SYMBOL TABLES: the names that belong to SYMBOL TABLES are the global
                       var, also called PACKAGE VARs. They live inside their package,
                       and are so fully qualified by the :: path and so are
                       accessible from outside with the long full name
        LEXYCAL VAR:   are local var, whose scope is ex. a function body
                       they are identified by keyords: local, my, our, state.
                       (our usually to avoid)
                       The largest LEXYCAL scope is the file. Any lexycal scope
                       var is never seen outside that file.

        HERE doc       It's a way to set a STRING with a 'document' inline
                       that starts from a specified <<keyowrd up to the same keyword
                       
                       print <<SSS;   print<<'SSS';    print<<"SSS"         print<< ;
                       .....             with ''         with ""                   ^ a space (deprecated)
                       SSS            SSS              SSS                           go up to 1st blank line (I can avoid any SSS)
                       

                       print <<"" x 10               print << x 10                     print <<"SSS", <<"TTT";
                          10 times this line            10 times this line             ....
                                                     (with space)                        SSS           I can 'stack' many
                                                     (deprecated)                      ...
                                                                                         TTT

                       print (<<SSS);                             ($quote = <<'SSS') =~ s/^\s+//gm;
                       .....       the brace if I like                   I indented this text
                       SSS                                               with the code, so I remove the spaces
                                                                  SSS


                      my @a = <<SSS;                              my @a = <<SSS =~ m/(\S.*\S)/g;
                       .....       I assign to an array            .....       I assign to an array removing spaces
                       SSS                                         SSS              


        

---------- Perl 4ed Oreilly Ch2
---------- Perl 4ed Oreilly Ch3
---------- Perl 4ed Oreilly Ch4
---------- Perl 4ed Oreilly Ch5
---------- Perl 4ed Oreilly Ch6 
---------- Perl 4ed Oreilly Ch7
---------- Perl 4ed Oreilly Ch8
---------- Perl 4ed Oreilly Ch9
---------- Perl 4ed Oreilly Ch10
---------- Perl 4ed Oreilly Ch10
---------- Perl 4ed Oreilly Ch12
---------- Perl 4ed Oreilly Ch13
---------- Perl 4ed Oreilly Ch14
---------- Perl 4ed Oreilly Ch15
---------- Perl 4ed Oreilly Ch16
---------- Perl 4ed Oreilly Ch17
---------- Perl 4ed Oreilly Ch18
---------- Perl 4ed Oreilly Ch19
---------- Perl 4ed Oreilly Ch20
---------- Perl 4ed Oreilly Ch21  
---------- Perl 4ed Oreilly Ch22
---------- Perl 4ed Oreilly Ch23
---------- Perl 4ed Oreilly Ch24    

\d      matches a Unicode digit, not just [0-9] but also other Unicode math digits (ARABIC INDIC symbols)
\D      is a negated \d; [^\d]
\s      matches a whitespace character, the set [\ \t\r\n\f] and others
\S      is a negated \s; [^\s]
\w      matches a word character (alphanumeric or _), not just [0-9a-zA-Z_] but also other Unicode digits
\W      is a negated \w; [^\w]
.       matches any character but "\n" 
\N      like '.' but it does so regardless of whether the modifier //s is in effect.
\b      word anchor, matches a boundary between a word char and a non-word char  /cat\b/;  # matches cat in 'housecat'
\b{wb}  light form of \b for natural language (ex. apostrophes are included in words, like in "don't")


---------- Perl 4ed Oreilly Ch25
---------- Perl 4ed Oreilly Ch26
---------- Perl 4ed Oreilly Ch27
---------- Perl 4ed Oreilly Ch28
---------- Perl 4ed Oreilly Ch29



//a              to match inside the ASCII subset of Unicode. 
                 Ex \d in ASCII is only [0-9] while in Uniocde
                 matches other matemathical digits (ex. ARABIC INDIC)
                 so use /\d/a
//aa             When using ignorecase //i, Perl must consider UPPERCASE Uniocode val
                 and lowercase Uniocde val. If one val (UPPER or lower) is in ASCII range and
                 the other is not, when testing with //ia as one macthes, the result is true.
                 To restrict on these cases use //iaa
//s   //m        stand for single-line multi-line and they determine whether a string 
                 is to be treated as one continuous string, or as a set of lines. 
                 They affect 1) how the '.' is defined, 2) where ^ and $ are able to match. 

                              .                ^                                   $
                 //      any != \n        only 1st char of ALL STR    only last char of ALL STR 
                 //s     any (also \n)    only 1st char of ALL STR    only last char of ALL STR
                 //m     any != \n        any STR start               any STR end or before \n   
                 //sm    any (also \n)    any STR start               any STR end or before \n

                 regardless of all the cases with
                      \A is always  "only 1st  char of ALL STR"
                      \Z is always  "only last char of ALL STR (with or without \n)"
                      \z is always  "only last char of ALL STR (different from  \n)"


                 
                 
                 the ASCII val, it matches
                 (so matching also 
                 
                 
                 
                 to match inside the ASCII subset of Unicode. 




