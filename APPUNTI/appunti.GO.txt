
go build -gcflags "-m -m"




_________________ INSTALL WITH PKG MANAGER

.   GO can be installed with a package manager (homebrew, apt-get, ..)
    and i.e. on a mac it goes in /usr/local/bin/go*

.   a package manager has always stable but older things, so once I have
    the (old) GO binary, I can even compile the latest GO version

    because GO is open source (and written in GO itself):  git@github.com:golang/go.git
    I can compile from source:

                      . clone the repo in ~
                        that will create dir: ~/go

_________________ COMPILE WITH GCC the LAST VERSION WRITTEN IN C

                  https://storage.googleapis.com/golang/go1.4-bootstrap-20161024.tar.gz

     1.  mkdir ~/go.bin/
     2.  cd ~/go.bin/ && wget ......tar.gz && tar xzvf ....

         in this way you have the GO (old) compiler: ~/go.bin/bin/go


     3.  compile the source in ~/go/src (with $GOROOT_BOOTSTRAP=~/go.bin

         no other env vars are required now, once completed, it is usefull to set
                       GOPATH
          (while GOROOT since some version of GO is nomore to be set
           but builtin into GO (
                                type: "go env" to see it
                                type: "go env GOPATH"  to see the value of $GOPATH

           )
     4. cd ./src && ./all.bash    (it will compile with the gcc, it will create the dir
                                   ./bin where it will create 2 binaries (go / gofmt)
                                   (gofmt is the formatter: use it on the command line as  > gofmt a.go)

                                   nb. gofmt is the old tool (still available), anyhow now there is
                                                 goimport which formats & manage the imports

     5. update PATH to find them (~/.bash_profile):

                               export GOPATH="$HOME/go"
                               export PATH="$PATH:$GOPATH/bin"
                               export PATH=$PATH:$(go env GOPATH)/bin

     6. recompile (with the new)
                       having the executable of the new compiler (compiled with the old)
                       that is located in ~/go/bin
                           now $GOROOT_BOOTSTRAP is no more  needed

                       nb. it's maybe  better to save the previous go (mv ~/go/bin/go ~/go/bin/go.prev)
                           as at each rebuilt it's overwritten



___________________________________________________________________________ GOROOT
___________________________________________________________________________ GOPATH (the 'Workspace')

    "GOPATH" is the path where ALL the go repos (both my code, and remote repos) are put
             (It's not the path where GO binary is installed)

    the GOPATH dir, has 3 subdir

               bin/
               pkg/
               src/  <----- here I put my code and any "go get github.com/...."
                            is downloaded into here

    $ go build    <--- this command only checks the compilation but doesn't create the binary in bin/
                       (actually it creates a binary in the same source dir, the "go install" will properly move it)
    $ go install  <--- this command creates the proper subdirs in bin/ and pkg/

    $ go get <PPPPPP>    <--- go get is a:
                                - download   (<--- it will create the usual source sub-dirs in $GOPATH/src)
                                - install
                       go get -d    will only download (no "install" after)

                       anyhow the path <PPPPPP> in "go get" can be also directly a sub-dir in $GOPATH/src
                       ex:
                                            go get sbasile/t1                 <---- subidr in $GOPATH/src/
                                                   ^^^^^^^^^
                                                       the syntax is a relative pathname of $GOPATH/src
                                                       not a http://.....

                       In this case the "download" phase is skipped and there is only a "get install".
                       So "get install" is completely redundant as:
                            1. if I want to download &  install:                  go get    http://
                            2. if I need to only download something from the net: go get -d http://......
                            2. if I want to only install  something locally       go get    ppp1/ppp2


    ex:
          src/github.com/user/hello/main.go                 (or src/sbasile/t1/main.go)
              ^^^^^^^^^^^^^^^^^^^^^   ^
                                |     the code
                                |
                                identify the name of the excutable ('hello')
                                ex.
                                     go install github.com/user/hello      <--- I can run from everywhere
                                                                                because $GOPATH is defined
                                                                                It will create a "hello" exe in $GOPATH/bin/

                                     go install sbasile/t1                 <--- I can run from everywhere
                                                                                because $GOPATH is defined.
                                                                                It will create a "t1" exe in $GOPATH/bin/

                                     go install                            <--- even just this after a
                                                                                cd src/github.com/user/hello

                   If GOPATH is in $PATH, from everywhere I can run
                             > hello




___________________________________________________________________________ 1 GO PROG OF 1 ONLY FILE

             Any prog written in go, starts (like in C) from the 'main'

             1 prog (executable xxxx*) will so have 1 of the possible structures below

                 src/........./xxxx/main.go   <---- the source code starts with  "package main"
                 src/........./xxxx/ffff.go   <----      "       "    "     "        "     "


                       nb. there is another important function in every package: 'init'.
                                       func init() { .... <--- no args / no return val)
                           The runtime steps done by GO are:
                                    . recursively load all the imported packages
                                    . set all global vars to their values
                                    . call the 'init' function (if present)

                           INCREDIBLY: I can have many DEFINITION of init().
                                       Many
                                              func init() {
                                       in the same file
                                       and/or many in different files of the same package.
                                       They will just be called in sequence.


                           import _ "xxxx"  <---- the _ is used to silent the compiler of
                                                  the fact that "xxxx" is not used in the file.
                                                  The reason is that GO will not trigger an error
                                                  and then, as usual, will call xxxx.init that is what I maybe want.

___________________________________________________________________________ 1 GO PROG OF 2+ FILES

             If a prog (xxxx*) is made by 2 or more source files there will be the main like above
             so any of this (but package "main")

                 src/........./xxxx/main.go
                 src/........./xxxx/ffff.go

             while any other source file will be something like

                 src/........./yyyy/ffff.go   <---- the source code starts with  "package yyyy"
                                                    and in the main I can include yyyy like
                                                    import "...../yyyy"


___________________________________________________________________________ PACKAGES

      package main   <--------- Every Go program is made of packages.
                                Programs start running in package main.

      import (       <---  this is called 'factored' layout (the suggested one)
        "fmt"              this is also possible  ------->    import "fmt"
        "math/rand"                                           import "math/rand"
      )



      import (
          "xxxx"
        m "xxxx"
        . "xxxx"
        _ "xxxx"
      )

        m "xxxx"    <---- I add an 'alias', so after I can just use m.B to refer a B var/function of package "xxxx"
                          It's usefull when a package B is like another A (ex. .../logxxx and  'log')
                          In the following code using the alias allow to have the same code
                          even i I change the package (both will have m.----)

        . "xxxx"    <---- In this case I can use the var/functions of "xxxx" without
                          prepending anything (ex. instad of xxxx.B or m.B directly B)

        _ "xxxx"    <---- call xxxx.init() even if xxxx is not used in the file (which otherwsie
                          would call an error by GO compiler).

___________________________________________________________________________ Exported names

    are visible outside (are exported)
    only names starting with an UPPER case
___________________________________________________________________________ GO declaration way

  Even if coming from C,
  GO decided to use a different style in TYPEs declarations

      int x;            x int                                           x is an int
      int *p;           p *int              the GO way is to match      p is a pointer to an int
      int a[3];         a [3]int            the human sentence          a is an array of ints
    ___ C _____       ____ GO_____

___________________________________________________________________________ BASIC TYPEs

         int  int8  int16  int32  int64
         uint uint8 uint16 uint32 uint64 uintptr

         byte // alias for uint8

         string

         bool

         rune // alias for int32 - represents a Unicode char

         float32   float64
         complex64 complex128
___________________________________________________________________________ VAR

     var    a, b, c   int       <--- var allows to declare a (list) of vars
                                     the type of all the list is at the end.

     var    a, b, c   int  = 1,2,3   <--- n.b. the syntax to also initialise.


     c := 3                    <--- :=  is called the short assign. statem.
                                        it allows to skip the TYPE that is inferred from the right hand value
                                        :=   can be used only for local vars  (inside function)

     var (                      <---  this grouping layout is also possible
         ToBe   bool       = false
         MaxInt uint64     = 1<<64 - 1
         z      complex128 = cmplx.Sqrt(-5 + 12i)
     )
___________________________________________________________________________ FUNCTIONS

     func add(x int, y int, z int)
     func add(x, y, z int)       <--- if 2 or more args are of the same type
                                      I can add the type  just after the last

     func swap(x, y int) (int, int)     <--- a function can return any number of args (here only the TYPEs are specified)
     func swap(x, y int) (a int, b int) <--- in this case the return TYPEs are 'named'  (name 'a' and 'b')
     {
          a=7                                         When there are 'named' return args
          b=8                                         it's supposed there are local vars with those names defined then in the function
          return                                      In this case I can use both of the following notations:
     } ^
       nb: missing 'var' for 'a' and 'b'                   return (a,b)    <--  explicit form
           I can use them directly                         return          <-- 'naked' form. local vars 'a' and 'b' are returned



     Functions are values. They can be passed around just like other values.

                 compute(fn func(float64, float64) float64) float64 {
                    return fn(3, 4)
                 }


     CLOSURES:  A closure is a function value that references var outside its body.

                func adder() func(int) int {       <---- receives nothing / returns a function  f(int)-->int
                     sum := 0
                         return func(x int) int {
                             sum += x
                             return sum
                         }
                     }

                func main() {
                         pos, neg := adder(), adder()  <--- Each closure is bound to its own sum variable.
                         for i := 0; i < 4; i++ {            0 0 0
                             fmt.Println(                    1 1 -2
                                 i.                          2 3 -6
                                 pos(i),                     3 6 -12
                                 neg(-2*i),
                             )
                         }
                     }

___________________________________________________________________________ ZERO VALUES

    var not initialised have this ZERO values:

             num types : 0
             bool      : false
             string    : ""
___________________________________________________________________________  TYPE CONVERSION

               xxxxx(a)           <----- var a is converted to type xxxxx

               var i int = 42                          i := 42
               var f float64 = float64(i)     --->     f := float64(i)
               var u uint = uint(f)                    u := uint(f)

              _____ LONG WAY __________              ____ SHORT______


             UNLIKE C (where this is possible:  int i = 258; char c = i;)
                      the type must be always indicated explicitly




___________________________________________________________________________ CONSTANTS

    just as expected:    const Pi = 3.14         (cannot be used ':=' )

___________________________________________________________________________ FOR

                                             'for' is the only loop construct
    for i := 0; i < 10; i++ {          <---- the are no '('  ')'
        sum += i                             while the  '{'  '}'  are required
    }


    sum := 1
    for ; sum < 1000; {                <--- only the 2nd part (test-of-end-condition)
        sum += sum                          can be usually specified
    }


    sum := 1
    for {                <--- if omitting all, it becomes a forever loop
          ...
    }
___________________________________________________________________________ IF

       if x < 0 {                   <---- like 'for' : NO '(' ')'   YES '{' '}'


       if v := 4; v < lim {       <--- like 'for' a pre-part to init (only 1 var) is possible



       } else {                   <--- the else stays on the line with the 2  '}'  '{'

___________________________________________________________________________ SWITCH


     switch os := runtime.GOOS; os {                switch os := runtime.GOOS; os {
        case "darwin":                                 case "darwin":
             fmt.Println("OS X.")                           fmt.Println("OS X.")
                                                            fallthrough                       <--- no 'break' are required
        case "linux":                                  case "linux":                               a 'fallthrough' will go down to the next
             fmt.Println("Linux.")                          fmt.Println("Linux.")
        default:                                       default:
             fmt.Printf("%s.", os)                          fmt.Printf("%s.", os)
     }                                              }



               n.b.  the 'cases' are tested in SEQUENCE
                     (like a short circuit)  and can so be of strange types:

                     switch i {
                     case 0:
                     case f():    <--- a function     (that anyhow is never executed if i=0)
                     }

               n.b.  Switch without a condition:
                     'switch {'
                     is the same as 'switch true {'.

___________________________________________________________________________ DEFER


       'defer' keyword  tags a function-call to be executed before return.

       func main() {                                                                                   for i := 0; i < 10; i++ {       --->     done
            defer fmt.Println("world")  <--- 'defer' are pushed on the stack, so called as LIFO            defer fmt.Println(i)                 9
                                                                                                       }                                        8
            fmt.Println("hello")                                                                       fmt.Println("done")                      7
       }                                                                                                                                        6
                                                                                                                                                5
                                                                                                                                                4
                                                                                                                                                3
                                                                                                                                                2
                                                                                                                                                1
                                                                                                                                                0
___________________________________________________________________________ POINTER

       '*' and '&' like C:

           i := 42
           var p *int
           p = &i

       A N Y H O W   note that UNLIKE C
                     there is NO-aritmetic for pointers


___________________________________________________________________________ STRUCT

     type Vertex struct {
        X int                                v := Vertex{1, 2}
        Y int                                v.X = 4
     }


    _____ POINTER TO STRUCT

        p := &v               (*p).X = 4   <---- the formal way
                                 p.X = 4   <---- syntactic sugar  (can skip the dereference)

    _____ INIT A STRUCT
                              as the above: v := Vertex{1, 2}
                              I can specify the fields with the syntax 'f_name : value'
                                            v :=  Vertex{Y: 6}  // X:0       is implicit
                                            p := &Vertex{}      // X:0 & Y:0 is implicit


==================== embedded fields
             they are fields with no name
             ex:
             type T1 struct {
                  f1 string
             }

             type T2 struct {
                     T1         <---------------- embedded field
                     f2     int64
                     f3, f4 float64
             }

             func main() {
                            t := T2{T1{"foo"}, 1, 2, 3}
                            fmt.Println(t.f1)    // foo
                            fmt.Println(t.T1.f1) // foo

==================== fields 'tags' and reflection

           REFLECTION is the ability of a computer program to examine, introspect, and modify
           its own structure / behavior at runtime.


           Struct fields can have some meta-information with the syntax
                `key1:"val1" [ key2:"val2"...]`     so:
                                                       . `......`
                                                       . key ':'  "..."
                                                       . 1 <space> separates more pairs

                                                    actually the syntax can be any different
                                                    ex
                                                             f1 string "f one"
                                                    but GO compiler can warns on this
                                                    "vet" enforces the syntax to be strictly ok
                                                    $ go vet file.go

                    _________________ even more fields together (they share the same spec):
                    type S struct {
                         F, G, H string `species:"gopher" color:"blue"`
                    }


            This information are usually added to instruct 3rd parties
            to 'transform / manipulate' the structure  (ex. JSON processing
                    type User struct {
                        Name string `json:"name" xml:"name"`
                    }
               nb. Usually a dash value ('-') for the "value"
                    means to exclude the field from the process
                    (e.g. in case of json it means not to marshal or unmarshal that field).
                    type Foo struct {
                        Bar string `json:"-"`
                        }

            )
            but can also be added and managed directly with the 'reflect' module
            (and its 2 methods 'Get' and 'Lookup' )

            package main

            import (
                "fmt"
                "reflect"
            )

            func main() {
                type S struct {
                     F string `species:"gopher" color:"blue"`
                }

                s := S{}
                st := reflect.TypeOf(s)
                field := st.Field(0)
                fmt.Println(field.Tag.Get("color"), field.Tag.Get("species")) --> blue gopher
            }                          ^                       ^

            we used 'Get'
            Get is the ligth version of Lookup:
               v, ok := f.Tag.Lookup("color")
            which, as usual, returns the "value" (of the key) and the boolean to say ok, not-ok
            With Get we don't care about ok/not-ok


___________________________________________________________________________ ARRAY


       var a [10]int       // Arrays do not need to be initialized explicitly;
                           // all its elem. are set to their 'zeroed' value

                   0  1  2  3   4   5   <----- the indexes (from 0, as usual)
       b := [6]int{2, 3, 5, 7, 11, 13}  <---- or syntactic sugar: [...]int{2, 3, 5, 7, 11, 13}
                                              //use of '...' : the compiler counts for me

       NOT A POINTER: An array var is the entire array; not a pointer to the first element
                      (as in C). This means that when you assign or pass an array
                      you will make a COPY.
                      (To avoid the copy you could pass a pointer to the array,
                      but then that's a pointer to an array, not an array.)
       FIXED LENGTH:   - An array's length is part of its type, so arrays cannot be resized.
       SLICES      :   - dynamically-sized flexible VIEWS into the elements of an array
                           []T <--- slice of type T

                           var s []int = b[1:4]     // 3,5,7
                                  ^      ^   ^
                                  |      |   index 4 is EXCLUDED
                               s is a    of the array b
                             slice of
                                int

                       .nb they are VIEWS:
                                 - slices do not store any data,
                                   they just describe a section of an underlying array.

                                 - Changing the elements of a slice modifies the underlying array.
                                 - Other slices that share the same underlying array will see those changes.
                                   ex. s[0]=8  --> b[1]=8

                                 - in [start:last]
                                   implicit values are assumed (0 for start, len for last)
                                    var a [10]int
                                                     a[0:10]
                                                     a[:10]    <----- are all the same
                                                     a[0:]
                                                     a[:]

                                 -  note that I can have a slice on a slice
                                    s := []int{2, 3, 5, 7, 11, 13}

                                                                   s = s[1:4]   // [3 5 7]
                                                                   s = s[:2]    // [3 5]
                                                                   s = s[1:]    // [5]

                                 -  slices cannot be re-sliced below zero to access earlier elements in the array.

       LEN & CAPACITY OF SLICES :            0   1   2   3   4   5   6   7   8    <--- indexes
                                           ____________________________________
                                           | a | b | c | d | e | f | g | h | i |
                                           |___|___|___|___|___|___|___|___|___|   <---- array
                                                   /__________________________/........................CAPACITY:7
                                                    ____________________
                                                    | 1 | 2 | 3 | 4 | 5 |          <---- slice:  LEN:5  CAP:7
                                                    |___|___|___|___|___|

                        A slice has both
                            capacity : the max number of elements in the underlying array it can address
                                       (counting from the first element in the slice).
                            length   : the actual number of elements it 'views'

                            So (as one could expect) I cannot define a slice exceding a certain 'capacity'
                            'viewing' outside the array


                        for a slice 's' they can be obtained as len(s) / cap(s)

                                               0  1  2  3   4   5   <----- the indexes
                                 -  s := []int{2, 3, 5, 7, 11, 13}  // len=6 cap=6 [2 3 5 7 11 13]

                                                                                              0 1 2  3  4  <----- the indexes
                                                   s = s[1:3] // len=2 cap=5 [3 5]        of [3 5 7 11 13]
                                                   s = s[:4]  // len=4 cap=5 [3 5 7 11]   of [3 5 7 11 13]
                                                   s = s[2:]  // len=2 cap=3 [7 11]       of [7 11 13]
                                                                                              0  1  2  <----- the indexes
       ZERO SLICE :       is nill & len(s)=cap(s)=0
                                        var s []int
                                                if s == nil {
                                                   fmt.Println(len(s), cap(s)...  // 0 0

       FUNCTION ON SLICES:
       ___________________

       'make' :           allocates a '0' (zeroed) array and
                          returns a slice
                                        a := make([]int, 5)    // full view on a 5 zeroed array
                                        a := make([]int, 2, 5) // view of 2 on a 5 zeroed array
       ___________________
       'copy' :           copies data from a source slice to a destination slice.
                          It returns the number of elements copied.
                          ex.
                               copy(t, s)
                          if t>s copies only s elem
                          Like Excel if t&s are overlapping slices on the same array
                          the copy can manage it.

       ___________________
       'append' :         c = append(a, 1, 2, 3)   appends the elements and grows the slice if more capacity is needed.

       ___________________
       'range' :          for i, v := range s {    used in a for loop. It returns 2 values:
                                                       . the index of elem i-th
                                                       . its value

                          for i    := range s {    I can skip the value if I don't care of it
                          for _, v := range s {    I can skip the index with '_' (if I only want the value)

___________________________________________________________________________ MAPS

       Maps are the Perl hashes (associative arrays) :

          ex.   var m map[string]T    an array of T indexed by string keys

       ZERO MAP :       is nill  (A nil map has no keys)

       FUNCTION ON MAPS:
       ___________________

       'make' :           function that allocates a map
                          m = make(map[string] T)
       ___________________

       'delete' :         delete(m, key)
       ___________________

       test elem is present : elem, ok =  m[key]       if present ok is true
                              elem, ok := m[key]       (and 'elem' contains it)
       ___________________

___________________________________________________________________________ METHODS  (NO CLASSES)

       . Go does not have classes.
       . there are 'methods'
         A method is a function with a special receiver argument.
         The receiver appears (in its own argument list) between func and func_name.

         func (v Vertex) Abs() float64 {
                  ^      ^                       <----- inside the function, the use is directly on v
                  ^      ^                              so there is no need of 'this' keyword
           receiver      func_name
           argument.


       . it can be called as expected:   v := Vertex{3, 4}
                                         v.Abs()            <-------- v.xxxx

       . methods must be in the same package (file)
         where the type of that receiver is defined

       . (v  Vertex) is a 'VALUE'-receiver   (the method works on a copy of it)
         (v *Vertex) is a 'POINTER'-receiver (the method works on the same arg)

         So normally we see 'POINTER'-receiver  (in both cases the call is   v.xxxx)


       // suppose v := Vertex{3, 4}        p := &v

       . FUNCTION WITH ARG POINTER:  func xxxx (v *Vertex) {    <---- MUST be called only as xxxx (&v)
       . METHOD   WITH POINTER-rec:  func (v *Vertex) xxxx() {  <---- CAN be called as v.xxxx or (&v).xxxx
                                                                                       ^
                                                                                       ^
                                                                                       syntactic sugar


       . METHOD   WITH VALUE-rec:    func (v Vertex) xxxx() {  <---- CAN be called as v.xxxx or  (*p).xxxx  or p.xxxx
                                                                                                               ^
                                                                                                               ^
                                                                                                               syntactic sugar

       . There is one more aspect of naming to be mentioned: method lookup
         is always by NAME only, not by signature (type) of the method.
         In other words, a single type can never have two methods with the same name.
         Given a method x.M, there's only ever one M associated with x.
         Again, this makes it easy to identify which method is referred to
         given only the name.
         It also makes the implementation of method invocation simple.
___________________________________________________________________________ INTERFACES

       . type iiii interface {    <---- iiiii is now a type (interface)  so a var can be defined of this type:  var x iiii
                xxxx() float64
         }

         now 'x' can be init with different var types (t1 or t2)
                         var f t1;  x = f
                         var g t2;  x = g

         only if both t1 and t2 have methods xxxx() float64

                            func (v t1) xxxx() float64
                            func (v t2) xxxx() float64

       . THE EMPTY INTERFACE:
                             with nothing inside: var i interface{}
                             are used by code that handles values of unknown type.

       . (xxxx,  type)        An interface under the cover, can be thought as a pair of
                                    'active' type
                                    xxxx to call (for that active type)

                              it is actually like a map or hash, so that it's easy to understand
                              the same possible syntax
                                       v := x.(t1)    assign the xxxx of t1 to v
                                       v := x.(t2)    assign the xxxx of t2 to v

                              if x is currently associated to t2  (ex var x = t2{...})
                              the
                                       v := x.(t1)
                              triggers a panic exception
                              so like for maps, there is the
                                       v, ok := x.(t1)      where the ok would be false

       . switch i.(type)
                                switch v := i.(type) {        <------- nb. 'type' is a GO keyword
                                    case int:
                                            fmt.Printf("Twice %v is %v\n", v, v*2)
                                    case string:
                                            fmt.Printf("%q is %v bytes long\n", v, len(v))
                                    default:
                                            fmt.Printf("I don't know about type %T!\n", v)
                               }

       . Stringer:             One of the most ubiquitous interfaces is Stringer defined by the fmt package.

                               type Stringer interface {
                                   String() string
                                   }

                               that instructs how to print a type into a string.
                               The fmt package (and many others) look for this interface to print values.


___________________________________________________________________________ error

       . error  is a built-in interface similar to fmt.Stringer:

           type error interface {
               Error() string
               }

         so each time I call a function xxxx     v,y := xxxx ( ...)
         the y is init with the error (string) value
         and should be tested with the logic
              = nil    --> ok
             != nil    --> ERROR
___________________________________________________________________________ READERS

       . interface with a Read method:
         func (T) Read(b []byte) (n int, err error)

         ex. from File/stream/or even string:

            /   r := strings.NewReader("Hello, Reader!")  <---- from a string
            |
            |   b := make([]byte, 8)
            |   for {
            |           n, err := r.Read(b)
            |           if err == io.EOF {
            |                     break
            \           }
___________________________________________________________________________ GOROUTINES

       .  A goroutine is a lightweight thread managed by the Go runtime.

             go f(x, y, z)  <---- starts a new goroutine running f(x, y, z)

          Goroutines run in the same address space, so access to shared memory must be synchronized.
          The sync package provides useful primitives,
          although you won't need them much in Go as there are other primitives.

       .  goroutines communicate via channels
___________________________________________________________________________ CHANNELS

       .   channels are TYPED  (--> it means on that channel passes 1 TYPE  (ex, int, string ...))
       .   goroutines synchronized to send & received data (with operator <-)
           n.b. The data flows in the direction of the arrow.
                 ch <- v         // Send v to channel
                 v := <-ch       // Receive from ch, and init v.
                 v, ok := <-ch   // assign to v and also test if ok  (maybe channel was closed)
                                 // This is used often to test if a channel is closed

       .   Like maps and slices, channels must be created before usage:

               ch := make(chan int)

            func sum(s []int, c chan int) {
                         sum := 0
                         for _, v := range s {
                             sum += v
                         }
                         c <- sum // send sum to c
             }

             func main() {
                         s := []int{7, 2, 8, -9, 4, 0}

                         c := make(chan int)
                         go sum(s[:len(s)/2], c)
                         go sum(s[len(s)/2:], c)
                         x, y := <-c, <-c // receive from c

                         fmt.Println(x, y, x+y)
                     }

       .   There are 2 types of channels:

              . BUFFERED   which block if the buffer is full.
              . UNBUFFERED which block if there's no "rendezvous", i.e. there must be
                           someone who puts (c <-) to and someone who takes (<- c) from the channel.

       .   BUFFERED: (add a 2nd arg)

            ch := make(chan int, 100)

            ___________________________________________________________________________________________________
                func main() {                      func main() {                 func main() {
                	ch := make(chan int, 2)        	ch := make(chan int, 2)      	ch := make(chan int, 2)
                	ch <- 1                        	ch <- 1                      	ch <- 1
                	ch <- 2                        	ch <- 2                      	fmt.Println(<-ch)
                	fmt.Println(<-ch)              	ch <- 3                      	ch <- 2
                	fmt.Println(<-ch)              	fmt.Println(<-ch)            	ch <- 3
                }                                  	fmt.Println(<-ch)            	fmt.Println(<-ch)
                        |                          }      |                      	fmt.Println(<-ch)
                        |                                 |                      }     |
            ____________V_________________________________V____________________________V_______________________
                    1                    fatal error:                                1
                    2                   all goroutines are asleep - deadlock!        2
                                                                                     3
            ___________________________________________________________________________________________________






       .   UNBUFFERED: as channels are intended to send/receive, if there is no rendezvous,
                       Go triggers a deadlock.
                       This means that a simple change in the above example gives a deadlock

            ___________________________________________________________________________________________________
                func main() {
                	ch := make(chan int)  <--- changed to UNBUFFERED
                	ch <- 1               <--- I'm sending, but no-one will ever pick it up ---> no rendezvous
                	fmt.Println("done")        fatal error: all goroutines are asleep - deadlock!
                }
            ___________________________________________________________________________________________________





       .   close:      The sender can close: close(c)
                       The receiver can test if it is close     v, ok := <-ch

                       Channels aren’t like files; you don’t usually need to close them.
                       They are closed to notify no more values to the Receiver   (that can stop its loop)

       .   range:      a 'range c' allows to loop through a channel because it ends when c is closed

                       for i := range c {


       .   select:     a goroutine can listen on more channels.

                            func g1 (ch1, ch2 chan int) {           func g1 (ch1, ch2 chan int) {
                                x, y := 0, 1                            ..
                                for {                                   for {
                                    select {                                select {
                                    case ch1 <- x:                          case ..
                                        x, y = y, x+y                           ..
                                    case <-ch2:                             case ..
                                        fmt.Println("quit")                     ..
                                        return                             default:             <---- a default is allowed
                                    }                                         fmt.Println("    .")
                                }                                             time.Sleep(50 * time.Millisecond)
                            }

                       A select blocks until one of its cases can run, then it executes that case.
                       It chooses one at random if multiple are ready.



___________________________________________________________________________ TEST

 Go has a lightweight "test" framework

			import "testing"

a test file is a file ending _test.go

function names are    TestXXX
function arg   are  (t *testing.T).
The code inside those functions must be any, but to be usefull somewhere
there must be a call to
                        t.Error       (or t.Errorf   for formatting like a printf: ex t.Errorf("Sum was incorrect, got: %d, want: %d.", total, 10))
                        t.Fail

                        t.Log        can be used to provide non-failing debug information

The framework runs each such function;
If any t.Error or t.Fail, is executed the test is considered to have failed.

                      package stringutil

                      import "testing"

                      func TestReverse(t *testing.T) {
                      	cases := []struct {
                      		in, want string     <--- anonymous type for these
                      	}{                                              /
                      		{"Hello, world", "dlrow ,olleH"},     <----'
                      		{"Hello, 世界", "界世 ,olleH"},
                      		{"", ""},
                      	}
                      	for _, c := range cases {
                      		got := Reverse(c.in)
                      		if got != c.want {
                      			t.Errorf("Reverse(%q) == %q, want %q", c.in, got, c.want)
                      		}
                      	}
                      }

if the above file xxxxx_test.go is in the dir $GOPATH/src/github.com/user/stringutil/xxxxx_test.go
                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^
run as:                                                               |
                                                                      |
$ go test github.com/user/stringutil   <------------------------------'
ok  	github.com/user/stringutil 0.165s


$ go test            will run all the *_test.go files in the current dir
$ go test -v         adds verbosity
$ go test --cover    built-in code-coverage for statements.
                     ex of output:
                                  $ go test -cover
                                  PASS
                                  coverage: 50.0% of statements
                                  ok     github.com/user/stringutil  0.009s


$  go test --cover -coverprofile=c.out         <--- this pair
$  go tool   cover -html=c.out -o c.html         <--- of commands creates a file c.out and then a c.html
                                                      (in the c.html opened in a browser I can see
                                                           in RED:  the lines "not covered"
                                                           in GREEN the lines "covered" )



===============================   ( TESTING with GoConvey )  https://github.com/smartystreets/goconvey

      . It adds a visual/colo
      . Directly integrates with go test

      1. install:   go get github.com/smartystreets/goconvey

      2. usage (impprt):
                    import (
                          "testing"
                          . "github.com/smartystreets/goconvey/convey"
                    )


      3. usage (function):

                    func TestSpec(t *testing.T) {


                        Convey("Given some integer with a starting value", t, func() {
                               x := 1                                      ^
                                                                           Only pass t into this top-level Convey call
                               Convey("When the integer is incremented", func() {
                                      x++

                                      Convey("The value should be greater by one", func() {
                                             So(x, ShouldEqual, 2)
                                      })
                               })
                        })
                    }

      4. run in the terminal
                       4.1   normal   go test


      5. see results in the browsers:
                       5.1   start the server:   $GOPATH/bin/goconvey
                       5.2   http://localhost:8080    <--- in the browser




___________________________________________________________________________ 'go list' command

given a package (ex.  $GOPATH/src/github.com/user/stringutil/......*.go)
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
I can use bash '$ find -iname ...' to list                            |
the go files and the test files or I can use the 'go list' command    |
                                                                      |
        $ go list -f={{.GoFiles}} github.com/user/stringutil  <-------'

        $ go list -f={{.TestGoFiles}} github.com/user/stringutil


        they produce:
                       . [handlers.go healthcheck.go]
                       . [handlers_test.go]


        with the `-f` (field) and the {{.xxxxx}} syntax
        I can print any xxxxxx field of this structure:

                type Package struct {
                    Dir           string // directory containing package sources
                    ImportPath    string // import path of package in dir
                    ImportComment string // path in import comment on package statement
                    Name          string // package name
                    Doc           string // package documentation string
                    Target        string // install path
                    Shlib         string // the shared library that contains this package (only set when -linkshared)
                    Goroot        bool   // is this package in the Go root?
                    Standard      bool   // is this package part of the standard Go library?
                    Stale         bool   // would 'go install' do anything for this package?
                    StaleReason   string // explanation for Stale==true
                    Root          string // Go root or Go path dir containing this package
                    ConflictDir   string // this directory shadows Dir in $GOPATH
                    BinaryOnly    bool   // binary-only package: cannot be recompiled from sources

                    // Source files
              ----> GoFiles        []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)
                    CgoFiles       []string // .go sources files that import "C"
                    IgnoredGoFiles []string // .go sources ignored due to build constraints
                    CFiles         []string // .c source files
                    CXXFiles       []string // .cc, .cxx and .cpp source files
                    MFiles         []string // .m source files
                    HFiles         []string // .h, .hh, .hpp and .hxx source files
                    FFiles         []string // .f, .F, .for and .f90 Fortran source files
                    SFiles         []string // .s source files
                    SwigFiles      []string // .swig files
                    SwigCXXFiles   []string // .swigcxx files
                    SysoFiles      []string // .syso object files to add to archive
              ----> TestGoFiles    []string // _test.go files in package
                    XTestGoFiles   []string // _test.go files outside package

                    // Cgo directives
                    CgoCFLAGS    []string // cgo: flags for C compiler
                    CgoCPPFLAGS  []string // cgo: flags for C preprocessor
                    CgoCXXFLAGS  []string // cgo: flags for C++ compiler
                    CgoFFLAGS    []string // cgo: flags for Fortran compiler
                    CgoLDFLAGS   []string // cgo: flags for linker
                    CgoPkgConfig []string // cgo: pkg-config names

                    // Dependency information
                    Imports      []string // import paths used by this package
                    Deps         []string // all (recursively) imported dependencies
                    TestImports  []string // imports from TestGoFiles
                    XTestImports []string // imports from XTestGoFiles

                    // Error information
                    Incomplete bool            // this package or a dependency has an error
                    Error      *PackageError   // error loading package
                    DepsErrors []*PackageError // errors loading dependencies
                }

___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________

___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________


     - GO is
              . compiled
              . statically typed
              . concurrent
              . garbage-collected
              . rigorous dependency management
              . light syntax (25 keywords)  (while C99  37; C++ 84)


              _________________________________________________________
              . rigorous dependency management

                C preprocessor style (to avoid include header files many times) :
                [the same even worse applies to C++]

                #ifndef _SYS_STAT_H_
                #define _SYS_STAT_H_     <--- even if the rest of the files is discarded by
                  ....                        subsequent includes still the files is open and read over and over
                #endif                        (in 1984 the ps unix command  ps.c opened #include <sys/stat.h> 37 times
                                              discarding 36.

                                              Moreover testing if an header is no more required just removing it in a file
                                              doesn't work because it could still be read in, trough other paths.

                                              Designers of library Plan 9, adopted a non-ANIS approach forbidding
                                              a header could have other #includes, but allowing includes only in .c
                                              This allowed to fix the above problems
                                              Moreover the possibility to remove the #ifndef speeded up the compilation time

              . GO doesn't compile if a package is not required  (avoiding having unused code on board)
                So no warning but error!

              . GO compile each imported package into an object.
                So any import X is the import of an X-object not X-source code
                The dependencies tree/graph is clean and with no cycles

                Moreover the data exported in each package are not an external file (like in some other languages)
                but are the FIRST section of the X-object format.

                So the compiler can stop reading when that section is over.
                      _________________________________________________________

                       Go can be parsed without type information or a symbol table;
                      _________________________________________________________

              . import { PPPPP / .... /  XXXXX }
                          ^^^^^^^^^^     ^^^^
                            full path    package name

                the vars exported from package X are then addressed as XXXXX.var  (so not the full path but only "package_name . var_name" )

              . GO decided to not worry about collisions so if there are 2 different X packages  ( path1/X  path2/X)
                to import in the same file, one must be renamed.

              . The path can be a URL  (ex. import "github.com/4ad/doozer")

              . GO can download remote packages just with "go get" (like a git clone)
                ex.
                    go get github.com/4ad/doozer

                Moreover the "go get" downloads dependencies recursively,
                that's possible only because the dependencies are explicit.

              _________________________________________________________
              . concurrent

              Go is not purely memory safe in the presence of concurrency.

              Go does not take a write-once approach.
              The reason is largely about familiarity and suitability for the problem domain.
              Go's concurrent features work well in a context familiar to most programmers.
              Go enables simple, safe concurrent programming but does not forbid bad programming.
              The motto is, "Don't communicate by sharing memory, share memory by communicating."
              _________________________________________________________
              Orthogonality is the property which guarantees that modifying a component
              doesn't propagate side effects to other components.
              Orthogonality reduces testing because it is easier to verify no side effects.

              An instruction set is said to be orthogonal if it lacks redundancy
              (i.e., there is only a single instruction that can be used to accomplish a given task)
              _________________________________________________________

              gofix:  tool to update old libraries and keep only 1 (the last) updated
              godoc:   document extractor, a program to verify that the API compatibility contract is maintained as the library is updated
              _________________________________________________________
              _________________________________________________________







































_________________________
created at Google in 2007 by
        Robert Griesemer,
        Rob Pike,
        Ken Thompson  <---- the same of UNIX & B-lang (father of C)





_________________________FEATURES

      . compiled           :  there are 2 main compilers:
                                 . gc  :  Google's Go compiler.
                                                 open source
                                                 targets various platforms
                                                       Linux,
                                                       OS X,
                                                       Windows,
                                                       various BSD and Unix
                                                       mobile devices/ smartphones

                                 . gccgo : a GCC frontend.


      . statically typed
      . garbage collector
      . memory safety
      . concurrent programming
      . structural type  (in contrast with
                               nominative systems
                               duck typing
                         )

_________________________
_________________________
_________________________
