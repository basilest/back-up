
go build -gcflags "-m -m"




.   GO can be installed with a package manager (homebrew, apt-get, ..)
    and i.e. on a mac it goes in /usr/local/go/bin/go

    or as it is open source:  git@github.com:golang/go.git
    it can also be compiled from source:

                      . clone the repo in ~
                        that will create dir: ~/go

            .   anyhow the source code is nowadays written in GO itself
                so to compile it, there are different options:


                1 option is to download the last stable old version of GO
                  still written in C and compile it (with gcc)

                  https://storage.googleapis.com/golang/go1.4-bootstrap-20161024.tar.gz

                      mkdir ~/go.bin/
                      cd ~/go.bin/ && wget ......tar.gz && tar xzvf ....

                  in this way you have the GO (old) compiler: ~/go.bin/bin/go


                  1.a. compile the source in ~/go/src (with $GOROOT_BOOTSTRAP=~/go.bin
                       no other env vars are required now, when complete it is usefull to set
                       GOPATH (while GOROOT since some version of GO is nomore to be set
                       but builtin into GO (type: "go env" to see it)) and update PATH to find them )
                       having the executable of the new compiler (compiled with the old)
                       that is located in ~/go/bin
                           now $GOROOT_BOOTSTRAP is no more  needed
                           while in ~/.bash_profile add:
                               export GOPATH="$HOME/go"
                               export PATH="$PATH:$GOPATH/bin"


                       recompile again (having the executable compiled with the new code)
                       nb. it's maybe  better to save the previous go (mv ~/go/bin/go ~/go/bin/go.prev)
                           as at each rebuilt it's overwritten

                2 install with a package manager, then follow 1.a

                compiling the code
                you need


                     2. install a binary version of GO









1) create a dir ~/go.bootstrap
2) download there the go1.4-bootstrap-20161024.tar.gz and untar  (it will create a 'root' dir ./go)
3) optionally mv everything up one level (get rid of './go' dir)
4) cd ./src && ./all.bash    (it will compile with the gcc, it will create the dir ./bin where it will create 2 binaries (go / gofmt)
                                                                                                        (gofmt is the formatter: use it on the command line
                                                                                                         as  > gofmt a.go)
5) so now we have the go compiler: (the old written in C: version 1.4)
6) clone the GO source code:
           6.a    mkdir ~/go.src
           6.b    cd ~/go.src  && git clone git@github.com:golang/go.git
           6.c    optionally get rid of the 'root' './go' dir created and move all up one level.
7) to compile the new GO source with the GO1.4 compiler is only required to define 1 env var:
   export GOROOT_BOOTSTRAP="$HOME/go.bootstrap"    (it must point to the 'tree' (so up 1 level the ./bin/go executable)
8) add the path to find the executable: export PATH=$PATH:$GOROOT_BOOTSTRAP/bin
9) now we can compile:
           9.a    cd ~/go.src/src && ./all.bash  (it will compile with the go1.4, it will create the dir ./bin where it will create 2 binaries (go / gofmt)

10) both GOROOT_BOOTSTRAP and PATH have been set at the command line.
    (even the full ~/go.bootstrap dir is no more required)
    The setting to write in bash_profile is PATH:$PATH:~/go.src/bin   (<-- this will find our last version of go)


    The problem to compile GO with a go compiler, is that the go compiler must be
    identified as a
         FULL-tree located by the var GOROOT_BOOTSTRAP
    this means that if GOROOT_BOOTSTRAP = xxxxx than there will be
                     xxxxx / bin / <---- with the executables
                     xxxxx / src    with the code
                     xxxxx / pkg    with the related import

    The new GO tree with the new code (ex in the dir ~/yyyyy
    ~/yyyyy/src   ~/yyyyy/pkg)
    will be compiled with cd ~/yyyyy/src && ~/.all.bash
    with the go compiler located in ~/xxxxx/bin   <--- this must be in $PATH

___________________________________________________________________________ PACKAGES

      package main   <--------- Every Go program is made up of packages.
                                Programs start running in package main.

      import (       <---  this is called 'factored' layout (the suggested one)
        "fmt"              this is also possible  ------->    import "fmt"
        "math/rand"                                           import "math/rand"
      )


___________________________________________________________________________ Exported names

    are visible outside (are exported)
    only names starting with an UPPER case
___________________________________________________________________________ GO declaration way

  Even if coming from C,
  GO decided to use a different style in TYPEs declarations

      int x;            x int                                           x is an int
      int *p;           p *int              the GO way is to match      p is a pointer to an int
      int a[3];         a [3]int            the human sentence          a is an array of ints
    ___ C _____       ____ GO_____

___________________________________________________________________________ BASIC TYPE

         int  int8  int16  int32  int64
         uint uint8 uint16 uint32 uint64 uintptr

         byte // alias for uint8

         string

         bool

         rune // alias for int32
              // represents a Unicode code point

         float32 float64

         complex64 complex128
___________________________________________________________________________ VAR

     var    a, b, c   int       <--- var allows to declare a (list) of vars
                                     the type of all the list is at the end.

     var    a, b, c   int  = 1,2,3   <--- n.b. the syntax to also initialise.


     c := 3                    <--- :=  is called the short assign. statem.
                                        it allows to skip the TYPE that is inferred from the right and value
                                        :=   can be used only for local vars  (inside function)

     var (                      <---  this grouping layout is also possible
         ToBe   bool       = false
         MaxInt uint64     = 1<<64 - 1
         z      complex128 = cmplx.Sqrt(-5 + 12i)
     )
___________________________________________________________________________ FUNCTIONS

     func add(x int, y int, z int)
     func add(x, y, z int)       <--- if 2 or more args are of the same type
                                      I can add the type  just after the last

     func swap(x, y string) (string, string)     <--- a function can return any number of args (here only the TYPEs are specified)
     func swap(x, y string) (string a, string b) <--- in this case the return TYPEs are 'named'  (name 'a' and 'b')

                                                      When there are 'named' return args
                                                      it's supposed there local vars with those names defined then in the function
                                                      In this case I case use both of the following notations:

                                                           return (a,b)    <--  explicit form
                                                           return          <-- 'naked' form. local vars 'a' and 'b' are returned



___________________________________________________________________________ ZERO VALUES

    var not initialised have this ZERO values:

             num types : 0
             bool      : false
             string    : ""
___________________________________________________________________________  TYPE CONVERSION

               xxxxx(a)           <----- var a is converted to type xxxxx

               var i int = 42                          i := 42
               var f float64 = float64(i)     --->     f := float64(i)
               var u uint = uint(f)                    u := uint(f)

              _____ LONG WAY __________              ____ SHORT______


             UNLIKE C (where this is possible:  int i = 258; char c = i;)
                      the type must be always indicated explicitly




___________________________________________________________________________ CONSTANTS

    just as expected:    const Pi = 3.14         (cannot be used ':=' )

___________________________________________________________________________ FOR

                                             'for' is the only loop construct
    for i := 0; i < 10; i++ {          <---- the are no '('  ')'
        sum += i                             while the  '{'  '}'  are required
    }


    sum := 1
    for ; sum < 1000; {                <--- only the 2nd part (test-of-end-condition)
        sum += sum                          can be usually specified
    }


    sum := 1
    for {                <--- if omitting all, it becomes a forever loop
          ...
    }
___________________________________________________________________________ IF

       if x < 0 {                   <---- like 'for' : NO '(' ')'   YES '{' '}'


       if v := 4; v < lim {       <--- like 'for' a pre-part to init (only 1 var) is possible


___________________________________________________________________________ SWITCH


     switch os := runtime.GOOS; os {                switch os := runtime.GOOS; os {
        case "darwin":                                 case "darwin":
             fmt.Println("OS X.")                           fmt.Println("OS X.")
                                                            fallthrough                       <--- no 'break' are required
        case "linux":                                  case "linux":                               a 'fallthrough' will go down to the next
             fmt.Println("Linux.")                          fmt.Println("Linux.")
        default:                                       default:
             fmt.Printf("%s.", os)                          fmt.Printf("%s.", os)
     }                                              }



               n.b.  the 'cases' are tested in SEQUENCE
                     (like a short circuit)  and can so be of strange types:

                     switch i {
                     case 0:
                     case f():    <--- a function     (that anyhow is never executed if i=0)
                     }

               n.b.  Switch without a condition is the same as switch true.
                     'switch {'

___________________________________________________________________________ DEFER


       'defer' keyword  tag something to be executed before return.

       func main() {                                                                                   for i := 0; i < 10; i++ {       --->     done
            defer fmt.Println("world")  <--- 'defer' are pushed on the stack, so called as LIFO            defer fmt.Println(i)                 9
                                                                                                       }                                        8
            fmt.Println("hello")                                                                       fmt.Println("done")                      7
       }                                                                                                                                        6
                                                                                                                                                5
                                                                                                                                                4
                                                                                                                                                3
                                                                                                                                                2
                                                                                                                                                1
                                                                                                                                                0
___________________________________________________________________________ POINTER

       '*' and '&' like C:

           i := 42
           var p *int
           p = &i

       A N Y H O W   note that UNLIKE C
                     there is NO-aritmetic for pointers


___________________________________________________________________________ STRUCT

     type Vertex struct {
        X int                                v := Vertex{1, 2}
        Y int                                v.X = 4
     }


    _____ POINTER TO STRUCT

        p := &v               (*p).X = 4   <---- the formal way
                                 p.X = 4   <---- syntactic sugar  (can skip the dereference)

___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
___________________________________________________________________________
