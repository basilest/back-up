
  The term [Docker] can refer to 3 different things:

             1  The "Docker Engine", the infrastructure plumbing software
                       that runs and orchestrates containers.
                       available in both:
                              - Enterprise Edition (EE)  supported 12 months
                              - Community  Edition (CE)  supported  4 months


                              Starting from Q1 2017 Docker version numbers follow the
                              YY.MM-xx versioning scheme, similar to Ubuntu and other projects.
                              Ex. 18.06.0-ce = first release of the Community Edition in June 2018


             2  Docker is part of a open-source project on GitHub (now called Moby: most written in Go)
                       The goal of the Moby project is to break Docker down into more modular components.
                       Being more and more modular, I can substitute some componenets (ex. networking)
                       with 3rd-party, even if Docker-Inc having to turn it into profit
                       makes native modules good enough to not require external plugins.

             3  Docker, Inc. is the company (based out of San Francisco) which is Docker overall maintainer
                             (and which offers commercial support)

             Note:  “The Open Container Initiative (OCI)”
                    is responsible for standardizing the most fundamental components
                    of container infrastructure such as image format and container runtime.
                    This was due as Docker was growing quick in many different directions, so the aim
                    was to keep the free development among 3rd-parties under control.

                    As of Docker 1.11, the Docker Engine architecture conforms to the OCI runtime spec.


       https://play-with-docker.com/    <----- good to try online



       3 main pieces of DOCKER:

            1. engine      $ docker         --version
            2. compose     $ docker-compose --version
            3. machine     $ docker-machine --version


__________________________________________________________________________________________________
|     docker --version              ___
|                                      \__Docker version 18.09.2, build 6247962
|
|     docker version                ___   nb. without --      it gives more info for Client and Sever
|                                      \__
|                                           Client: Docker Engine - Community   <---------------------- the CLIENT
|                                            Version:           18.09.2
|                                            API version:       1.39
|                                            Go version:        go1.10.8
|                                            Git commit:        6247962
|                                            Built:             Sun Feb 10 04:12:39 2019
|                                            OS/Arch:           darwin/amd64
|                                            Experimental:      false
|
|                                           Server: Docker Engine - Community   <---------------------- the SERVER
|                                            Engine:
|                                             Version:          18.09.2
|                                             API version:      1.39 (minimum version 1.12)
|                                             Go version:       go1.10.6
|                                             Git commit:       6247962
|                                             Built:            Sun Feb 10 04:13:06 2019
|                                             OS/Arch:          linux/amd64
|                                             Experimental:     true
|
|     docker info                       even more verbose
|
|     docker-compose --version      ___
|                                      \__ docker-compose version 1.23.2, build 1110ad01
|
|     docker-compose version
|                                       docker-compose version 1.23.2, build 1110ad01
|                                       docker-py version: 3.6.0
|                                       CPython version: 3.6.6
|                                       OpenSSL version: OpenSSL 1.1.0h  27 Mar 2018
|
|                                 . Commands:
|                                 .   build              Build or rebuild services
|                                 .   bundle             Generate a Docker bundle from the Compose file
|                                 .   config             Validate and view the Compose file
|                                 .   create             Create services
|                                 .   down               Stop and remove containers, networks, images, and volumes
|                                 .   events             Receive real time events from containers
|                                 .   exec               Execute a command in a running container
|            docker-compose       .   help               Get help on a command
|                                 .   images             List images
|                                 .   kill               Kill containers
|                                 .   logs               View output from containers
|                                 .   pause              Pause services
|                                 .   port               Print the public port for a port binding
|                                 .   ps                 List containers
|                                 .   pull               Pull service images
|                                 .   push               Push service images
|                                 .   restart            Restart services
|                                 .   rm                 Remove stopped containers
|                                 .   run                Run a one-off command
|                                 .   scale              Set number of containers for a service
|                                 .   start              Start services
|                                 .   stop               Stop services
|                                 .   top                Display the running processes
|                                 .   unpause            Unpause services
|                                 .   up                 Create and start containers
|                                 .   version            Show the Docker-Compose version information
|
|     docker-machine --version      ___
|                                      \__ docker-machine version 0.16.1, build cce350d7
|
|__________________________________________________________________________________________________




      image  :  is an EXEC package (including all what is required (
                                          - the application to run
                                                    +
                                          - required LIBRARIES
                                          - required ENV vars
                                          - required CONFIG file
                                          )
                Said otherwise an image contains enough of an operating system (OS),
                as well as all the code and dependencies to run whatever application it’s designed for.
                An image is a stopped container. It's the build static output
                Like with a "git pull"  images are pulled down with "docker pull"
                from an image registry. The most popular registry is Docker Hub.


      container  :  it's a running instance of an image
                    (it has a proc id:   docker ps    # to see all the containers)
                    I cannot delete an image till some of its containers
                    are still running

      diff with VM:  VM               any VM includes its own full-blown OS
                     Containers       All containers on a single host share a single OS.
                                      This would mean that a containerized app designed
                                      to Windows host will not run on a Linux host.

                                      Anyhow thanks to the effort of Microsoft and Docker
                                      (Docker for Windows)
                                      is possible the opposite: run Linux containers in Windows

                                      Docker for Mac will not give you the Docker Engine
                                      running natively on the Mac OS Darwin kernel.
                                      Behind the scenes, the Docker daemon is running inside a
                                      lightweight Linux VM which exposes the daemon and API to the
                                      Mac environment, so I can open a terminal and
                                      use the regular Docker commands.

                                      So it’s Docker on Linux under the hood and it only works
                                      with Linux-based containers.

                                      The lightweight Linux VM is
                                         Linux: a highly tuned Linux distro called Moby that is based on Alpine Linux.
                                         VM: “  HyperKit for the lightweight hypervisor.
                                                HyperKit is based on the xhive hypervisor.

                                      $ docker version

                                            Client:
                                              .....
                                             OS/Arch:      darwin/amd64    <--- Mac

                                            Server:
                                              .....
                                             OS/Arch:      linux/amd64     <--- the Linux inside the VM

                                      Client / Server on Mac and Linux
                                      communicate between an IPC/Unix socket

                                                /var/run/docker.sock

|__________________________________________________________________________________________________

      docker image ls                   to see all the images
      docker images                     (<--  same)

                                        REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
                                        friendlyhello               latest              af97d893c91f        3 months ago        131MB
                                        python                      2.7-slim            0dc3d8d47241        3 months ago        120MB
                                        portainer/portainer         latest              00ead811e8ae        5 months ago        58.7MB
                                        confluentinc/cp-kafka       5.0.0               373a4e31e02e        5 months ago        558MB
                                        confluentinc/cp-zookeeper   5.0.0               3cab14034c43        5 months ago        558MB

                                        note that a 'docker build --tag=xxxxx .  ' in the cur dir . where I have a 'Dockerfile' will
                                        create the output not in the same dir: ./xxxxx but in my machine’s Docker image registry
                                        so that I can see the image xxxx with 'docker image ls'

      docker image ls --digests
                                        REPOSITORY                  TAG         DIGEST                                                                    IMAGE ID      CREATED        SIZE
                                        test                        latest      <none>                                                                    063f1b91a843  3 hours ago    71.5MB
                                        alpine                      latest      sha256:72c42ed48c3a2db31b7dafe17d275b634664a708d901ec9fd57b1529280f01fb   961769676411  9 days ago     5.58MB
                                        basilest/get-started        part2       sha256:4ee440ad1f9f9c56ede69b01c4fa95c764eb1d2045892bb1f33756e0a41db2d2   612cc1b42bc6  6 months ago   131MB
                                        friendlyhello               latest      <none>                                                                    612cc1b42bc6  6 months ago   131MB
                                        <none>                      <none>      <none>                                                                    af97d893c91f  9 months ago   131MB
                                        python                      2.7-slim    sha256:f82db224fbc9ff3309b7b62496e19d673738a568891604a12312e237e01ef147   0dc3d8d47241  9 months ago   120MB
                                        portainer/portainer         latest      sha256:07c0e19e28e18414dd02c313c36b293758acf197d5af45077e3dd69c630e25cc   00ead811e8ae  11 months ago  58.7MB
                                        confluentinc/cp-kafka       5.0.0       sha256:9bc4b7a7234338cae2eaf5da6b2e563668f6ca6cd3544bde009029517035168b   373a4e31e02e  12 months ago  558MB
                                        confluentinc/cp-zookeeper   5.0.0       sha256:384924ef3ac598973cf15abbface4b05dcbeff7894188ccb255a46e53b7043c4   3cab14034c43  12 months ago  558MB


      docker image ls --filter dangling=true      shows dangling images   (the ones with    REPOSITORY & TAG = <none>  <none>)
                                                  They occur when building a new image and tagging it with an existing tag.
                                                  Docker will remove the tag from the existing image, which becomes 'dangling'
                                                  (values:  --filter dangling=true   or --filter dangling=false)

                                                  Other: --filter

                                                     --filter before  nnnnn/iiiii : returns images created before the specified image (by name or ID)
                                                     --filter since   nnnnn/iiiii : ....................... after
                                                     --filter label   lllll/ll=vv : returns  images based on the presence of
                                                                                    a label or label and value.
                                                                                    The docker image ls command does not display labels in its output.
                                                     --filter=reference="*:latest"  all the ones tagged with latest


      docker image ls --format "{{.Size}}"                              99.3MB
                                                                        111MB
                                                                        82.6MB
                                                                        88.8MB
                                                                        4.15MB
                                                                        108MB


      docker image ls --format "{{.Repository}}: {{.Tag}}: {{.Size}}
                                                                        dodge:  challenger: 99.3MB
                                                                        ubuntu: latest:     111MB
                                                                        python: 3.4-alpine: 82.6MB
                                                                        python: 3.5-alpine: 88.8MB
                                                                        alpine: latest:     4.15MB
                                                                        nginx:  latest:     108MB”







      docker image prune                removes dangling images
      docker image prune -a             removes dangling images AND all unused images (the ones with no running containers)


      docker image rm <image id>        to Remove specified image from this machine  (it removes all the internal layers that are not shared
                                                                                      by other images. The shared ones are kept as blob in the repo)
      docker image rm $(docker image ls -a -q)           to Remove all images

      docker image build -t test:latest .      reads in the current dir the 'Dockerfile' and creates a container called 'test' and tagged 'latest'
      docker image pull alpine:latest          it pulls from Docker Hub the repo alpine image 'latest'
                                               alpine is a light Linux distro (about 4MB) perfect for containers and its quick boot time.

                                               :latest    is optional. The version-tag if missing is by default :latest
                                               so docker image pull alpine:latest    is the same as
                                                  docker image pull alpine

                                               Be carefull anyhow: latest is an arbitrary tag and is not guaranteed to point to the newest image in a repository!

      docker image pull -a alpine       pulls all images
      docker image pull alpine@sha256:c0537...7c0a7726c88e2bb7584dc96     to pull specifying the digest
      docker image pull ubuntu:latest   a pull produces this output:

                                        latest: Pulling from library/ubuntu
                                        952132ac251a: Pull complete             <------ 1
                                        82659f8f1b76: Pull complete                     2    I see the num of layers
                                        c19118ca682d: Pull complete                     3    which build the image: here 5
                                        8296858250fe: Pull complete                     4
                                        24e0251a0e2c: Pull complete                     5
                                        Digest: sha256:f4691c96e6bbaa99d...28ae95a60369c506dd6e6f6ab”


      docker image inspect ubuntu:latest         the inspect command is the proper one to see the layers:
                                                 [
                                                     {
                                                         "Id": "sha256:bd3d4369ae.......fa2645f5699037d7d8c6b415a10",
                                                         "RepoTags": [
                                                             "ubuntu:latest"

                                                         <Snip>

                                                         "RootFS": {
                                                             "Type": "layers",
                                                             "Layers": [
                                                                 "sha256:c8a75145fc...894129005e461a43875a094b93412",
                                                                 "sha256:c6f2b330b6...7214ed6aac305dd03f70b95cdc610",
                                                                 "sha256:055757a193...3a9565d78962c7f368d5ac5984998",
                                                                 "sha256:4837348061...12695f548406ea77feb5074e195e3",
                                                                 "sha256:0cad5e07ba...4bae4cfc66b376265e16c32a0aae9"
                                                             ]
                                                         }
                                                     }
                                                 ]

                                          S H A R I N G   L A Y E R S     Docker is able to understand if it already has 1 layer
                                                                          for an image and it doesn't pull that again

                                                                          docker image pull -a nigelpoulton/tu-demo    <----------- -a : all images

                                                                           latest: Pulling from nigelpoulton/tu-demo
                                                                           237d5fcd25cf: Pull complete       <--- download
                                                                           a3ed95caeb02: Pull complete       <--- download
                                                                           <Snip>
                                                                           Digest: sha256:42e34e546cee61adb100...a0c5b53f324a9e1c1aae451e9

                                                                           v1: Pulling from nigelpoulton/tu-demo
                                                                           237d5fcd25cf: Already exists      <----no download
                                                                           a3ed95caeb02: Already exists      <----no download
                                                                           <Snip>
                                                                           Digest: sha256:9ccc0c67e5c5eaae4beb...24c1d5c80f2c9623cbcc9b59a

                                                                           v2: Pulling from nigelpoulton/tu-demo
                                                                           237d5fcd25cf: Already exists      <----no download
                                                                           a3ed95caeb02: Already exists      <----no download
                                                                           <Snip>
                                                                           eab5aaac65de: Pull complete       <---- download








      docker search xxxx                                   searches in Docker Hub for every repo containing xxxx in the NAME
      docker search alpine --filter "is-official=true"     gives only official repos
      docker search alpine --filter "is-automated=true"    gives only repo with automated builds

      docker ps                         to see all the containers

                                        CONTAINER ID        IMAGE                             COMMAND                  CREATED             STATUS              PORTS                                NAMES
                                        7b7b15441b98        portainer/portainer               "/portainer"             2 months ago        Up 10 minutes       0.0.0.0:9000->9000/tcp               portainer
                                        f00d1e12d7ff        confluentinc/cp-kafka:5.0.0       "/etc/confluent/dock…"   3 months ago        Up 9 minutes        9092/tcp, 0.0.0.0:29093->29093/tcp   kafka
                                        b9254eb9b9c1        confluentinc/cp-zookeeper:5.0.0   "/etc/confluent/dock…"   3 months ago        Up 10 minutes       2181/tcp, 2888/tcp, 3888/tcp         zookeeper

      docker container ls --all         to see all the containers

                                        CONTAINER ID        IMAGE                             COMMAND                  CREATED             STATUS              PORTS                                NAMES
                                        7b7b15441b98        portainer/portainer               "/portainer"             2 months ago        Up 8 minutes        0.0.0.0:9000->9000/tcp               portainer
                                        f00d1e12d7ff        confluentinc/cp-kafka:5.0.0       "/etc/confluent/dock…"   3 months ago        Up 8 minutes        9092/tcp, 0.0.0.0:29093->29093/tcp   kafka
                                        b9254eb9b9c1        confluentinc/cp-zookeeper:5.0.0   "/etc/confluent/dock…"   3 months ago        Up 8 minutes        2181/tcp, 2888/tcp, 3888/tcp         zookeeper

      docker container ls -aq           to see only containes_id (note -aq not --aq)

                                        7b7b15441b98
                                        f00d1e12d7ff
                                        b9254eb9b9c1



      docker container stop             to stop a container giving the ID or the NAME
                                           docker container stop 7b7b15441b98
                                           docker container stop confluentinc/cp-kafka:5.0.0

      docker container kill <id>        to Force shutdown
      Control-pq                        to exit from the container keeping it running (....like sending in bg)
      docker container exec -it nnnnn/iiiiii   bash       to attach back (-it interactively) to the container named nnnnnn or with id iiiiii

      docker container rm <hash>                         # Remove specified container from this machine
      docker container rm $(docker container ls -a -q)   # Remove all containers

      docker container run -d  --name web1  --publish 8080:8080  test:latest       creates (-d detached or in bg) a running instance (named 'web1') of the container 'test' tagged 'latest'
      docker container run     --name ctr1 -it alpine:latest sh                    creates (-it interactively on fg) a running instance (named 'ctrl') of the container 'alpine' tagged 'latest'
                                                                                   and inside it executes 'sh'



      docker login                      to Log in this CLI session using your Docker credentials  (this will allow to push and pull to dockerhub)
                                        note the terminology:
                                             docker repository <----> git repository
                                             docker push/pull  <----> git push/pull
                                             docker image      <----> git branch     ==>  so you usually push / pull 1 IMAGE

                                             a docker image is in the form:
                                                          username / repository : tag

      docker tag <image> username/repository:tag         # Tag <image> for upload to registry
      docker push username/repository:tag     to Upload tagged image to registry
      docker run username/repository:tag      to Run image from a registry


      _______________________________________________ SCALE AN APP
  |                            terminology:
  |
  |                                     TASK:  1 single container running in a service.
  |                                            Tasks are given unique IDs that numerically increment,
  |                                            up to the number of replicas you defined in docker-compose.yml
  |
  |                                     SWARM: a group of machines that are running Docker and joined into a cluster.
  |                                            The normal Docker commands are executed on a cluster by a swarm manager.
  |
  |                                     NODES: The machines in a swarm can be physical or virtual.
  |                                            After joining a swarm, they are referred to as nodes.
  |
  |                                     WORKER: Swarm managers are the only machines in a swarm that can execute your commands,
  |                                            or authorize other machines to join the swarm as workers.
  |                                            Workers are just there to provide capacity and do not have the authority
  |                                            to tell any other machine what it can or cannot do.
  |
  |   docker swarm init                               to enter 'swarm mode' (this host will become the 'manager')
  |                                                   must be executed before we can use any 'docker stack deploy'
  |   docker swarm join                               on other machines to join the swarm as workers.
  |   docker swarm leave --force                      Take down a single node swarm from the manager
  |
  |   docker stack ls                                 List stacks or apps
  |   docker stack deploy -c <composefile> <appname>  Run the specified Compose file  ex. docker stack deploy -c docker-compose.yml getstartedlab
  |   docker stack rm <appname>                       Tear down an application        ex. docker stack rm getstartedlab
  |
  |   docker service ls                               List running services associated with an app
  |   docker service ps <service>                     List tasks associated with an app
  |
  |   docker inspect <task or container>              Inspect task or container  (it returns a big json)    ex.  docker inspect e3b416239775
  |
  |   docker-machine create --driver virtualbox myvm1
  |
  |                Creating CA: /Users/sbasile/.docker/machine/certs/ca.pem
  |                Creating client certificate: /Users/sbasile/.docker/machine/certs/cert.pem
  |                Running pre-create checks...
  |                (myvm1) Image cache directory does not exist, creating it at /Users/sbasile/.docker/machine/cache...
  |                (myvm1) No default Boot2Docker ISO found locally, downloading the latest release...
  |                (myvm1) Latest release for github.com/boot2docker/boot2docker is v18.09.2
  |                (myvm1) Downloading /Users/sbasile/.docker/machine/cache/boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v18.09.2/boot2docker.iso...
  |                (myvm1) 0%....10%....20%....30%....40%....50%....60%....70%....80%....90%....100%
  |                Creating machine...
  |                (myvm1) Copying /Users/sbasile/.docker/machine/cache/boot2docker.iso to /Users/sbasile/.docker/machine/machines/myvm1/boot2docker.iso...
  |                (myvm1) Creating VirtualBox VM...
  |                (myvm1) Creating SSH key...
  |                (myvm1) Starting the VM...
  |                (myvm1) Check network to re-create if needed...
  |                (myvm1) Found a new host-only adapter: "vboxnet4"
  |                (myvm1) Waiting for an IP...
  |                Waiting for machine to be running, this may take a few minutes...
  |                Detecting operating system of created instance...
  |                Waiting for SSH to be available...
  |                Detecting the provisioner...
  |                Provisioning with boot2docker...
  |                Copying certs to the local machine directory...
  |                Copying certs to the remote machine...
  |                Setting Docker configuration on the remote daemon...
  |                Checking connection to Docker...
  |                Docker is up and running!
  |               To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env myvm1
  |
  |
  |   docker-machine ls                         to list the machines and get their IP addresses.
  |
  |                     NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORS
  |                     myvm1   -        virtualbox   Running   tcp://192.168.99.100:2376           v18.09.2
  |                     myvm2   -        virtualbox   Running   tcp://192.168.99.101:2376           v18.09.2
  |
  |
  |
  |
  |
  |
  |





      docker network create confluent
      docker network ls

      docker volume ls
      docker volume create portainer_data


------------      Dockerfile

      . it's like a Makefile. It's used to builld an image (which I can then see with 'docker image ls')

      . docker build --tag=xxxx .              <--- it will give the default value 'latest' to the TAG column in 'docker image ls'
      . docker build --tag=xxxx:v0.0.1 .       <--- it gives a value for the TAG column

      . ex of  Dockerfile
                    | # Use an official Python runtime as a parent image
                    | FROM python:2.7-slim
                    |
                    | # Set the working directory to /app
                    | WORKDIR /app
                    |
                    | # Copy the current directory contents into the container at /app
                    | COPY . /app
                    |
                    | # Install any needed packages specified in requirements.txt
                    | RUN pip install --trusted-host pypi.python.org -r requirements.txt <-------- ./requirements.txt :   | Flask
                    |                                                                               this 2 lines file ->  | Redis
                    | # Make port 80 available to the world outside this container
                    | EXPOSE 80                            <------   I will be able to run my app (tagged as xxxx) with:   'docker run -p 4000:80 xxxx'
                    |
                    | # Define environment variable
                    | ENV NAME World
                    |
                    | # Run app.py when the container launches
                    | CMD ["python", "app.py"]    <----------  ./app.py: file where I wrote some Python code

      . note Docker-syntax commands like:

                     COPY
                     EXPOSE
                     ENV            (ENV is also used to manage proxy settings
                                     so that my app will be able to access the network:

                                          |    ENV http_proxy  host:port
                                          |    ENV https_proxy host:port
------------      DNS issues
      Besides the 'ENV ...proxy' settings
      also the DNS could need to be set:

        /etc/docker/daemon.json   ---->  {
                                             "dns": ["your_dns_address", "8.8.8.8"]
                                         }

      then make docker re-source it:

      'sudo service docker restart'


------------      run
      docker run -p 4000:80 xxxx                   to run an image (tagged as xxxx) mapping localhost port 4000 to the port 80 inside the docker image
                                                   (which was 'exposed' in the 'Dockerfile' )

      docker run -d -p 4000:80 xxxx                -d to 'detach' and run in background giving back the prompt.




------------      docker-compose.yml
               to deploy a service (i.e. a container)

              | version: "3"
              | services:
              |   web: <------------------------------------------ 0) define 'web' container
              |     # replace username/repo:tag with your name and image details
              |     image: basilest/get-started:part2  <---------- 1) the image for the service
              |     deploy:
              |       replicas: 5   <----------------------------- 2) run 5 instances of the  service
              |       resources:
              |         limits:
              |           cpus: "0.1" <--------------------------- 3) limit each one to use, at most, 10% of the CPU (across all cores), and 50MB of RAM.
              |           memory: 50M
              |       restart_policy:
              |         condition: on-failure <------------------- 4) Immediately restart containers if one fails.
              |     ports:
              |       - "4000:80"   <----------------------------- 5) Map port 4000 on the host to web’s port 80.
              |     networks:
              |       - webnet  <--------------------------------- 6) share port 80 for web-container via a load-balanced network called webnet.
              | networks:                                            (Internally, the containers themselves publish to web’s port 80 at an ephemeral port)
              |   webnet:



------------ PORTAINER    (https://portainer.readthedocs.io/en/stable/deployment.html)

    docker volume create portainer_data
    docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer



                  PERSISTENT DATA

                  By default, Portainer stores in "/data" the container's data.
                  to keep your changes after restart/upgrade of the Portainer container
                  I can use a bind mount on the Docker host folder:


    docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v /path/on/host/data:/data portainer/portainer
                                                                                                                 ^^^^^^^^^^^^^^^^^^







     Install and start Zookeeper

                                   docker run -d \
                                       --net=confluent \
                                       --name=zookeeper \
                                       --restart=always \
                                       -e ZOOKEEPER_CLIENT_PORT=32181 \
                                       confluentinc/cp-zookeeper:5.0.0

     Install and start Kafka

                                   docker run -d \
                                       --net=confluent \
                                       --name=kafka \
                                       --restart=always \                                                      This is the local host (i.e. Mac) IP
                                       -p 29093:29093 \                                                       /
                                       -e KAFKA_ZOOKEEPER_CONNECT=zookeeper:32181 \                          /
                                       -e KAFKA_ADVERTISED_LISTENERS=INSIDE://localhost:29092,OUTSIDE://172.19.68.36:29093 \
                                       -e KAFKA_LISTENER_SECURITY_PROTOCOL_MAP=INSIDE:PLAINTEXT,OUTSIDE:PLAINTEXT \
                                       -e KAFKA_INTER_BROKER_LISTENER_NAME=INSIDE \
                                       -e KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1 \
                                       confluentinc/cp-kafka:5.0.0



     Listing your Kafka Topics

                                   docker run \
                                       --net=confluent \
                                       --rm confluentinc/cp-kafka:5.0.0 \
                                       kafka-topics --list --zookeeper zookeeper:32181

    Running Kafka Console Consumer

                                   docker exec -it kafka /usr/bin/kafka-console-consumer --bootstrap-server localhost:29092 --topic PA_STREAMING_2 --from-beginning # Ctrl C to exit



    option -v     : to mount a volume (dir or file) so that it's visible in the docker from the host filesystem.

                docker run -d --name nginx -p 443:443 \
                           -v "/nginx.ssl.conf:/etc/nginx/conf.d/default.conf" \
                           -v "/ssl-cert.pem:/etc/nginx/certs/ssl-cert.pem" \
                           -v "/ssl-cert.key:/etc/nginx/certs/ssl-cert.key" \
                           nginx



    option -w     : to use ENV variables;


                The `docker run` command has -e and --env-file options to provide environments variables for processes inside the container


    Dockerfile:



                docker run -d --name nginx -p 443:443 \
                   -v "/ssl-cert.pem:/etc/nginx/certs/ssl-cert.pem" \
                   -v "/ssl-cert.key:/etc/nginx/certs/ssl-cert.key"\
                   -e "NGINX_ENABLE_SSL=True" \      <------------   we want to have a config var to control how the docker is config.
                   our-nginx



                Dockerfile:

                FROM nginx
                    RUN apt-get update && \
                        apt-get install python-dev python-setuptools
                    RUN easy_install j2cli

                    COPY nginx.conf.j2 /templates/
                    COPY docker-entrypoint.sh /         <-----------------------   #!/bin/bash -e
                    ENTRYPOINT ["/docker-entrypoint.sh"]                           j2 /templates/nginx.conf.j2 > /etc/nginx/conf.d/default.conf
                    CMD ["nginx", "-g", "daemon off;"]                             exec "$@"





                J2 Template

                server {
                        server_name _;
                        {% if NGINX_ENABLE_SSL|default('False') == 'True' %}
                        listen 443;
                        ssl on;

                        ssl_certificate /etc/ssl/certs/ssl-cert.pem;
                        ssl_certificate_key /etc/ssl/private/ssl-cert.key;
                        {% else %}
                        listen 80;
                        {% endif %}

                        location / {
                            proxy_pass http://localhost:8080;
                        }
                    }



------------      docker  (engine)
    docker ps -a        to show all containers
    docker run
                            --name           assign a name to the container:                            ex.  --name my_container
                            -d  (--detach)   runs the container in the background of the terminal.      ex.  -d
                            -e  (--env)      sets an ENV var using a KEY=VALUE pair.                    ex.  -e KEY=VALUE    (I can add many -e flags in the cmd line)
                            --env-file       if ENV vars are in file, I can pass the full path here     ex. -env-file ./env.list
                            --ip             declare an IP address.                                     ex. --ip=10.10.9.75
                            --rm             automatically removes the container when it exits          ex. --rm
                            -v  (--volume)   mount host's filesystem into the docker's one.             ex. -v "/ssl-cert.pem:/etc/nginx/certs/ssl-cert.pem"
                            -w  (--workdir)  sets the working dir in the docker  (useful for example
                                             if I have to then copy files to this dir).
                            -p  (--publish)
                            -P  (--publish-all)  port mappings between the container and host
                                                (ports defined in an image’s Dockerfile or by using option, --expose)
                                                . The option --publish, -p publishes a container’s port(s) to the host, while --publish-all , -P publishes all exposed ports.
                            -t  (--tty)      runs the container in the background of the terminal.
                            --entrypoint     specifies an executable to run when the container starts      ex. --entrypoint "/bin/ls -al /root"
                                             nb. any args to this executable must be added after
                                                 the container name                                                        container name
                                                                                                                          /
                                                                      ex.   docker run --entrypoint "/bin/ls -al /root" debian     (wrong)
                                                                      ex.   docker run --entrypoint "/bin/ls" debian -al /root     (good)

    docker exec         to run a command in an existing container
    docker start        to restart a stopped container with all its previous changes intact





------------      docker  (engine)


    docker system info
    docker system df
                                TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
                                Images              6                   4                   824.2MB             622.4MB (75%)
                                Containers          42                  8                   12.58MB             10.86MB (86%)
                                Local Volumes       6                   6                   3.226GB             0B (0%)
                                Build Cache         0                   0                   0B                  0B















docker search zookeeper
docker search mesosphere/marathon

docker pull zookeeper
docker pull mesosphere/marathon
docker pull mesosphere/mesos-slave:1.4.2    # I specify a version

docker run -d -p 2181:2181 --name zookeeper zookeeper:3.4.11                       ZOOKEEPER
docker run -it -d --name mesos-master -p 172.16.121.1:5050:5050                    MESOS_MASTER
                  --link zookeeper
                    -e MESOS_ZK=zk://zookeeper:2181/mesos
                    -e MESOS_QUORUM=1
                    -e MESOS_CLUSTER=docker-compose
                    -e MESOS_HOSTNAME=172.16.121.1
                    -e MESOS_WORK_DIR=/var/tmp/mesos
                    -e MESOS_LOG_DIR=/var/log/mesos
                    mesososphere/mesos-master:1.4.1

docker run -it -d --name mesos-slave -p 172.16.121.1:5051:5051                     MESOS_SLAVE
                  --link zookeeper:zookeeper
                  --link mesos-master:mesos-master
                    -e MESOS_MASTER=zk://zookeeper:2181/mesos
                    -e MESOS_CONTAINERIZERS=docker
                    -e MESOS_PORT=5051
                    -e MESOS_RESOURCES=ports[11000-11999]
                    -e MESOS_HOSTNAME=172.16.121.1
                    -e MESOS_WORK_DIR=/var/tmp/mesos
                    -e MESOS_LOG_DIR=/var/log/mesos
                    -e MESOS_SYSTEMD_ENABLE_SUPPORT="false" --
                    mesososphere/mesos-slave:1.4.1

docker run -it -d --name marathon -p 8080:8080                                     MESOS_MARATHON
                  --link zookeeper:zookeeper
                  --link mesos-master:mesos-master
                  --entry-point ./bin/start
                    -e MARATHON_ZK=zk://zookeeper:2181/marathon
                    -e MARATHON_MASTER=zk://zookeeper:2181/mesos
                    mesososphere/marathon:v1.5.6

