
   All started with LXC = Linux Container
        https://en.wikipedia.org/wiki/LXC
        https://github.com/lxc/lxc
        https://linuxcontainers.org/

        2008 - IBM / Google / ...

   Which can do the same docker stuff known nowadays
   with similar commands, which means
   LXC provides  isolated environments for applications
   combining the kernel's cgroups and isolated namespaces.

   LXC relies on the Linux kernel cgroups functionality that was released in version 2.6.24
   and on namespace isolation functionality, which is integrated into the mainline Linux kernel.

   It's now shipped with LXD, as container manager to provide a better user experience.


   Docker was first implemented on top of LXC, but
   it was made optional in v0.9 and support was dropped in Docker v1.10.

   Docker substituted LXC (to stay indipendent) with 'libcontainer'
   so doing the same low level kernel interactions but with full control of the interfaces
   as, before, changes in LXC proved to break the up layers of Docker.



       1/2 Namespaces        are about ISOLATION                      _________________________________________.
                             having multi indipendent operating systems inside an hypervisor                   |
                                                                                                               |
                             Linux namespaces                                .----.                            |
                                           Process ID          pid           | c  |<---- so a container        |
                                           Network             net           | o  |      has its own           |
                                           Files system/mount  mnt           | n  |      root file system      |
                                           Inter-proc comms    ipc           | t  |      network               |
                                           UTS                 uts           | a  |      users                 |
                                           User                user          | .  |      process tree          |
                                                                             '----'      ...                   |
|                                                                                                              |-------- > -------------.
|                                                                                                              |                        |
|      2/2 Control Groups    are about grouping objects and setting limits                                     |                        |
|           (cgroups)        so that different containers can share democratically                             |                        |
|                            the same resources:                                                               |                        |
|                                      tot disk each                                                           |                        |
|                                      tot CPU  each                                                           |                        |
|                                       ...                                                                    |                        |
|                             (so a "container" is an OS area where resources usage are limited)               |                        |
|                                                                     _________________________________________|                        |
|                                                                                                                                       |
|                                                                                                                                       |
|                              > docker CLI              ex. $ docker container run ....                                                |
|                                    |                                                                                                  |
|       ------------------           |                                                                                                  |
|    D  |                   .--------------------.                                                                                      |
|       |                   |       API          |       ex.  /containers/create                                                        |
|    O  |                   |                    |                                                                                      |  This is used
|       |                   '--------------------'                                                                                      |  here
|    C  |                            |                                                                                                  |  to achivate
|       |                            |_REST  POST /vX.X/containers/create HTTP/1.1                                                      |  the real
|    K  |                            |                                                                                                  |  containerisation
|       |                   .--------------------.                                                                                      |  'under the hood'
|    E  |                   |  docker daemon     |      The REST CRUD API (over gRPC / unix socket)                                     |
|       |                   |                    |          ex. it's on listening and receives the instructions                         |
|    R  |                   '--------------------'              which are routed to containerd                                          |
|       |                            |_gPRC / unix socket                                                                               |
|       |                            |                                                                                                  |
|       |                   .--------------------.                                                                                      |
|       |                   |  containerd        |     supervisor of the containers                                                     |
|    E  |                   |                    |     Manages their lifecycle:                                                         |
|       |                   '--------------------'     (start | stop | pause | .. )  (*1)                                               |
|    N  |           ___________/  |   . . .  \__________     ex. prepare the image to give to runc (which will CREATE the container)    |
|       |          /              |                     \                                                                               |
|    G  |   ______/_______________|______________________\_______________( O C I   Layer down here )______________________________      |
|       |   .----------.     .----------.            .----------.                                                 KERNEL SPACE          |
|    I  |   |  shim    |     |  shim    |  . . .     |  shim    | enable daemonless containers  (*3)              where                 |
|       |   |          |     |          |            |          |                                                 the actual            |
|    N  |   '----------'     '----------'            '----------'                                                 containers            |
|       |   .----------.     .----------.            .----------.                                                      =                |
|    E  |   |  runc    |     |  runc    |  . . .     |  runc    | runtime code (of the container)  (*2)           distinct/ isolated    |   runc: https://github.com/opencontainers/runc
|       |   |          |     |          |            |          | (interface to kernel primitives)                resources             |
|       |   '----------'     '----------'            '----------'                                                 start                 |
|       |                                                                                                                               |
|       |   .----------.     .----------.            .----------.                                                                       |
|       |   |          |     |          |  . . .     |          |   CONTAINERS (RUNNING)     <------------------------------------------'
        |   |          |     |          |            |          |
        |   '----------'     '----------'            '----------'


        NOTE. The modular diagram of the DOCKER ENGINE allows to upgrade parts indipendently.
              Eg. I can update the Docker daemon without stopping the running containers.




         (*1)  containerd is light and small. Basic functionalities to

                         start / stop / pause CONTAINERS.

               Anyhow it's extensible, which means I can use it alone (light and reusable
               for example in Kubernetes) or I can add features to manage more easily images
               management like push and pull.

                          It doesn't CREATE containers. This task is in runc.

               containerd forks 1 runc at every container CREATION.


         (*2)  runc is the implementation of Docker Inc of the 'Container runtime spec'
               which is the spec defined by OCI  (so runc is also called OCI layer)
               It CREATEs containers (like child of itself (fork), then it exits)
               When it exits the shim process becomes the parent of the container

         (*3)  As parent of the container, it can keep for example the STDIN / OUT opened even
               if the Docker daemon is upgraded. So pipes in the container are not affected.
               It also reports back to the Docker daemon the exit status of the container.

               This allows to upgrade both "docker daemon" and/or "containerd" and have then
               the still-running-containrs to resync/realign once the upgrade is done.

              $ docker version
                                Client:
                                 Cloud integration: v1.0.22
                                 Version:           20.10.13
                                 API version:       1.41
                                 Go version:        go1.16.15
                                 Git commit:        a224086
                                 Built:             Thu Mar 10 14:08:44 2022
                                 OS/Arch:           darwin/amd64
                                 Context:           default
                                 Experimental:      true

                                Server: Docker Desktop 4.6.0 (75818)
                                 Engine:
                                  Version:          20.10.13
                                  API version:      1.41 (minimum version 1.12)
                                  Go version:       go1.16.15
                                  Git commit:       906f57f
                                  Built:            Thu Mar 10 14:06:05 2022
                                  OS/Arch:          linux/amd64
                                  Experimental:     false
               -------------->   containerd:
                                  Version:          1.5.10
                                  GitCommit:        2a1d4dbdb2a1030dc5b01e96fb110a9d9f150ecc
               -------------->   runc:
                                  Version:          1.0.3
                                  GitCommit:        v1.0.3-0-gf46b6ba
                                 docker-init:
                                  Version:          0.19.0
                                  GitCommit:        de40ad0
--------------------------------------------------------------------------------
  The term [Docker] can refer to 3 different things:

             1  The "Docker Engine", the infrastructure plumbing software
                       that runs and orchestrates containers.
                       available in both:
                              - Enterprise Edition (EE)  supported 12 months
                              - Community  Edition (CE)  supported  4 months


                              Starting from Q1 2017 Docker version numbers follow the
                              YY.MM-xx versioning scheme, similar to Ubuntu and other projects.
                              Ex. 18.06.0-ce = first release of the Community Edition in June 2018


             2  Docker is part of a open-source project on GitHub (now called Moby: most written in Go)
                       The goal of the Moby project is to break Docker down into more modular components.
                       Being more and more modular, I can substitute some componenets (ex. networking)
                       with 3rd-party, even if Docker-Inc having to turn it into profit
                       makes native modules good enough to not require external plugins.

             3  Docker, Inc. is the company (based out of San Francisco) which is Docker overall maintainer
                             (and which offers commercial support)

             Note:  “The Open Container Initiative (OCI)”
                    is responsible for standardizing the most fundamental components
                    of container infrastructure such as image format and container runtime.
                    This was due as Docker was growing quick in many different directions, so the aim
                    was to keep the free development among 3rd-parties under control.

                    As of Docker 1.11, the Docker Engine architecture conforms to the OCI runtime spec.



       3 main pieces of DOCKER:

            1. engine      $ docker         --version
            2. compose     $ docker-compose --version
            3. machine     $ docker-machine --version    Docker Machine has been deprecated. Please use Docker Desktop instead


__________________________________________________________________________________________________
|     docker --version              ___
|                                      \__Docker version 18.09.2, build 6247962
|
|     docker version                ___   nb. without --      it gives more info for Client and Sever
|                                      \__
|                                           Client: Docker Engine - Community   <---------------------- the CLIENT
|                                            Version:           18.09.2
|                                            API version:       1.39
|                                            Go version:        go1.10.8
|                                            Git commit:        6247962
|                                            Built:             Sun Feb 10 04:12:39 2019
|                                            OS/Arch:           darwin/amd64
|                                            Experimental:      false
|
|                                           Server: Docker Engine - Community   <---------------------- the SERVER
|                                            Engine:
|                                             Version:          18.09.2
|                                             API version:      1.39 (minimum version 1.12)
|                                             Go version:       go1.10.6
|                                             Git commit:       6247962
|                                             Built:            Sun Feb 10 04:13:06 2019
|                                             OS/Arch:          linux/amd64
|                                             Experimental:     true
|
|     docker info                       even more verbose:   (note that it lists info on images and containers)
|                                                               Client:
|                                                                Debug Mode: false
|
|                                                               Server:
|                                                                Containers: 15             <------------
|                                                                 Running: 5                <------------
|                                                                 Paused: 0                 <------------
|                                                                 Stopped: 10               <------------
|                                                                Images: 4                  <------------
|                                                                Server Version: 19.03.5
|                                                                ....
|     docker system info       (same of docker info)
|     docker system df
|                               TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
|                               Images              6                   4                   824.2MB             622.4MB (75%)
|                               Containers          42                  8                   12.58MB             10.86MB (86%)
|                               Local Volumes       6                   6                   3.226GB             0B (0%)
|                               Build Cache         0                   0                   0B                  0B
|
|
|     docker-compose --version      ___
|                                      \__ docker-compose version 1.23.2, build 1110ad01
|
|     docker-compose version
|                                       docker-compose version 1.23.2, build 1110ad01
|                                       docker-py version: 3.6.0
|                                       CPython version: 3.6.6
|                                       OpenSSL version: OpenSSL 1.1.0h  27 Mar 2018
|
|                                 . Commands:
|                                 .   build              Build or rebuild services
|                                 .   bundle             Generate a Docker bundle from the Compose file
|                                 .   config             Validate and view the Compose file
|                                 .   create             Create services
|                                 .   down               Stop and remove containers, networks, images, and volumes
|                                 .   events             Receive real time events from containers
|                                 .   exec               Execute a command in a running container
|            docker-compose       .   help               Get help on a command
|                                 .   images             List images
|                                 .   kill               Kill containers
|                                 .   logs               View output from containers
|                                 .   pause              Pause services
|                                 .   port               Print the public port for a port binding
|                                 .   ps                 List containers
|                                 .   pull               Pull service images
|                                 .   push               Push service images
|                                 .   restart            Restart services
|                                 .   rm                 Remove stopped containers
|                                 .   run                Run a one-off command
|                                 .   scale              Set number of containers for a service
|                                 .   start              Start services
|                                 .   stop               Stop services
|                                 .   top                Display the running processes
|                                 .   unpause            Unpause services
|                                 .   up                 Create and start containers
|                                 .   version            Show the Docker-Compose version information
|
|     docker-machine --version      ___                                                        Docker Machine has been deprecated. Please use Docker Desktop instead
|                                      \__ docker-machine version 0.16.1, build cce350d7
|
|__________________________________________________________________________________________________



           Dokerfile
             |                                       .-------------.
             |                                       |             |
             '----------->  .-------------.          |  Dock. Hub  |
                 build      |             |  push -->|             |
                            |   Images    |<-- pull  |_____________|
                        .-->|             |
                        |   |_____________|--.
                 commit |                    |
                        |   .-------------.  |  run                 docker commit <container-id> username/imagename
                        '___|             |  |                               |
                            | Containers  |<-'                               ' -m 'commit message'      is also possible
                            |             |
                            |_____________|
                         (stop/ start/ restart)


                          with a container cstef I can do this:

      save / export / load:
             docker save   cstef > cstef_save.tar
             docker export cstef > cstef_export.tar

             docker load  < ....tar             1. _save.tar    will not keep mods to the file system (ex. directories/files)
                                                2. _export.tar  keeps the changes




      image  :  is an EXEC package (including all what is required (
                                          - the application to run
                                                    +
                                          - required LIBRARIES
                                          - required ENV vars
                                          - required CONFIG file
                                          )
                Said otherwise an image contains enough of an operating system (OS),
                as well as all the code and dependencies to run whatever application it’s designed for.
                An image is a stopped container. It's the build static output
                Like with a "git pull"  images are pulled down with "docker pull"
                from an image registry. The most popular registry is Docker Hub.


      container  :  it's a running instance of an image
                    (it has a proc id:   docker ps    # to see all the containers)
                    I cannot delete an image till some of its containers
                    are still running

                   A container is also defined as:                                                         __This is the "execution" (writable) Layer which a container
                   "Isolated area of an OS with resource usage limits applied"                            /       adds on top of the IMAGE
                                                                                                         /
                   NOTE: I can have + containers running from the SAME image.                   -----------------
                         They are indipendent. The image has a READONLY filesystem               .-------------.
                         so when every container writes to the filesystem it writes              |  ---------  |   IMAGE with its READONLY
                         in its own space, which will not be saved back to the image             |  ---------  |   Layers
                         when the container is closed.                                           '-------------'

                         COPY ON WRITE:   If a container must write any Image content, because the IMAGE
                                          is READONLY, it
                                                   1) copies the content into its own writable layer
                                                   2) writes/changes it.

                       | Until a container is not deleted, (ex. a STOP / RESTART) |
                       | its 'execution' Layer contains/preserves all the changes | <----- NOTE
                       | so they are not lost until a $ docker container rm       |

      diff with VM:  VM               any VM includes its own full-blown OS
                     Containers       All containers on a single host share a single OS.
                                      This would mean that a containerized app designed
                                      to Windows host will not run on a Linux host.

                                      Anyhow thanks to the effort of Microsoft and Docker
                                      (Docker for Windows)
                                      it's possible the opposite: run Linux containers in Windows

                                      Docker for Mac will not give you the Docker Engine
                                      running natively on the Mac OS Darwin kernel.
                                      Behind the scenes, the Docker daemon is running inside a
                                      lightweight Linux VM which exposes the daemon and API to the
                                      Mac environment, so I can open a terminal and
                                      use the regular Docker commands.

                                      So it’s Docker on Linux under the hood and it only works
                                      with Linux-based containers.

                                      The lightweight Linux VM is
                                         Linux: a highly tuned Linux distro called Moby that is based on Alpine Linux.
                                         VM: “  HyperKit for the lightweight hypervisor.
                                                HyperKit is based on the xhive hypervisor.

                                      $ docker version

                                            Client:
                                              .....
                                             OS/Arch:      darwin/amd64    <--- Mac

                                            Server:
                                              .....
                                             OS/Arch:      linux/amd64     <--- the Linux inside the VM

                                      Client / Server on Mac and Linux
                                      communicate between an IPC/Unix socket

                                                /var/run/docker.sock

|__________________________________________________________________________________________________

      Any filesystem change inside a container is lost when the container restarts from its clean image

      VOLUME: is an internal private space for the container to save data for future runs.
              This place is not accessibile from the host.
              So there is no easy way to retrieve if not from inside the container.

              A given volume can be mounted into multiple containers simultaneously.

           CREATE    I can let Docker create volumes during container creation
                     or I can create explictly:

                    docker volume create

                    If I don't give a name (named volumes) a volume receives a random (unique) name
                    from docker (anonymous volumes) but apart from these they behave the same.

           DELETE    Volumes are not removed automatically. I can remove unused volumes:

                    docker volume prune

      BIND MOUNT: I can expose (in read and/or write) the local host filesystem to the container.

         - docker volume

                Commands:
                  create      Create a volume
                  inspect     Display detailed information on one or more volumes
                  ls          List volumes
                  prune       Remove all unused local volumes
                  rm          Remove one or more volumes

                Run 'docker volume COMMAND --help' for more information on a command.

         - docker volume ls
                DRIVER              VOLUME NAME
                local               6debad22422316e3fceb85087722e0251f83cc97f4a8409c406e809be01a42c8
                local               16cd3aa0f1084761621a74226f2a0e3e4cbef7052226c9a69d9ba6911bd21f7e
                local               65bec217f2f6d4dcb865779ef26cffddc3438bedadc4a04f2e2aa58710d7aa08
                local               a1a73ed852451596dfd9cce7291ee8d13fcc9eb21f9bf97d57265c74ebb3ed55
                local               b92a3eb392b476b17378bd439809cea50b8c3ef173ade3d1bd2ef63dbe628e37
                local               fes-administration-scripts
                local               portainer_data


  NOTE: the file system inside a container (ex. ubuntu FS) can be different from the file system on the host (Centos)
        so they are separate things.
|__________________________________________________________________________________________________


              R E G I S T R Y   /  R E P O  :  I M A G E  (called TAG)

                     docker.io  /   redis   :  latest                      so actually 'redis' is NOT an image, it's a repo
                     docker.io  /   nginx   :  1.13.5                      the image is redis:latest
                                                                           It's clear then that a
        If omitted REGISTRY: default "docker.io"                                $ docker image pull redis -a
        If omitted IMAGE   : default "latest"                              will pull ALL the images out off  repo 'redis'
                                                                           (which actually means to pull ALL the layers)
                     ex:
                        docker image pull docker.io/redis:4.0.1

           .-------------.
           |    FAT      |  Give
           |   MANIFEST  |  Linux     .-------------.      The pull
           |             | -------->  |    IMAGE    |      retrieves
           |  (also      |            |   MANIFEST  |      The proper version
           |   MANIFEST  |            '-------------'      of the image
           |   LIST)     |                                 according to
           '-------------'                                 the docker client
                   |                                       (e.g. Linux, ...)
             {API} |
                   |
                   |
                  pull                            FAT MANIFEST: is a list of manifests (listing the available manifests for different architectures (Mac, Power PC, ...))
                                                                $ docker image pull   is retrieving, as first step, the FAT MANIFEST in order to the get
                                                                  the proper IMAGE MANIFEST, which will then contain the LIST OF LAYERS to pull down.

        1 image =  . set of
                          - OS files / libraries
                          - App specific files
                          - 1 manifest file
                     put as a stack of + layers.
                              ^^^^^^^^^^^^^^^^^
                     The manifest file is a JSON file containing  the list of layers (and their digest/hash) +
                                                                          - env vars +
                         ________ digest1     .-----.                     - exposed ports +
                         ________ digest2     | txt |                       ...
                         ________ digest3     '_____'        )
                                               digest


        - layer --> digest            Every layer has its digest/hash which specifies its autenticity

        - the manifest --> digest     The image manifest has also its digest/hash,
                                      so that the image as a whole is assured to be authentic
                                      as all the layers digests are written inside
                                      so if everything changes (layesr/vars/ports...)
                                      the manifest digest changes too.

                                      On my local filesystsem the hashes are called
                                                       CONTENT hashes
                                      anyhow when the IMAGE is pushed to a repo
                                      the IMAGE is compressed and it has new digest called
                                                       DISTRIBUTION hashes
                                      This is due, as said, because the push (and pull), as operations 'on-the wire' performs some compression
                                      so they amend the hashes accodingly to keep all consistent.


        - Storage Driver              it magages
                                          - the different layers (pulling them as separate entities and assembling the image as one)
                                          - the layers' digest cryptography.
                                          - the file systems of a container

                                      I can see it with a
                                          $ docker system info | grep -i storage

                                                 Storage Driver: overlay2


                                       There are differnt in Linux (for Windows only 1: windowsfilter)
                                           . aufs             (the original and oldest)
                                           . overlay2         (the best choice)
                                           . devicemapper
                                           . btrfs
                                           . zfs

                                       When Docker is started it looks what to use
                                       reading
                                            /etc/docker/daemon.json
                                       where there is a config block like this:
                                               {
                                                  "storage-driver": "overlay2"
                                               }
                                       till Docker is not restarted I cannot use
                                       a different STORAGE DRIVER, but all the images and containers are
                                       managed by this.
                                       They are stored in
                                            “/var/lib/docker/<storage-driver>/...”
                                       so if I change the STORAGE DRIVER I change the place
                                       where Docker looks, and I see nomore my previous images.
                                       To change the STORAGE DRIVER means doing a
                                               docker save                    # save locally
                                               docker push                    # to save remotely
                                               change STORAGE DRIVER          # vi /etc/docker/daemon.json
                                               start docker
                                               docker pull                    # retrieve locally

        - SEE THE LAYERS ON THE HOST    the layers that are listed with a
                                                   $ docker image inspect <N/D>
                                        ex:
                                        "RootFS": {
                                            "Type": "layers",
                                            "Layers": [
                                                "sha256:4ac8bc2cd0bed27b5d7bcdf724530b8f718618bb2e2b466a70a7136975378bc6",
                                                "sha256:348622fdcc617bbef1a8d7ac19b47b695109164160a507f1837289a414c3a70c",
                                                "sha256:d59769727d800c08c09f47e72906d5723958e2d7684a68ad54097ec294e80dc8",
                                                "sha256:7a7698da17f29db593cf6d1a35127e494beb644e1819ee99d0036f12f54e694d",
                                                "sha256:c5579a205adc296258840de0c2e452ee4c0be5b6c4e1143e93c48fac0de52e32",
                                                "sha256:5310afbc033c0524198da12aad90f5ee8375336f06d81ab5a725a2e933133e0b",
                                                "sha256:0356ec20fa00f7632bd43986060f53c77019e33873b644be6c2d75ffb2a0e07b"
                                            ]
                                         are not mapped 1 to 1 with the dirs I see inspecting the container with
                                                   $ docker container inspect xxxx

                                        ex:
                                       "Data": {
                                            "LowerDir": "/var/lib/docker/overlay2/1741c41e377d6029083dade934f45fea7e68ad186.........,
                                            "MergedDir": "/var/lib/docker/overlay2/1741c41e377d6029083dade934f45fea7e68ad18688d599109eb75bc9aa096fe/merged",
                                            "UpperDir": "/var/lib/docker/overlay2/1741c41e377d6029083dade934f45fea7e68ad18688d599109eb75bc9aa096fe/diff",
                                            "WorkDir": "/var/lib/docker/overlay2/1741c41e377d6029083dade934f45fea7e68ad18688d599109eb75bc9aa096fe/work"
                                        },
                                        "Name": "overlay2"
                                    },
                               Even the "hash" used as dir name are different as they are random numbers for each container.
                               Anyhow, even on the host (ie. Mac) I can see those container dirs:

                                         /var/lib/docker/overlay2/....
                               which are paths in the container's VM.

                               In the old versions of Docker it was used 'tty' (ex. at this path:
                                         ~/Library/Containers/com.docker.docker/Data/vms/0/tty
                               )
                               and it was possible to access that terminal via screen:
                                      screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty

                               New versions of docker, though, use sockets. I can look for the
                                      /debug-shell.sock
                               and connect with nc (TCP and UDP connections and listens)

                                ❯ nc -U /Users/sbasile/Library/Containers/com.docker.docker/Data//debug-shell.sock
                                / # ls /var/lib/docker/overlay2
                                ls /var/lib/docker/overlay2
                                070feb5bd2c7f4617d2177389bf4bf1e91b082927c324766863002beb02258e7
                                1285e1573330c2879705c9e20c702fdf5aa99a8bbc542a96a8cf671ebd91ba3e
                                1741c41e377d6029083dade934f45fea7e68ad18688d599109eb75bc9aa096fe
                                1741c41e377d6029083dade934f45fea7e68ad18688d599109eb75bc9aa096fe-init
                                40d6e2ceedde1f343b109e8bfa0fc55a64d9e0535bf1d2e762d38cd25a135c4d
                                4425fed44487b08408a457add5b85c5af183e380252f3137f7c8046f5cfeda86
                                5f289151387f26a977be3376eee693624e5b16bfe20ea66f18fb351c2c4543df
                                9d8c65dcb9fdb8834dc97a1b51a98c4965d63f6b0ebc194e15434e2ef4d4836a
                                ac83581ad61f9618088a096873b6fc5e6babac4d929cef2e09af6f9e8efd207f
                                cfe88b88dfc5f45452fcfab13b2a17d9cbbfb0367e3cae50290d927a1ca80984
                                l
                                / #


-----------------------------------------
DOCKER FILE:
                          . it's the list of instructions to build an image
                          . it's the meeting point between devs & ops people
                            as ops people can look at it and understand
                            it's then the DOCUMENTATION of the app
                          . it's a file named 'Dockerfile'  (1 word & Capital D)
                                                              it cannot have other names
                                                              ("dockerfile" and "Docker file")
                                                              it can only with the flag -f :
                                                                 $ docker image build -f ../example/my_docfile
                          . it's a file at the app root dir ---> $ docker image build .
                          . the list of instructions are in the form                  ^
                                 KEY value
                            where KEY are instruction keywords (like FROM)
                            and are usually CAPITALIZED

                            ex.
                                   FROM alpine

       KEYWORDS
                     FROM  alpine                      the image to start from
                     LABEL mantainer="stef"            document with metadata
                     RUN   apk add --update ...        to execute commands inside the image
                                                       and create 1 layer
                     COPY  . /src                      copy files from local host dir to image file sys
                                                       and create 1 layer
                     WORKDIR /src                      set the current dir in the image on start
                     EXPOSE  8080                      expose an image port (from the image net space)
                                                       when the container will be launched:
                                                              docker container run -d  --name anyname  -p host_port:8080  imageID
                                                                                                       -p 80:8080   ....
                                                       I will choose a host port to map onto:
                                                       which means I can reach the app from the host
                                                       as
                                                             " localhost : host_port "

                     ENTRYPOINT ["node", "./app.js"]   start the app which has been the main reason of building the container
                                                       NOTE: ./ means from current WORKDIR so = /src/app.js

                    | ENV NAME World      <----- I can also define ENV vars in the Docker file


       docker build     # short for $ docker image build
                                             ^^^^^
                     It creates an Image(/tag) from a Dockerfile whose place is given as build arg:

                     docker image build -tag image_name   place_where_Dockerfile_is      # -tag / -t :      --tag=xxxx   --tag=xxxx:v0.0.1  ...
                     docker image build -t   image_name   place_where_Dockerfile_is
                                                                      \
                                                                       \_____docker image build -t xxxx  .     (the place is the local file sys / cur dir)
                                                                             docker image build -t xxxx  https://github.com/..../repo.git  (the place is remote)

                     Some instructions add a LAYER in the Image, others only METADATA (not Layers) to the Image
                     I highlight this with an L here
                     |
                     |                                                  FROM        FROM+LABEL     FROM+LABEL+RUN   FROM+LABEL+RUN+COPY    FROM+LABEL+RUN+COPY+RUN
                     L  FROM alpine                                   .--------.   .--------.     .--------.       .--------.             .--------.
                        LABEL maintainer="nigelpoulton@hotmail.com"   '.__F___.'   '._F_L__.'     '.__R___.'       '.__C___.'             '.__R___.'
                     L  RUN apk add --update nodejs nodejs-npm                                    .--------.       .--------.             .--------.
                     L  COPY . /src                                                               '._F_L__.'       '.__R___.'             '.__C___.'
                        WORKDIR /src         <---- set a DIR inside the image                                      .--------.             .--------.
                     L  RUN npm install            (following cmds will be relative to this)                       '._F_L__.'             '.__R___.'
                        EXPOSE 8080                                                                                                       .--------.
                        ENTRYPOINT ["node", "./app.js"]                                                                                   '._F_L__.'


                        comment:           a line with #
                        syntax:            INSTRUCTION arguments     (ex   COPY . /src)      INSTRUCTIONs names are case-insensitive but usually UPPERCASED.

                                           Some INSTRUCTIONs add layers.
                                           The more the layers the slower the app ==>  group many instructions in 1
                                                                                       ex a RUN with (&&) or line breaks (\)
                                                                                       like in a normal unix shell
                                           Layers are cached (like artefacts)
                                           this means that a
                                                   $docker build
                                           will create a layer only if it's not found in the cache
                                           When a layer is not found in the cache (cache miss) since then
                                 NOTE----->THE CACHE IS NO MORE SEARCHED.
                                           So leave the possible different layers at the end of a Docker file
                                           and all the possible common layers at the top, so that they are (cache hits)

                                           to not use the cache:
                                           $docker image bulld --no-cache=true
                                           $docker image bulld --squashed      #it collapses all the layers into 1
                                                                                The image will become a single block
                                                                                so every push/pull will move ALL (negative thing)
                                                                                but it can be positive when I want to use that
                                                                                as a basic image for different projects.


       MULTI STAGE BUILD     they are when a Dockerfile has more FROM:

                                        FROM ....                     <--- stage 1 (produces an image)
                                              ..

                                        FROM ....                     <--- stage 2 (produces an image)
                                              ..

                                        FROM ....                     <--- stage 3 (produces an image)
                                              ..

                             each FROM is a 'stage' creating an image.
                             They are used when:

                                1. every previous stage builds an image
                                   with libraries of the filesystem and i.e. compiles something

                                2. every stage can reference the others to get something
                                   i.e. an artefact

                                3. the last stage retrieves what it needs from the others
                                   to generate the final desired target.
                                   The benefit is that every other stages (=images) are big
                                   while the last can be a small image containing only what needed.



                               |   FROM node:latest AS storefront              <----- 1 FROM so 1 Stage (this by default is numbered 0) (aliased as storefront)
           This returns        |   WORKDIR /usr/src/atsea/app/react-app
           2 images:           |   COPY react-app .
            - the pulled 'FROM'|   RUN npm install
            - the added changes|   RUN npm run build
              (maybe big)      |
                               |   FROM maven:latest AS appserver             <----- 1 FROM so a 2nd Stage (this by default is numbered 1) (aliased as appserver)
           This returns        |   WORKDIR /usr/src/atsea
           other 2 images:     |   COPY pom.xml .
            - the pulled 'FROM'|   RUN mvn -B -f pom.xml -s /usr/share/maven/ref/settings-docker.xml dependency\
            - the added change |   :resolve
               (maybe big)     |   COPY . .
                               |   RUN mvn -B -s /usr/share/maven/ref/settings-docker.xml package -DskipTests
                               |
           This returns        |   FROM java:8-jdk-alpine AS production       <----- 1 FROM so a 3rd Stage (by default numbered 2) (aliased as production)
           other 2 images:     |   RUN adduser -Dh /home/gordon gordon
            - the pulled 'FROM'|   WORKDIR /static
            - the added change |   COPY --from=storefront /usr/src/atsea/app/react-app/build/ .
              and something    |   WORKDIR /app
              from prev. img.  |     COPY --from=appserver /usr/src/atsea/target/AtSea-0.0.1-SNAPSHOT.jar .  <-- NOTE: I can use the previous STAGES (by their aliases) (here it's used to get/copy from)
              but not ALL      |   ENTRYPOINT ["java", "-jar", "/app/AtSea-0.0.1-SNAPSHOT.jar"]
              so this image    |   CMD ["--spring.profiles.active=postgres"]”
              can be small     |

           AFTER BULDING THE ABOVE DOCKER FILE I CAN THEN SEE THE 6 IMAGES:  $ docker images   (AND THEIR SIZE)

----------------------------------------- COMMANDS

                             NOTE ON nnnnn:   any number/id specifying an image or container can be shortened (like in git commits)
                                              as far as it's unique. Ex 607889..... might be just 60

      docker login                      to Log in this CLI session using your Docker credentials  (this will allow to push and pull to dockerhub)
                                        note the terminology:
                                             docker repository <----> git repository
                                             docker push/pull  <----> git push/pull
                                             docker image      <----> git branch     ==>  so you usually push / pull 1 IMAGE

                                             a docker image is in the form:
                                                          username / repository : tag

      docker image ls                   to see all the images
      docker images                     (<--  same)

                                        REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
                                        friendlyhello               latest              af97d893c91f        3 months ago        131MB
                                        python                      2.7-slim            0dc3d8d47241        3 months ago        120MB
                                        portainer/portainer         latest              00ead811e8ae        5 months ago        58.7MB
                                        confluentinc/cp-kafka       5.0.0               373a4e31e02e        5 months ago        558MB
                                        confluentinc/cp-zookeeper   5.0.0               3cab14034c43        5 months ago        558MB

                                        note that a 'docker build --tag=xxxxx .  ' in the cur dir . where I have a 'Dockerfile' will
                                        create the output not in the same dir: ./xxxxx but in my machine’s Docker image registry
                                        so that I can see the image xxxx with 'docker image ls'


                                      1 An Image is retrieved from a Registry (like GitHub, but for docker is: docker.io which is the DEFAULT value if omitted)
                                      2 Inside a REPOSITORY (no DEFAULT value, if not explicitly set, docker looks
                                        if it's present a var REPOSITORY in the image (the Dockerfile file used when the image was created)
                                      3 a tag is like a branch for GitHub. The image retrieved is identified by a specific tag among all
                                        (DEFAULT 'latest' ... like for git 'master')

      docker image ls --digests
                                                                                           |
                             REPOSITORY                  TAG         DIGEST                |                       IMAGE ID      CREATED        SIZE
                             test                        latest      <none>                V                       063f1b91a843  3 hours ago    71.5MB
                             alpine                      latest      sha256:72c42ed48c3a2db31b7dafe17d275b6301fb   961769676411  9 days ago     5.58MB
                             basilest/get-started        part2       sha256:4ee440ad1f9f9c56ede69b01c4fa95c7b2d2   612cc1b42bc6  6 months ago   131MB
                             friendlyhello               latest      <none>                                        612cc1b42bc6  6 months ago   131MB
                             <none>                      <none>      <none>                                        af97d893c91f  9 months ago   131MB
                             python                      2.7-slim    sha256:f82db224fbc9ff3309b7b62496e19d67f147   0dc3d8d47241  9 months ago   120MB
                             portainer/portainer         latest      sha256:07c0e19e28e18414dd02c313c36b293725cc   00ead811e8ae  11 months ago  58.7MB
                             confluentinc/cp-kafka       5.0.0       sha256:9bc4b7a7234338cae2eaf5da6b2e5636168b   373a4e31e02e  12 months ago  558MB
                             confluentinc/cp-zookeeper   5.0.0       sha256:384924ef3ac598973cf15abbface4b0543c4   3cab14034c43  12 months ago  558MB


      docker image ls  -f | --filter              Filter output based on conditions provide

      docker image ls --filter dangling=true      shows dangling images   (the ones with    REPOSITORY & TAG = <none>  <none>)
                                                  They occur when building a new image and tagging it with an existing tag.
                                                  Docker will remove the tag from the existing image, which becomes 'dangling'
                                                  (values:  --filter dangling=true   or --filter dangling=false)

                                                  Other: --filter

                                                     --filter before  nnnnn/iiiii : returns images created before the specified image (by name or ID)
                                                     --filter since   nnnnn/iiiii : ....................... after
                                                     --filter label   lllll/ll=vv : returns  images based on the presence of
                                                                                    a label or label and value.
                                                                                    The docker image ls command does not display labels in its output.
                                                     --filter=reference="*:latest"  all the ones tagged with latest


      docker image ls --format string             Pretty-print images using a Go template

      docker image ls --format "{{.Size}}"                              99.3MB
                                                                        111MB
                                                                        82.6MB
                                                                        88.8MB
                                                                        4.15MB
                                                                        108MB


      docker image ls --format "{{.Repository}}: {{.Tag}}: {{.Size}}"
                                                                        dodge:  challenger: 99.3MB
                                                                        ubuntu: latest:     111MB
                                                                        python: 3.4-alpine: 82.6MB
                                                                        python: 3.5-alpine: 88.8MB
                                                                        alpine: latest:     4.15MB
                                                                        nginx:  latest:     108MB”







      docker image prune                       removes dangling images
      docker image prune -a                    removes dangling images AND all unused images (the ones with no running containers)


      docker image rm <image id>               to Remove specified image from this machine  (it removes all the internal layers that are not shared
                                               by other images. The shared ones are kept as blob in the repo)
      docker image rm $(docker image ls -a -q) to Remove all images
      docker image rm --force                  to remove even with running containers


      docker search xxxx                                   searches in Docker Hub for every repo containing xxxx in the NAME
                                                           ex:
                                                                docker search zookeeper
                                                                docker search mesosphere/marathon
      docker search alpine --filter "is-official=true"     gives only official repos
      docker search alpine --filter "is-automated=true"    gives only repo with automated builds

      docker image build -t test:latest .      reads in the current dir the 'Dockerfile' and creates a container called 'test' and tagged 'latest'

      docker image pull alpine:latest          it pulls from Docker Hub the repo alpine image 'latest'
                                               alpine is a light Linux distro (about 4MB) perfect for containers and its quick boot time.

                                               :latest    is optional. The version-tag if missing is by default :latest
                                               so docker image pull alpine:latest    is the same as
                                                  docker image pull alpine

                                               Be carefull anyhow: latest is an arbitrary tag and is not guaranteed to point to the newest image in a repository

      docker image pull -a alpine       pulls all images
      docker image pull alpine@sha256:c0537...7c0a7726c88e2bb7584dc96     to pull specifying the digest
      docker image pull ubuntu:latest   a pull produces this output:

                                        latest: Pulling from library/ubuntu
                                        952132ac251a: Pull complete             <------ 1
                                        82659f8f1b76: Pull complete                     2    I see the num of layers
                                        c19118ca682d: Pull complete                     3    which build the image: here 5
                                        8296858250fe: Pull complete                     4
                                        24e0251a0e2c: Pull complete                     5
                                        Digest: sha256:f4691c96e6bbaa99d...28ae95a60369c506dd6e6f6ab”

                  ACTUALLY THE PULL OF 1 IMAGE IS THE PULL OF MORE LAYERS (5 in the example)
                  THE PULL IS THE -----(API)---> call to the registry which will do:
                                                                                     step1: Get the FAT manifest (with all the available list of different architectures)
                                                                                     step2: Get the IMAGE manifest of the chosen architecure
                                                                                     step3: PULL the layers


      docker push username/repository:tag        to Upload tagged image to registry

      docker image inspect ubuntu:latest         the inspect command is the proper one to see the layers:
                                                 [
                         __________________________ .{ ..________________V
                        /                                "Id": "sha256:bd3d4369ae.......fa2645f5699037d7d8c6b415a10",
                       /                                 "RepoTags": [
   docker images:     /                                      "ubuntu:latest"
   REPOSITORY TAG IMAGE ID  CREATED  SIZE
   ubuntu  latest bd3d4369ae                             <Snip>                                                                     NOTE THIS POSSIBLE NOTATION
                  ^^^^^^^^^                                                                                                         docker inspect -f "{{ .RootFS.Layers}}"  ubuntu:latest
                                                         "RootFS": {                                                                               ^^^^^^^^^^^^^^^^^^^^^^
                                                             "Type": "layers",                                                      to extract only parts of the JSON
                                                             "Layers": [
                                                                 "sha256:c8a75145fc...894129005e461a43875a094b93412",
                                                                 "sha256:c6f2b330b6...7214ed6aac305dd03f70b95cdc610",
                                                                 "sha256:055757a193...3a9565d78962c7f368d5ac5984998",
                                                                 "sha256:4837348061...12695f548406ea77feb5074e195e3",
                                                                 "sha256:0cad5e07ba...4bae4cfc66b376265e16c32a0aae9"
                                                             ]
                                                         }
                                                     }
                                                 ]

                                          S H A R I N G   L A Y E R S     Docker is able to understand if it has already 1 layer
                                                                          for an image and it doesn't pull that again

                                                                          docker image pull -a nigelpoulton/tu-demo    <----------- -a : all images

                                                                           latest: Pulling from nigelpoulton/tu-demo
                                                                           237d5fcd25cf: Pull complete       <--- download
                                                                           a3ed95caeb02: Pull complete       <--- download
                                                                           <Snip>
                                                                           Digest: sha256:42e34e546cee61adb100...a0c5b53f324a9e1c1aae451e9

                                                                           v1: Pulling from nigelpoulton/tu-demo
                                                                           237d5fcd25cf: Already exists      <----no download
                                                                           a3ed95caeb02: Already exists      <----no download
                                                                           <Snip>
                                                                           Digest: sha256:9ccc0c67e5c5eaae4beb...24c1d5c80f2c9623cbcc9b59a

                                                                           v2: Pulling from nigelpoulton/tu-demo
                                                                           237d5fcd25cf: Already exists      <----no download
                                                                           a3ed95caeb02: Already exists      <----no download
                                                                           <Snip>
                                                                           eab5aaac65de: Pull complete       <---- download


      docker image history   web:latest                   It shows the steps of the original Docker file used.
                                                            NOTE:
                                                                  1. the listed instructions are in reverse order from the last to the first
                                                                  2. the instructions creating a layer are the ones with a SIZE value > 0
                                                                     layers can also been showed with a   $docker image inspect web:latest

                                 ex:   docker image history python:2.7-slim

                                    IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
                                    0dc3d8d47241        11 months ago       /bin/sh -c #(nop)  CMD ["python2"]              0B
                                    <missing>           11 months ago       /bin/sh -c set -ex;   savedAptMark="$(apt-ma…   7.12MB    <------ not 0 ==> it's a layer
                                    <missing>           11 months ago       /bin/sh -c #(nop)  ENV PYTHON_PIP_VERSION=18…   0B
                                    <missing>           11 months ago       /bin/sh -c set -ex   && savedAptMark="$(apt-…   51.4MB    <------ not 0 ==> it's a layer
                                    <missing>           11 months ago       /bin/sh -c #(nop)  ENV PYTHON_VERSION=2.7.15    0B
                                    <missing>           11 months ago       /bin/sh -c #(nop)  ENV GPG_KEY=C01E1CAD5EA2C…   0B
                                    <missing>           11 months ago       /bin/sh -c apt-get update && apt-get install…   6.45MB    <------ not 0 ==> it's a layer
                                    <missing>           11 months ago       /bin/sh -c #(nop)  ENV PYTHONIOENCODING=UTF-8   0B
                                    <missing>           11 months ago       /bin/sh -c #(nop)  ENV LANG=C.UTF-8             0B
                                    <missing>           11 months ago       /bin/sh -c #(nop)  ENV PATH=/usr/local/bin:/…   0B
                                    <missing>           11 months ago       /bin/sh -c #(nop)  CMD ["bash"]                 0B
                                    <missing>           11 months ago       /bin/sh -c #(nop) ADD file:dab9baf938799c515…   55.3MB    <------ not 0 ==> it's a layer    (THIS IS THE BASE LAYER)



      docker ps                         to see all the containers
      docker ps -a                      "   "   "   "      "

                                        CONTAINER ID        IMAGE                             COMMAND                  CREATED             STATUS              PORTS                                NAMES
                                        7b7b15441b98        portainer/portainer               "/portainer"             2 months ago        Up 10 minutes       0.0.0.0:9000->9000/tcp               portainer
                                        f00d1e12d7ff        confluentinc/cp-kafka:5.0.0       "/etc/confluent/dock…"   3 months ago        Up 9 minutes        9092/tcp, 0.0.0.0:29093->29093/tcp   kafka
                                        b9254eb9b9c1        confluentinc/cp-zookeeper:5.0.0   "/etc/confluent/dock…"   3 months ago        Up 10 minutes       2181/tcp, 2888/tcp, 3888/tcp         zookeeper

      docker container ls               to see UP (running) containers
      docker container ls --all         to see all the containers (UP and also STOPPED/Exited)

                                        CONTAINER ID        IMAGE                             COMMAND                  CREATED             STATUS              PORTS                                NAMES
                                        7b7b15441b98        portainer/portainer               "/portainer"             2 months ago        Up 8 minutes        0.0.0.0:9000->9000/tcp               portainer
                                        f00d1e12d7ff        confluentinc/cp-kafka:5.0.0       "/etc/confluent/dock…"   3 months ago        Up 8 minutes        9092/tcp, 0.0.0.0:29093->29093/tcp   kafka
                                        b9254eb9b9c1        confluentinc/cp-zookeeper:5.0.0   "/etc/confluent/dock…"   3 months ago        Up 8 minutes        2181/tcp, 2888/tcp, 3888/tcp         zookeeper

      docker container ls -q            to see only container_id

                                        7b7b15441b98
                                        f00d1e12d7ff
                                        b9254eb9b9c1

      docker container ls -a -q
      docker container ls -q -a
      docker container ls -aq
      docker container ls -qa



      docker container stop             to stop a container giving the ID or the NAME
                                           docker container stop 7b7b15441b98
                                           docker container stop confluentinc/cp-kafka:5.0.0

      docker container start            to restart a stopped(exited) container with all its previous changes intact
      docker container exec             to run a command in a running container without entering its prompt (so still in the host shell)
                                            docker container exec -it <container-name or container-id> 'command'
                                        ex
                                            docker container exec 6078 'echo "aaaaa" > stef.txt'
                                            docker container exec 6078 cat stef.txt
      Control-PQ                        if executed inside a container shell, it goes back to the host shell keeping the container running
                                        docker container exec -it nnnnn/iiiiii   bash    to attach back (-it interactively) to the container named nnnnnn or with id iiiiii

                       CMD:  it's the default command which (in the Docker file) a container will run at start
                             ex for alpine:
                               "Cmd":[
                                   "/bin/sh"
                               ],
                             So I can start/run a container without specifying any cmd at all, becuase it will run the default from the Docker file.

                             ANY command specified on the command-line (at start/run) will override the default command
                                      ────────────────────────────────────────────────────────────────────────────────────────────
                                      ❯ dki ls
                                      REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
                                      perl         latest    80f3b1328344   9 days ago    890MB
                                      alpine       latest    76c8fb57b6fc   10 days ago   5.57MB               <---- 'alpine' is 76c8fb57b6fc
                                      ────────────────────────────────────────────────────────────────────────────────────────────
                                      ❯ dkc run -it --name alpine_1  76                                        <---- the image is unique with just 76 (or even 7)
                                      / # ps -efl
                                      PID   USER     TIME  COMMAND
                                          1 root      0:00 /bin/sh    <---- I didn't specify any cmd so this is the default launched at start
                                          8 root      0:00 ps -efl
                                      / # exit
                                      ────────────────────────────────────────────────────────────────────────────────────────────
                                      ❯ dkc run -d --name alpine_2  76 sleep 1d                                <---- I override the default with another command (sleep 1 day)
                                      1d90a33b362c3cdd85b383944cf95a8a64060616ec9f93eede2137d32b98efb6
                                      ────────────────────────────────────────────────────────────────────────────────────────────
                                      ❯ dkc ls -a
                                      CONTAINER ID   IMAGE     COMMAND      CREATED          STATUS                     PORTS     NAMES         <---- I can see my 2 containers
                                      1d90a33b362c   76        "sleep 1d"   19 seconds ago   Up 19 seconds                        alpine_2            coming from the same image
                                      f4a32234e008   76        "/bin/sh"    3 minutes ago    Exited (0) 2 minutes ago             alpine_1            and their starting commands
                                      ────────────────────────────────────────────────────────────────────────────────────────────
                                      ❯ dkc exec  1d ps -efl                                                  <----- I can see that
                                      PID   USER     TIME  COMMAND                                                   the container with sleep 1d
                                          1 root      0:00 sleep 1d                                                  is NOT tunning the default command (bin/sh)
                                          7 root      0:00 ps -efl
                                      ────────────────────────────────────────────────────────────────────────────────────────────

                       ENTRYPOINT:  passed arguments on the command line are APPENDED to this.
                             ex for alpine:
                               "Entrypoint": null,


      docker container inspect <N/ID>   it gives detailed configuration and runtime information.
                                        It accepts container names or IDs




      docker container kill <id>        to Force shutdown

      docker container rm <hash>                         # Remove specified container from this machine
      docker container rm    $(docker container ls -a -q)   # Remove all containers
      docker container rm    $(docker container ls -a | grep -i 'get-started' | awk '{print $1}')     # remove all containers with 'get-started' in the name
      docker container rm -f $(docker container ls -a | grep -i 'get-started' | awk '{print $1}')     # forced remove all containers with with 'get-started' in the name

      docker container run -d  --name web1  --publish 8080:8080  test:latest       creates (-d detached or in bg) a running instance (named 'web1') of the container 'test' tagged 'latest'
      docker container run -it --name ctr1  alpine:latest sh                       creates (-it interactively on fg) a running instance (named 'ctrl') of the container 'alpine' tagged 'latest'
                                                                                   and inside it executes 'sh'
      docker run                (same of  $docker container run)

      docker run
                            --name           assign a name to the container:                            ex.  --name my_container
                            -d  (--detach)   runs the container in the background of the terminal.      ex.  -d
                            -e  (--env)      sets an ENV var using a KEY=VALUE pair.                    ex.  -e KEY=VALUE    (I can add many -e flags in the cmd line)
                                                                                                        ex.  docker container run  -e STEF=BASI -e HIRO=FUJII  -it --name cont_alipne_1  alpine:latest  sh
                                                                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ <--- here, otherwise doesn't work
                            --env-file       if ENV vars are in file, I can pass the full path here     ex. -env-file ./env.list
                            --ip             declare an IP address.                                     ex. --ip=10.10.9.75
                            --rm             automatically removes the container when it exits          ex. --rm
                            -v  (--volume)   mount host's filesystem into the docker's one.             ex. -v "/ssl-cert.pem:/etc/nginx/certs/ssl-cert.pem"
                            -w  (--workdir)  sets the working dir in the docker  (useful for example
                                             if I have to then copy files to this dir).
                            -p  (--publish)
                            -P  (--publish-all)  port mappings between the container and host
                                                (ports defined in an image’s Dockerfile or by using option, --expose)
                                                . The option --publish, -p publishes a container’s port(s) to the host, while --publish-all , -P publishes all exposed ports.
                            -t  (--tty)      runs the container in the background of the terminal.
                            --entrypoint     specifies an executable to run when the container starts      ex. --entrypoint "/bin/ls -al /root"
                                             nb. any args to this executable must be added after
                                                 the container name                                                        container name
                                                                                                                          /
                                                                      ex.   docker run --entrypoint "/bin/ls -al /root" debian     (wrong)
                                                                      ex.   docker run --entrypoint "/bin/ls" debian -al /root     (good)
                                                                                                              ^^^^^^

                                    docker run -d -p 2181:2181 --name zookeeper zookeeper:3.4.11                       ZOOKEEPER
                                    docker run -it -d --name mesos-master -p 172.16.121.1:5050:5050                    MESOS_MASTER
                                                      --link zookeeper
                                                        -e MESOS_ZK=zk://zookeeper:2181/mesos
                                                        -e MESOS_QUORUM=1
                                                        -e MESOS_CLUSTER=docker-compose
                                                        -e MESOS_HOSTNAME=172.16.121.1
                                                        -e MESOS_WORK_DIR=/var/tmp/mesos
                                                        -e MESOS_LOG_DIR=/var/log/mesos
                                                        mesososphere/mesos-master:1.4.1

                                    docker run -it -d --name mesos-slave -p 172.16.121.1:5051:5051                     MESOS_SLAVE
                                                      --link zookeeper:zookeeper
                                                      --link mesos-master:mesos-master
                                                        -e MESOS_MASTER=zk://zookeeper:2181/mesos
                                                        -e MESOS_CONTAINERIZERS=docker
                                                        -e MESOS_PORT=5051
                                                        -e MESOS_RESOURCES=ports[11000-11999]
                                                        -e MESOS_HOSTNAME=172.16.121.1
                                                        -e MESOS_WORK_DIR=/var/tmp/mesos
                                                        -e MESOS_LOG_DIR=/var/log/mesos
                                                        -e MESOS_SYSTEMD_ENABLE_SUPPORT="false" --
                                                        mesososphere/mesos-slave:1.4.1

                                    docker run -it -d --name marathon -p 8080:8080                                     MESOS_MARATHON
                                                      --link zookeeper:zookeeper
                                                      --link mesos-master:mesos-master
                                                      --entry-point ./bin/start
                                                        -e MARATHON_ZK=zk://zookeeper:2181/marathon
                                                        -e MARATHON_MASTER=zk://zookeeper:2181/mesos
                                                        mesososphere/marathon:v1.5.6




      docker port N/I                                      gives the port exposed of the specified container

      docker tag <image> username/repository:tag           Tag <image> for upload to registry
      docker image tag <old> <new>                         to change a tag  ex.  docker image tag web:latest nigelpoulton/web:latest


      _______________________________________________ SWARM

       Since v1.12, docker releseed
                SwarmKit                         (https://github.com/docker/swarmkit)
       which allows to run docker in both the legacy
                    . Single engine mode
       and also
                    . Swarm mode

           $ docker swarm init       # I run this on 1 host (ex. My mac), I'm entering 'swarm mode' and this host will become the 1st Manager of the swarm: The Manager LEADER
                                     # The init also assigns a client certificate & a cluster store

                       ======================================= ex.1
                       $ docker system info | grep -i swarm
                             Swarm: inactive
                       $ docker swarm init
                       $ docker system info | grep -i swarm
                             Swarm: active
                       ======================================= ex.2
                       $ docker system info > swarm.2
                       $ docker node ls
                       Error response from daemon: This node is not a swarm manager. Use "docker swarm init" or "docker swarm join" to connect this node to swarm and try again.

                       $ docker swarm init
                        |Swarm initialized: current node (g1bxflvzyp4d84uk2yneyee1g) is now a manager.
                        |
                        |To add a worker to this swarm, run the following command:                                           $ doker swarm join-token manager :   to see this string again
                        |                                                                                                  /                                       /
                        |    docker swarm join --token SWMTKN-1-4yenqs0r0h5debwrpng0mftijt77vnu98dzzhtmkgvaw2vugu3-34svw4nmm31wfn9tt5hd2hfqz 192.168.65.3:2377  __/
                        |
                        |To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.
                                                                         ^^^^^^^^^^
                                                                                NB 1 word (no space) join-token       join-token manager  (dumps the string to join as a manager)
                                                                                                                      join-token worker   (dumps the string to join as a worker)

                        This is the token
                        SWMTKN-1-4yenqs0r0h5debwrpng0mftijt77vnu98dzzhtmkgvaw2vugu3-34svw4nmm31wfn9tt5hd2hfqz 192.168.65.3:2377
                           |                                  |                             |
                         fixed                             same for Managers             Managers != workers
                                                           and workers                (All Managers =
                                                       (it's the cluster id)           All workers =)


                       $ sudo openssl x509 -in /var/lib/docker/swarm/certificates/swarm-node.crt -text        <----- to see the cert

                       $ docker swarm update --cert-expiry 48h       # 48 hours (2 days) and the certificates will expiry
                       $ docker system info | grep days
                            Expiry Duration: 2 days


                       $ docker system info > swarm.2
                       $ vimdiff swarm.*
                           28  Swarm: inactive                                                   |   28  Swarm: active
                           29  Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux run|   29   NodeID: g1bxflvzyp4d84uk2yneyee1g
                              -------------------------------------------------------------------|   30   Is Manager: true
                              -------------------------------------------------------------------|   31   ClusterID: vdnqhnhk45gt8j3v4cu8l9uho
                              -------------------------------------------------------------------|   32   Managers: 1
                              -------------------------------------------------------------------|   33   Nodes: 1
                              -------------------------------------------------------------------|   34   Default Address Pool: 10.0.0.0/8
                              -------------------------------------------------------------------|   35   SubnetSize: 24
                              -------------------------------------------------------------------|   36   Data Path Port: 4789
                              -------------------------------------------------------------------|   37   Orchestration:
                              -------------------------------------------------------------------|   38    Task History Retention Limit: 5
                              -------------------------------------------------------------------|   39   Raft:
                              -------------------------------------------------------------------|   40    Snapshot Interval: 10000
                              -------------------------------------------------------------------|   41    Number of Old Snapshots to Retain: 0
                              -------------------------------------------------------------------|   42    Heartbeat Tick: 1
                              -------------------------------------------------------------------|   43    Election Tick: 10
                              -------------------------------------------------------------------|   44   Dispatcher:
                              -------------------------------------------------------------------|   45    Heartbeat Period: 5 seconds
                              -------------------------------------------------------------------|   46   CA Configuration:
                              -------------------------------------------------------------------|   47    Expiry Duration: 3 months
                              -------------------------------------------------------------------|   48    Force Rotate: 0
                              -------------------------------------------------------------------|   49   Autolock Managers: false
                              -------------------------------------------------------------------|   50   Root Rotation In Progress: false
                              -------------------------------------------------------------------|   51   Node Address: 192.168.65.3
                              -------------------------------------------------------------------|   52   Manager Addresses:
                              -------------------------------------------------------------------|   53    192.168.65.3:2377
                              -------------------------------------------------------------------|   54  Runtimes: io.containerd.runtime.v1.linux runc io.containerd.runc.v

                       $ docker node ls
                        ID                            HOSTNAME         STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
                        g1bxflvzyp4d84uk2yneyee1g *   docker-desktop   Ready     Active         Leader           20.10.13

                       =======================================


                         ----------------------------------------------------------|
                              Cluster Store                                        |
                         ----------------------------------------------------------|  3 is the minimum recommended number for Managers and also they should be odd
                            Manager           Manager           Manager            |   as an election with 2 or an even number doesn't work
                                   \            |               /                  |
                                    \           |              /                   |   SWARM = is a SECURE CLUSTER of docker nodes
                                      ------------------------                     |
                                       Mutual AUTH Encryption                      |
                                      ------------------------                     |
                                    /           |              \                   |
                                   /            |               \                  |
                                                                                   |
                            Worker            Worker            Worker             |
                                                                                   |


           $ docker swarm join --token SWMTKN-1-4yenqs0r0h5debwrpng0mftijt77vnu98dzzhtmkgvaw2vugu3-34svw4nmm31wfn9tt5hd2hfqz 192.168.65.3:2377
                               ^^^^^^^
                                 NB join <space> --token
                # we run in any other host we want to join the swarm cluster
                # the node will be a Manager with MANAGER STATUS = Reachable (not Leader):

                       $ docker node ls
                        ID                            HOSTNAME         STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
                        g1bxflvzyp4d84uk2yneyee1g *   docker-desktop   Ready     Active         Leader           20.10.13             # minimum
                       .......................................................................  Reachable ...............             # I add
                       .......................................................................  Reachable ...............             # 2 other nodes so the Managers are >= 3

           $ docker swarm join-token worker
            |To add a worker to this swarm, run the following command:
            |
            | docker swarm join --token SWMTKN-1-4yenqs0r0h5debwrpng0mftijt77vnu98dzzhtmkgvaw2vugu3-34svw4nmm31wfn9tt5hd2hfqz 192.168.65.3:2377

                       =======================================  AUTOLOCK

           $ docker swarm init --autolock   # when init a new swarm                Autolock:      - Prevents restarted Manager from automatically re-joining the swarm
           $ docker swarm update --autolock=true  # to change an existing swarm                   - Prevents accidentally restoring old copies of the swarm

             |docker swarm update --autolock=true
             |Swarm updated.
             |To unlock a swarm manager after it restarts, run the `docker swarm unlock`
             |command and provide the following key:
             |
             |    SWMKEY-1-OOu3PFx2z1xbcQFxd4OVIFEpz81TgdUCXFBJtL26yLA
             |
             |Please remember to store this key in a password manager, since without it you
             |will not be able to restart the manager.



      _______________________________________________ ORCHESTRATION


      _______________________________________________ SCALE AN APP
  |                            terminology:
  |
  |                                     TASK:  1 single container running in a service.
  |                                            Tasks are given unique IDs that numerically increment,
  |                                            up to the number of replicas you defined in docker-compose.yml
  |
  |                                     SWARM: a group of machines that are running Docker and joined into a cluster.
  |                                            The normal Docker commands are executed on a cluster by a swarm manager.
  |
  |                                     NODES: The machines in a swarm can be physical or virtual.
  |                                            After joining a swarm, they are referred to as nodes.
  |
  |                                     WORKER: Swarm managers are the only machines in a swarm that can execute your commands,
  |                                            or authorize other machines to join the swarm as workers.
  |                                            Workers are just there to provide capacity and do not have the authority
  |                                            to tell any other machine what it can or cannot do.
  |
  |   docker swarm init                               to enter 'swarm mode' (this host will become the 'manager')
  |                                                   must be executed before we can use any 'docker stack deploy'
  |   docker swarm join                               on other machines to join the swarm as workers.
  |   docker swarm leave --force                      Take down a single node swarm from the manager
  |
  |   docker stack ls                                 List stacks or apps
  |   docker stack deploy -c <composefile> <appname>  Run the specified Compose file  ex. docker stack deploy -c docker-compose.yml getstartedlab
  |   docker stack rm <appname>                       Tear down an application        ex. docker stack rm getstartedlab
  |
  |   docker service ls                               List running services associated with an app
  |   docker service ps <service>                     List tasks associated with an app
  |
  |   docker inspect <task or container>              Inspect task or container  (it returns a big json)    ex.  docker inspect e3b416239775
  |
  |   docker-machine create --driver virtualbox myvm1
  |
  |                Creating CA: /Users/sbasile/.docker/machine/certs/ca.pem
  |                Creating client certificate: /Users/sbasile/.docker/machine/certs/cert.pem
  |                Running pre-create checks...
  |                (myvm1) Image cache directory does not exist, creating it at /Users/sbasile/.docker/machine/cache...
  |                (myvm1) No default Boot2Docker ISO found locally, downloading the latest release...
  |                (myvm1) Latest release for github.com/boot2docker/boot2docker is v18.09.2
  |                (myvm1) Downloading /Users/sbasile/.docker/machine/cache/boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v18.09.2/boot2docker.iso...
  |                (myvm1) 0%....10%....20%....30%....40%....50%....60%....70%....80%....90%....100%
  |                Creating machine...
  |                (myvm1) Copying /Users/sbasile/.docker/machine/cache/boot2docker.iso to /Users/sbasile/.docker/machine/machines/myvm1/boot2docker.iso...
  |                (myvm1) Creating VirtualBox VM...
  |                (myvm1) Creating SSH key...
  |                (myvm1) Starting the VM...
  |                (myvm1) Check network to re-create if needed...
  |                (myvm1) Found a new host-only adapter: "vboxnet4"
  |                (myvm1) Waiting for an IP...
  |                Waiting for machine to be running, this may take a few minutes...
  |                Detecting operating system of created instance...
  |                Waiting for SSH to be available...
  |                Detecting the provisioner...
  |                Provisioning with boot2docker...
  |                Copying certs to the local machine directory...
  |                Copying certs to the remote machine...
  |                Setting Docker configuration on the remote daemon...
  |                Checking connection to Docker...
  |                Docker is up and running!
  |               To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env myvm1
  |
  |
  |   docker-machine ls                         to list the machines and get their IP addresses.
  |
  |                     NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORS
  |                     myvm1   -        virtualbox   Running   tcp://192.168.99.100:2376           v18.09.2
  |                     myvm2   -        virtualbox   Running   tcp://192.168.99.101:2376           v18.09.2
  |
  |
  |
  |
  |
  |
  |





      docker network create confluent
      docker network ls

      docker volume ls
      docker volume create portainer_data








------------      DNS issues
      Besides the 'ENV ...proxy' settings
      also the DNS could need to be set:

        /etc/docker/daemon.json   ---->  {
                                             "dns": ["your_dns_address", "8.8.8.8"]
                                         }

      then make docker re-source it:

      'sudo service docker restart'


------------      docker-compose.yml
               to deploy a service (i.e. a container)

              | version: "3"
              | services:
              |   web: <------------------------------------------ 0) define 'web' container
              |     # replace username/repo:tag with your name and image details
              |     image: basilest/get-started:part2  <---------- 1) the image for the service
              |     deploy:
              |       replicas: 5   <----------------------------- 2) run 5 instances of the  service
              |       resources:
              |         limits:
              |           cpus: "0.1" <--------------------------- 3) limit each one to use, at most, 10% of the CPU (across all cores), and 50MB of RAM.
              |           memory: 50M
              |       restart_policy:
              |         condition: on-failure <------------------- 4) Immediately restart containers if one fails.
              |     ports:
              |       - "4000:80"   <----------------------------- 5) Map port 4000 on the host to web’s port 80.
              |     networks:
              |       - webnet  <--------------------------------- 6) share port 80 for web-container via a load-balanced network called webnet.
              | networks:                                            (Internally, the containers themselves publish to web’s port 80 at an ephemeral port)
              |   webnet:


----------------------------------------- LOGGING


         Engine/ daemon:            Linux
                                           - systemd:     journal -u docker.service
                                           - non-systemd: /var/log/messages

         Container/App              - Use Stdout / Stderr  (so the app dumps here)
                                    - If the App writes to a file, assign that file to a volume to inspect it easily
                                    - Use the docker-driver of any industrial-standard logging facility
                                                                       ex. docker driver of Syslog
                                                                            "       "    of Gelf
                                                                            "       "    of Splunk
                                                                            "       "    of Fluentd
                                                    this external tool's docker drivers
                                                    can be used both:
                                                               A- specifying the logging driver in deamon.jon
                                                               B- ovrwriting the value of A-  with the options
                                                                 --log-driver   --log-opts
                                                                 when starting the cotnatiner.

                                                    Almost all the logging drivers allow then to inspect the logs with:
                                                            $ docker logs <container_id>



