
     D                      .--------------------.
                            |  Docker client     |      Docker CLI
     O                      |                    |          ex. docker container run ....
                            |  >                 |
     C                      '--------------------'
                                     |
     K                               |
                            .--------------------.
     E                      |  Docker daemon     |      The REST CRUD API (over gRPC)
                            |                    |          ex. it's on listening and receives the instructions
     R                      '--------------------'              which are routed to containerd
                                     |
                                     |
                            .--------------------.
                            |  containerd        |     supervisor of the containers
     E                      |                    |     Manages their lifecycle:
                            '--------------------'     (start | stop | pause | .. )  (*1)
     N              ___________/  |   . . .  \__________     ex. prepare the image to give to runc (which will CREATE the container)
                   /              |                     \
     G            /               |                      \
            .----------.     .----------.            .----------.
     I      |  shim    |     |  shim    |  . . .     |  shim    | enable daemonless containers
            |          |     |          |            |          |
     N      '----------'     '----------'            '----------'
            .----------.     .----------.            .----------.
     E      |  runc    |     |  runc    |  . . .     |  runc    | runtime code (of the container)  (*2)
            |          |     |          |            |          | (interface to kernel primitives)
            '----------'     '----------'            '----------'

            .----------.     .----------.            .----------.
            |          |     |          |  . . .     |          |   CONTAINERS (RUNNING)
            |          |     |          |            |          |
            '----------'     '----------'            '----------'


        NOTE. The modular diagram of the DOCKER ENGINE allows to upgrade parts indipendently.
              Eg. I can update the Docker daemon without stopping the running containers.




         (*1)  containerd is light and small. I has basic functionalities to start / stop / pause
               containers. Anyhow it's extensible, which means I can use it alone (light and reusable
               for example in Kubernetes) or I can add features to manage more esaily images
               management like push and pull.
               It doesn't CREATE containers. This task is in runc.
               containerd forks 1 runc at every container CREATION.


         (*2)  runc is the implementation of Docker Inc of the 'Container runtime spec'
               which is the spec defined by OCI  (so runc is also called OCI layer)
               It CREATEs containers (like child of itself, then it exits)
               When it exits the shim process becomes the parent of the container

         (*3)  As parent of the container, it can keep for example the STDIN / OUT opened even
               if the Docker daemon is upgraded. So pipes in the container are not affected.
               It also report back to the Docker daemon the exit status of the container.


--------------------------------------------------------------------------------
  The term [Docker] can refer to 3 different things:

             1  The "Docker Engine", the infrastructure plumbing software
                       that runs and orchestrates containers.
                       available in both:
                              - Enterprise Edition (EE)  supported 12 months
                              - Community  Edition (CE)  supported  4 months


                              Starting from Q1 2017 Docker version numbers follow the
                              YY.MM-xx versioning scheme, similar to Ubuntu and other projects.
                              Ex. 18.06.0-ce = first release of the Community Edition in June 2018


             2  Docker is part of a open-source project on GitHub (now called Moby: most written in Go)
                       The goal of the Moby project is to break Docker down into more modular components.
                       Being more and more modular, I can substitute some componenets (ex. networking)
                       with 3rd-party, even if Docker-Inc having to turn it into profit
                       makes native modules good enough to not require external plugins.

             3  Docker, Inc. is the company (based out of San Francisco) which is Docker overall maintainer
                             (and which offers commercial support)

             Note:  “The Open Container Initiative (OCI)”
                    is responsible for standardizing the most fundamental components
                    of container infrastructure such as image format and container runtime.
                    This was due as Docker was growing quick in many different directions, so the aim
                    was to keep the free development among 3rd-parties under control.

                    As of Docker 1.11, the Docker Engine architecture conforms to the OCI runtime spec.



       3 main pieces of DOCKER:

            1. engine      $ docker         --version
            2. compose     $ docker-compose --version
            3. machine     $ docker-machine --version


__________________________________________________________________________________________________
|     docker --version              ___
|                                      \__Docker version 18.09.2, build 6247962
|
|     docker version                ___   nb. without --      it gives more info for Client and Sever
|                                      \__
|                                           Client: Docker Engine - Community   <---------------------- the CLIENT
|                                            Version:           18.09.2
|                                            API version:       1.39
|                                            Go version:        go1.10.8
|                                            Git commit:        6247962
|                                            Built:             Sun Feb 10 04:12:39 2019
|                                            OS/Arch:           darwin/amd64
|                                            Experimental:      false
|
|                                           Server: Docker Engine - Community   <---------------------- the SERVER
|                                            Engine:
|                                             Version:          18.09.2
|                                             API version:      1.39 (minimum version 1.12)
|                                             Go version:       go1.10.6
|                                             Git commit:       6247962
|                                             Built:            Sun Feb 10 04:13:06 2019
|                                             OS/Arch:          linux/amd64
|                                             Experimental:     true
|
|     docker info                       even more verbose:   (note that it lists info on images and containers)
|                                                               Client:
|                                                                Debug Mode: false
|
|                                                               Server:
|                                                                Containers: 15             <------------
|                                                                 Running: 5                <------------
|                                                                 Paused: 0                 <------------
|                                                                 Stopped: 10               <------------
|                                                                Images: 4                  <------------
|                                                                Server Version: 19.03.5
|                                                                ....
|     docker system info       (same of docker info)
|     docker system df
|                               TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
|                               Images              6                   4                   824.2MB             622.4MB (75%)
|                               Containers          42                  8                   12.58MB             10.86MB (86%)
|                               Local Volumes       6                   6                   3.226GB             0B (0%)
|                               Build Cache         0                   0                   0B                  0B
|
|
|     docker-compose --version      ___
|                                      \__ docker-compose version 1.23.2, build 1110ad01
|
|     docker-compose version
|                                       docker-compose version 1.23.2, build 1110ad01
|                                       docker-py version: 3.6.0
|                                       CPython version: 3.6.6
|                                       OpenSSL version: OpenSSL 1.1.0h  27 Mar 2018
|
|                                 . Commands:
|                                 .   build              Build or rebuild services
|                                 .   bundle             Generate a Docker bundle from the Compose file
|                                 .   config             Validate and view the Compose file
|                                 .   create             Create services
|                                 .   down               Stop and remove containers, networks, images, and volumes
|                                 .   events             Receive real time events from containers
|                                 .   exec               Execute a command in a running container
|            docker-compose       .   help               Get help on a command
|                                 .   images             List images
|                                 .   kill               Kill containers
|                                 .   logs               View output from containers
|                                 .   pause              Pause services
|                                 .   port               Print the public port for a port binding
|                                 .   ps                 List containers
|                                 .   pull               Pull service images
|                                 .   push               Push service images
|                                 .   restart            Restart services
|                                 .   rm                 Remove stopped containers
|                                 .   run                Run a one-off command
|                                 .   scale              Set number of containers for a service
|                                 .   start              Start services
|                                 .   stop               Stop services
|                                 .   top                Display the running processes
|                                 .   unpause            Unpause services
|                                 .   up                 Create and start containers
|                                 .   version            Show the Docker-Compose version information
|
|     docker-machine --version      ___
|                                      \__ docker-machine version 0.16.1, build cce350d7
|
|__________________________________________________________________________________________________



           Dokerfile
             |                                       .-------------.
             |                                       |             |
             '----------->  .-------------.          |  Dock. Hub  |
                 build      |             |  push -->|             |
                            |   Images    |<-- pull  |_____________|
                        .-->|             |
                        |   |_____________|--.
                 commit |                    |
                        |   .-------------.  |  run                 docker commit <container-id> username/imagename
                        '___|             |  |                               |
                            | Containers  |<-'                               ' -m 'commit message'      is also possible
                            |             |
                            |_____________|
                         (stop/ start/ restart)


                          with a container cstef I can do this:

      save / export / load:
             docker save   cstef > cstef_save.tar
             docker export cstef > cstef_export.tar

             docker load  < ....tar             1. _save.tar    will not keep mods to the file system (ex. directories/files)
                                                2. _export.tar  keeps the changes




      image  :  is an EXEC package (including all what is required (
                                          - the application to run
                                                    +
                                          - required LIBRARIES
                                          - required ENV vars
                                          - required CONFIG file
                                          )
                Said otherwise an image contains enough of an operating system (OS),
                as well as all the code and dependencies to run whatever application it’s designed for.
                An image is a stopped container. It's the build static output
                Like with a "git pull"  images are pulled down with "docker pull"
                from an image registry. The most popular registry is Docker Hub.


      container  :  it's a running instance of an image
                    (it has a proc id:   docker ps    # to see all the containers)
                    I cannot delete an image till some of its containers
                    are still running

      diff with VM:  VM               any VM includes its own full-blown OS
                     Containers       All containers on a single host share a single OS.
                                      This would mean that a containerized app designed
                                      to Windows host will not run on a Linux host.

                                      Anyhow thanks to the effort of Microsoft and Docker
                                      (Docker for Windows)
                                      is possible the opposite: run Linux containers in Windows

                                      Docker for Mac will not give you the Docker Engine
                                      running natively on the Mac OS Darwin kernel.
                                      Behind the scenes, the Docker daemon is running inside a
                                      lightweight Linux VM which exposes the daemon and API to the
                                      Mac environment, so I can open a terminal and
                                      use the regular Docker commands.

                                      So it’s Docker on Linux under the hood and it only works
                                      with Linux-based containers.

                                      The lightweight Linux VM is
                                         Linux: a highly tuned Linux distro called Moby that is based on Alpine Linux.
                                         VM: “  HyperKit for the lightweight hypervisor.
                                                HyperKit is based on the xhive hypervisor.

                                      $ docker version

                                            Client:
                                              .....
                                             OS/Arch:      darwin/amd64    <--- Mac

                                            Server:
                                              .....
                                             OS/Arch:      linux/amd64     <--- the Linux inside the VM

                                      Client / Server on Mac and Linux
                                      communicate between an IPC/Unix socket

                                                /var/run/docker.sock

|__________________________________________________________________________________________________

      Any filesystem change inside a container is lost when the container restarts from its clean image

      VOLUME: is an internal private space for the container to save data for future runs.
              This place is not accessibile from the host.
              So there is no easy way to retrieve if not from inside the container.

              A given volume can be mounted into multiple containers simultaneously.

           CREATE    I can let Docker create volumes during container creation
                     or I can create explictly:

                    docker volume create

                    If I don't give a name (named volumes) a volume receives a random (unique) name
                    from docker (anonymous volumes) but apart from these they behave the same.

           DELETE    Volumes are not removed automatically. I can remove unused volumes:

                    docker volume prune

      BIND MOUNT: I can expose (both in read and/or write) the local host filesystem to the container.

         - docker volume

                Commands:
                  create      Create a volume
                  inspect     Display detailed information on one or more volumes
                  ls          List volumes
                  prune       Remove all unused local volumes
                  rm          Remove one or more volumes

                Run 'docker volume COMMAND --help' for more information on a command.

         - docker volume ls
                DRIVER              VOLUME NAME
                local               6debad22422316e3fceb85087722e0251f83cc97f4a8409c406e809be01a42c8
                local               16cd3aa0f1084761621a74226f2a0e3e4cbef7052226c9a69d9ba6911bd21f7e
                local               65bec217f2f6d4dcb865779ef26cffddc3438bedadc4a04f2e2aa58710d7aa08
                local               a1a73ed852451596dfd9cce7291ee8d13fcc9eb21f9bf97d57265c74ebb3ed55
                local               b92a3eb392b476b17378bd439809cea50b8c3ef173ade3d1bd2ef63dbe628e37
                local               fes-administration-scripts
                local               portainer_data
|__________________________________________________________________________________________________
----------------------------------------- STORAGE DRIVER

           Docker can manage the file systems of a container
           with a STORAGE DRIVER.
           There are differnt in Linux (for Windoes only 1: windowsfilter)
               . aufs             (the original and oldest)
               . overlay2         (the best choice)
               . devicemapper
               . btrfs
               . zfs

           When Docker is started it looks what to use
           reading
                /etc/docker/daemon.json
           where there is a config block like this:
                   {
                      "storage-driver": "overlay2"
                   }
           till Docker is not restarted I cannot use
           a different STORAGE DRIVER, but all the images and containers are
           managed by this.
           They are stored in
                “/var/lib/docker/<storage-driver>/...”
           so if I change the STORAGE DRIVER I change the place
           where Docker looks, and I see nomore my previous images.
           To change the STORAGE DRIVER means doing a
                   docker save                    # save locally
                   docker push                    # to save remotely
                   change STORAGE DRIVER          # vi /etc/docker/daemon.json
                   start docker
                   docker pull                    # retrieve locally

           To see the running STORAGE DRIVER just
                   docker info

                          ...
                          Storage Driver: overlay2
                          ...

|__________________________________________________________________________________________________
-----------------------------------------

      docker image ls                   to see all the images
      docker images                     (<--  same)

                                        REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
                                        friendlyhello               latest              af97d893c91f        3 months ago        131MB
                                        python                      2.7-slim            0dc3d8d47241        3 months ago        120MB
                                        portainer/portainer         latest              00ead811e8ae        5 months ago        58.7MB
                                        confluentinc/cp-kafka       5.0.0               373a4e31e02e        5 months ago        558MB
                                        confluentinc/cp-zookeeper   5.0.0               3cab14034c43        5 months ago        558MB

                                        note that a 'docker build --tag=xxxxx .  ' in the cur dir . where I have a 'Dockerfile' will
                                        create the output not in the same dir: ./xxxxx but in my machine’s Docker image registry
                                        so that I can see the image xxxx with 'docker image ls'


                                      1 An Image is retrieved from a Registry (like GitHub, but for docker is: docker.io which is the DEFAULT value if omitted)
                                      2 Inside a REPOSITORY (no DEFAULT value, if not explicitly set, docker looks
                                        if it's present a var REPOSITORY in the image (the Dockerfile file used when the image was created)
                                      3 a tag is like a branch for GitHub. The image retrieved is identified by a specific tag among all
                                        (DEFAULT 'latest' ... like for git 'master')

      docker image ls --digests
                                                                                           |
                             REPOSITORY                  TAG         DIGEST                |                       IMAGE ID      CREATED        SIZE
                             test                        latest      <none>                V                       063f1b91a843  3 hours ago    71.5MB
                             alpine                      latest      sha256:72c42ed48c3a2db31b7dafe17d275b6301fb   961769676411  9 days ago     5.58MB
                             basilest/get-started        part2       sha256:4ee440ad1f9f9c56ede69b01c4fa95c7b2d2   612cc1b42bc6  6 months ago   131MB
                             friendlyhello               latest      <none>                                        612cc1b42bc6  6 months ago   131MB
                             <none>                      <none>      <none>                                        af97d893c91f  9 months ago   131MB
                             python                      2.7-slim    sha256:f82db224fbc9ff3309b7b62496e19d67f147   0dc3d8d47241  9 months ago   120MB
                             portainer/portainer         latest      sha256:07c0e19e28e18414dd02c313c36b293725cc   00ead811e8ae  11 months ago  58.7MB
                             confluentinc/cp-kafka       5.0.0       sha256:9bc4b7a7234338cae2eaf5da6b2e5636168b   373a4e31e02e  12 months ago  558MB
                             confluentinc/cp-zookeeper   5.0.0       sha256:384924ef3ac598973cf15abbface4b0543c4   3cab14034c43  12 months ago  558MB


      docker image ls  -f | --filter              Filter output based on conditions provide

      docker image ls --filter dangling=true      shows dangling images   (the ones with    REPOSITORY & TAG = <none>  <none>)
                                                  They occur when building a new image and tagging it with an existing tag.
                                                  Docker will remove the tag from the existing image, which becomes 'dangling'
                                                  (values:  --filter dangling=true   or --filter dangling=false)

                                                  Other: --filter

                                                     --filter before  nnnnn/iiiii : returns images created before the specified image (by name or ID)
                                                     --filter since   nnnnn/iiiii : ....................... after
                                                     --filter label   lllll/ll=vv : returns  images based on the presence of
                                                                                    a label or label and value.
                                                                                    The docker image ls command does not display labels in its output.
                                                     --filter=reference="*:latest"  all the ones tagged with latest


      docker image ls --format string             Pretty-print images using a Go template

      docker image ls --format "{{.Size}}"                              99.3MB
                                                                        111MB
                                                                        82.6MB
                                                                        88.8MB
                                                                        4.15MB
                                                                        108MB


      docker image ls --format "{{.Repository}}: {{.Tag}}: {{.Size}}"
                                                                        dodge:  challenger: 99.3MB
                                                                        ubuntu: latest:     111MB
                                                                        python: 3.4-alpine: 82.6MB
                                                                        python: 3.5-alpine: 88.8MB
                                                                        alpine: latest:     4.15MB
                                                                        nginx:  latest:     108MB”







      docker image prune                       removes dangling images
      docker image prune -a                    removes dangling images AND all unused images (the ones with no running containers)


      docker image rm <image id>               to Remove specified image from this machine  (it removes all the internal layers that are not shared
                                               by other images. The shared ones are kept as blob in the repo)
      docker image rm $(docker image ls -a -q) to Remove all images
      docker image rm --force                  to remove even with running containers


      docker search xxxx                                   searches in Docker Hub for every repo containing xxxx in the NAME
                                                           ex:
                                                                docker search zookeeper
                                                                docker search mesosphere/marathon
      docker search alpine --filter "is-official=true"     gives only official repos
      docker search alpine --filter "is-automated=true"    gives only repo with automated builds

      docker image build -t test:latest .      reads in the current dir the 'Dockerfile' and creates a container called 'test' and tagged 'latest'

      docker image pull alpine:latest          it pulls from Docker Hub the repo alpine image 'latest'
                                               alpine is a light Linux distro (about 4MB) perfect for containers and its quick boot time.

                                               :latest    is optional. The version-tag if missing is by default :latest
                                               so docker image pull alpine:latest    is the same as
                                                  docker image pull alpine

                                               Be carefull anyhow: latest is an arbitrary tag and is not guaranteed to point to the newest image in a repository

      docker image pull -a alpine       pulls all images
      docker image pull alpine@sha256:c0537...7c0a7726c88e2bb7584dc96     to pull specifying the digest
      docker image pull ubuntu:latest   a pull produces this output:

                                        latest: Pulling from library/ubuntu
                                        952132ac251a: Pull complete             <------ 1
                                        82659f8f1b76: Pull complete                     2    I see the num of layers
                                        c19118ca682d: Pull complete                     3    which build the image: here 5
                                        8296858250fe: Pull complete                     4
                                        24e0251a0e2c: Pull complete                     5
                                        Digest: sha256:f4691c96e6bbaa99d...28ae95a60369c506dd6e6f6ab”
      /*----------- check this syntax
                docker pull zookeeper
                docker pull mesosphere/marathon
                docker pull mesosphere/mesos-slave:1.4.2    # I specify a version
      ----------- */


      docker image inspect ubuntu:latest         the inspect command is the proper one to see the layers:
                                                 [
                         __________________________ .{ ..________________V
                        /                                "Id": "sha256:bd3d4369ae.......fa2645f5699037d7d8c6b415a10",
                       /                                 "RepoTags": [
   docker images:     /                                      "ubuntu:latest"
   REPOSITORY TAG IMAGE ID  CREATED  SIZE
   ubuntu  latest bd3d4369ae                             <Snip>
                  ^^^^^^^^^
                                                         "RootFS": {
                                                             "Type": "layers",
                                                             "Layers": [
                                                                 "sha256:c8a75145fc...894129005e461a43875a094b93412",
                                                                 "sha256:c6f2b330b6...7214ed6aac305dd03f70b95cdc610",
                                                                 "sha256:055757a193...3a9565d78962c7f368d5ac5984998",
                                                                 "sha256:4837348061...12695f548406ea77feb5074e195e3",
                                                                 "sha256:0cad5e07ba...4bae4cfc66b376265e16c32a0aae9"
                                                             ]
                                                         }
                                                     }
                                                 ]

                                          S H A R I N G   L A Y E R S     Docker is able to understand if it has already 1 layer
                                                                          for an image and it doesn't pull that again

                                                                          docker image pull -a nigelpoulton/tu-demo    <----------- -a : all images

                                                                           latest: Pulling from nigelpoulton/tu-demo
                                                                           237d5fcd25cf: Pull complete       <--- download
                                                                           a3ed95caeb02: Pull complete       <--- download
                                                                           <Snip>
                                                                           Digest: sha256:42e34e546cee61adb100...a0c5b53f324a9e1c1aae451e9

                                                                           v1: Pulling from nigelpoulton/tu-demo
                                                                           237d5fcd25cf: Already exists      <----no download
                                                                           a3ed95caeb02: Already exists      <----no download
                                                                           <Snip>
                                                                           Digest: sha256:9ccc0c67e5c5eaae4beb...24c1d5c80f2c9623cbcc9b59a

                                                                           v2: Pulling from nigelpoulton/tu-demo
                                                                           237d5fcd25cf: Already exists      <----no download
                                                                           a3ed95caeb02: Already exists      <----no download
                                                                           <Snip>
                                                                           eab5aaac65de: Pull complete       <---- download



      docker ps                         to see all the containers
      docker ps -a                      "   "   "   "      "

                                        CONTAINER ID        IMAGE                             COMMAND                  CREATED             STATUS              PORTS                                NAMES
                                        7b7b15441b98        portainer/portainer               "/portainer"             2 months ago        Up 10 minutes       0.0.0.0:9000->9000/tcp               portainer
                                        f00d1e12d7ff        confluentinc/cp-kafka:5.0.0       "/etc/confluent/dock…"   3 months ago        Up 9 minutes        9092/tcp, 0.0.0.0:29093->29093/tcp   kafka
                                        b9254eb9b9c1        confluentinc/cp-zookeeper:5.0.0   "/etc/confluent/dock…"   3 months ago        Up 10 minutes       2181/tcp, 2888/tcp, 3888/tcp         zookeeper

      docker container ls               to see UP (running) containers
      docker container ls --all         to see all the containers (UP and also STOPPED/Exited)

                                        CONTAINER ID        IMAGE                             COMMAND                  CREATED             STATUS              PORTS                                NAMES
                                        7b7b15441b98        portainer/portainer               "/portainer"             2 months ago        Up 8 minutes        0.0.0.0:9000->9000/tcp               portainer
                                        f00d1e12d7ff        confluentinc/cp-kafka:5.0.0       "/etc/confluent/dock…"   3 months ago        Up 8 minutes        9092/tcp, 0.0.0.0:29093->29093/tcp   kafka
                                        b9254eb9b9c1        confluentinc/cp-zookeeper:5.0.0   "/etc/confluent/dock…"   3 months ago        Up 8 minutes        2181/tcp, 2888/tcp, 3888/tcp         zookeeper

      docker container ls -q            to see only container_id

                                        7b7b15441b98
                                        f00d1e12d7ff
                                        b9254eb9b9c1

      docker container ls -a -q
      docker container ls -q -a
      docker container ls -aq
      docker container ls -qa



      docker container stop             to stop a container giving the ID or the NAME
                                           docker container stop 7b7b15441b98
                                           docker container stop confluentinc/cp-kafka:5.0.0

      docker container start            to restart a stopped(exited) container with all its previous changes intact
      docker container exec             to run a command in an existing container
                                        ex
                                            “docker container exec -it <container-name or container-id> bash”
      docker container inspect <N/ID>   it gives detailed configuration and runtime information.
                                        It accepts container names or IDs




      docker container kill <id>        to Force shutdown
      Control-PQ                        to exit from the container keeping it running (....like sending in bg)
      docker container exec -it nnnnn/iiiiii   bash       to attach back (-it interactively) to the container named nnnnnn or with id iiiiii

      docker container rm <hash>                         # Remove specified container from this machine
      docker container rm    $(docker container ls -a -q)   # Remove all containers
      docker container rm    $(docker container ls -a | grep -i 'get-started' | awk '{print $1}')     # remove all containers with 'get-started' in the name
      docker container rm -f $(docker container ls -a | grep -i 'get-started' | awk '{print $1}')     # forced remove all containers with with 'get-started' in the name

      docker container run -d  --name web1  --publish 8080:8080  test:latest       creates (-d detached or in bg) a running instance (named 'web1') of the container 'test' tagged 'latest'
      docker container run -it --name ctr1  alpine:latest sh                       creates (-it interactively on fg) a running instance (named 'ctrl') of the container 'alpine' tagged 'latest'
                                                                                   and inside it executes 'sh'



      docker login                      to Log in this CLI session using your Docker credentials  (this will allow to push and pull to dockerhub)
                                        note the terminology:
                                             docker repository <----> git repository
                                             docker push/pull  <----> git push/pull
                                             docker image      <----> git branch     ==>  so you usually push / pull 1 IMAGE

                                             a docker image is in the form:
                                                          username / repository : tag

      docker tag <image> username/repository:tag           Tag <image> for upload to registry
      docker push username/repository:tag                  to Upload tagged image to registry
      docker run  username/repository:tag                  to Run image from a repository
      docker image tag <old> <new>                         to change a tag  ex.  docker image tag web:latest nigelpoulton/web:latest

      docker run
                            --name           assign a name to the container:                            ex.  --name my_container
                            -d  (--detach)   runs the container in the background of the terminal.      ex.  -d
                            -e  (--env)      sets an ENV var using a KEY=VALUE pair.                    ex.  -e KEY=VALUE    (I can add many -e flags in the cmd line)
                            --env-file       if ENV vars are in file, I can pass the full path here     ex. -env-file ./env.list
                            --ip             declare an IP address.                                     ex. --ip=10.10.9.75
                            --rm             automatically removes the container when it exits          ex. --rm
                            -v  (--volume)   mount host's filesystem into the docker's one.             ex. -v "/ssl-cert.pem:/etc/nginx/certs/ssl-cert.pem"
                            -w  (--workdir)  sets the working dir in the docker  (useful for example
                                             if I have to then copy files to this dir).
                            -p  (--publish)
                            -P  (--publish-all)  port mappings between the container and host
                                                (ports defined in an image’s Dockerfile or by using option, --expose)
                                                . The option --publish, -p publishes a container’s port(s) to the host, while --publish-all , -P publishes all exposed ports.
                            -t  (--tty)      runs the container in the background of the terminal.
                            --entrypoint     specifies an executable to run when the container starts      ex. --entrypoint "/bin/ls -al /root"
                                             nb. any args to this executable must be added after
                                                 the container name                                                        container name
                                                                                                                          /
                                                                      ex.   docker run --entrypoint "/bin/ls -al /root" debian     (wrong)
                                                                      ex.   docker run --entrypoint "/bin/ls" debian -al /root     (good)

                                    docker run -d -p 2181:2181 --name zookeeper zookeeper:3.4.11                       ZOOKEEPER
                                    docker run -it -d --name mesos-master -p 172.16.121.1:5050:5050                    MESOS_MASTER
                                                      --link zookeeper
                                                        -e MESOS_ZK=zk://zookeeper:2181/mesos
                                                        -e MESOS_QUORUM=1
                                                        -e MESOS_CLUSTER=docker-compose
                                                        -e MESOS_HOSTNAME=172.16.121.1
                                                        -e MESOS_WORK_DIR=/var/tmp/mesos
                                                        -e MESOS_LOG_DIR=/var/log/mesos
                                                        mesososphere/mesos-master:1.4.1

                                    docker run -it -d --name mesos-slave -p 172.16.121.1:5051:5051                     MESOS_SLAVE
                                                      --link zookeeper:zookeeper
                                                      --link mesos-master:mesos-master
                                                        -e MESOS_MASTER=zk://zookeeper:2181/mesos
                                                        -e MESOS_CONTAINERIZERS=docker
                                                        -e MESOS_PORT=5051
                                                        -e MESOS_RESOURCES=ports[11000-11999]
                                                        -e MESOS_HOSTNAME=172.16.121.1
                                                        -e MESOS_WORK_DIR=/var/tmp/mesos
                                                        -e MESOS_LOG_DIR=/var/log/mesos
                                                        -e MESOS_SYSTEMD_ENABLE_SUPPORT="false" --
                                                        mesososphere/mesos-slave:1.4.1

                                    docker run -it -d --name marathon -p 8080:8080                                     MESOS_MARATHON
                                                      --link zookeeper:zookeeper
                                                      --link mesos-master:mesos-master
                                                      --entry-point ./bin/start
                                                        -e MARATHON_ZK=zk://zookeeper:2181/marathon
                                                        -e MARATHON_MASTER=zk://zookeeper:2181/mesos
                                                        mesososphere/marathon:v1.5.6




      _______________________________________________ SCALE AN APP
  |                            terminology:
  |
  |                                     TASK:  1 single container running in a service.
  |                                            Tasks are given unique IDs that numerically increment,
  |                                            up to the number of replicas you defined in docker-compose.yml
  |
  |                                     SWARM: a group of machines that are running Docker and joined into a cluster.
  |                                            The normal Docker commands are executed on a cluster by a swarm manager.
  |
  |                                     NODES: The machines in a swarm can be physical or virtual.
  |                                            After joining a swarm, they are referred to as nodes.
  |
  |                                     WORKER: Swarm managers are the only machines in a swarm that can execute your commands,
  |                                            or authorize other machines to join the swarm as workers.
  |                                            Workers are just there to provide capacity and do not have the authority
  |                                            to tell any other machine what it can or cannot do.
  |
  |   docker swarm init                               to enter 'swarm mode' (this host will become the 'manager')
  |                                                   must be executed before we can use any 'docker stack deploy'
  |   docker swarm join                               on other machines to join the swarm as workers.
  |   docker swarm leave --force                      Take down a single node swarm from the manager
  |
  |   docker stack ls                                 List stacks or apps
  |   docker stack deploy -c <composefile> <appname>  Run the specified Compose file  ex. docker stack deploy -c docker-compose.yml getstartedlab
  |   docker stack rm <appname>                       Tear down an application        ex. docker stack rm getstartedlab
  |
  |   docker service ls                               List running services associated with an app
  |   docker service ps <service>                     List tasks associated with an app
  |
  |   docker inspect <task or container>              Inspect task or container  (it returns a big json)    ex.  docker inspect e3b416239775
  |
  |   docker-machine create --driver virtualbox myvm1
  |
  |                Creating CA: /Users/sbasile/.docker/machine/certs/ca.pem
  |                Creating client certificate: /Users/sbasile/.docker/machine/certs/cert.pem
  |                Running pre-create checks...
  |                (myvm1) Image cache directory does not exist, creating it at /Users/sbasile/.docker/machine/cache...
  |                (myvm1) No default Boot2Docker ISO found locally, downloading the latest release...
  |                (myvm1) Latest release for github.com/boot2docker/boot2docker is v18.09.2
  |                (myvm1) Downloading /Users/sbasile/.docker/machine/cache/boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v18.09.2/boot2docker.iso...
  |                (myvm1) 0%....10%....20%....30%....40%....50%....60%....70%....80%....90%....100%
  |                Creating machine...
  |                (myvm1) Copying /Users/sbasile/.docker/machine/cache/boot2docker.iso to /Users/sbasile/.docker/machine/machines/myvm1/boot2docker.iso...
  |                (myvm1) Creating VirtualBox VM...
  |                (myvm1) Creating SSH key...
  |                (myvm1) Starting the VM...
  |                (myvm1) Check network to re-create if needed...
  |                (myvm1) Found a new host-only adapter: "vboxnet4"
  |                (myvm1) Waiting for an IP...
  |                Waiting for machine to be running, this may take a few minutes...
  |                Detecting operating system of created instance...
  |                Waiting for SSH to be available...
  |                Detecting the provisioner...
  |                Provisioning with boot2docker...
  |                Copying certs to the local machine directory...
  |                Copying certs to the remote machine...
  |                Setting Docker configuration on the remote daemon...
  |                Checking connection to Docker...
  |                Docker is up and running!
  |               To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env myvm1
  |
  |
  |   docker-machine ls                         to list the machines and get their IP addresses.
  |
  |                     NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORS
  |                     myvm1   -        virtualbox   Running   tcp://192.168.99.100:2376           v18.09.2
  |                     myvm2   -        virtualbox   Running   tcp://192.168.99.101:2376           v18.09.2
  |
  |
  |
  |
  |
  |
  |





      docker network create confluent
      docker network ls

      docker volume ls
      docker volume create portainer_data


------------      Dockerfile

                  it cannot have other names
                  ("dockerfile" and "Docker file")
                  it can only with the flag -f :
                       docker build -f ../example/my_docfile


      . it's like a Makefile. It's used to builld an image (which I can then see with 'docker image ls')

         Some instructions add a LAYER in the Image, others only METADATA (not Layers) to the Image
         I highlight this with an L here
         |
         |                                                  FROM        FROM+LABEL     FROM+LABEL+RUN   FROM+LABEL+RUN+COPY    FROM+LABEL+RUN+COPY+RUN
         L  FROM alpine                                   .--------.   .--------.     .--------.       .--------.             .--------.
            LABEL maintainer="nigelpoulton@hotmail.com"   '.__F___.'   '._F_L__.'     '.__R___.'       '.__C___.'             '.__R___.'
         L  RUN apk add --update nodejs nodejs-npm                                    .--------.       .--------.             .--------.
         L  COPY . /src                                                               '._F_L__.'       '.__R___.'             '.__C___.'
            WORKDIR /src         <---- set a DIR inside the image                                      .--------.             .--------.
         L  RUN npm install            (following cmds will be relative to this)                       '._F_L__.'             '.__R___.'
            EXPOSE 8080          <---- the internal image port.                                                               .--------.
            ENTRYPOINT ["node", "./app.js"]   <----  sets the main application that the image should run                      '._F_L__.'


            Note:  8080  is the internal image port.
                   It is mapped during the docker run command
                       docker run -p 80:8080   ....
                   which maps the host-docker-local 80 port onto the image 8080
                   If 80 is taken I can us any other available port


            comments:          a line with #
            syntax:            INSTRUCTION arguments     (ex   COPY . /src)      INSTRUCTIONs names are case-insensitive but usually UPPERCASED.

                               Some INSTRUCTIONs add layers.
                               The more the layers the slower the app ==>  group many instructions in 1
                                                                           ex a RUN with (&&) or line breaks (\)
                                                                           like in a normal unix shell
                               Layers are cached (like artefacts)
                               this means that a
                                       $docker build
                               will create a layer only if it's not found in the cache
                               When a layer is not found in the cache (cache miss) since then
                     NOTE----->THE CACHE IS NO MORE SEARCHED.
                               So leave the possible different layers at the end of a Docker file
                               and all the possible common layers at the top, so that they are (cache hits)

                               to not use the cache:
                               $docker image bulld --no-cache=true
                               $docker image bulld --squashed      #it collapses all the layers into 1
                                                                    The image will become a single block
                                                                    so every push/pull will move ALL (negative thing)
                                                                    but it can be positive when I want to use that
                                                                    as a basic image for different projects.



                               MULTI_STAGE:

                             |   FROM node:latest AS storefront              <----- 1 FROM so 1 Stage (this by default is numbered 0) (aliased as storefront)
                             |   WORKDIR /usr/src/atsea/app/react-app
                             |   COPY react-app .
                             |   RUN npm install
                             |   RUN npm run build
                             |
                             |   FROM maven:latest AS appserver             <----- 1 FROM so a 2nd Stage (this by default is numbered 1) (aliased as appserver)
                             |   WORKDIR /usr/src/atsea
                             |   COPY pom.xml .
                             |   RUN mvn -B -f pom.xml -s /usr/share/maven/ref/settings-docker.xml dependency\
                             |   :resolve
                             |   COPY . .
                             |   RUN mvn -B -s /usr/share/maven/ref/settings-docker.xml package -DskipTests
                             |
                             |   FROM java:8-jdk-alpine AS production       <----- 1 FROM so a 3rd Stage (by default numbered 2) (aliased as production)
                             |   RUN adduser -Dh /home/gordon gordon
                             |   WORKDIR /static
                             |   COPY --from=storefront /usr/src/atsea/app/react-app/build/ .
                             |   WORKDIR /app
                             |   COPY --from=appserver /usr/src/atsea/target/AtSea-0.0.1-SNAPSHOT.jar .  <-- NOTE: I can use the previous STAGES (by their aliases) (here it's used to get/copy from)
                             |   ENTRYPOINT ["java", "-jar", "/app/AtSea-0.0.1-SNAPSHOT.jar"]
                             |   CMD ["--spring.profiles.active=postgres"]”
                             |
                             |   Excerpt From: Nigel Poulton. “Docker Deep Dive”. Apple Books.






      . docker image build  -t web:latest .                 it creates the image (put in my local (ex Mac) registry place
                                                            reading the Docker file in the cur dir '.'





      . docker image history   web:latest                   It shows the steps of the original Docker file used.
                                                            NOTE:
                                                                  1. the listed instructions are in reverse order from the last to the first
                                                                  2. the instructions creating a layer are the ones with a SIZE value > 0
                                                                     layers can also been showed with a   $docker image inspect web:latest

                                 ex:   docker image history python:2.7-slim

                                    IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
                                    0dc3d8d47241        11 months ago       /bin/sh -c #(nop)  CMD ["python2"]              0B
                                    <missing>           11 months ago       /bin/sh -c set -ex;   savedAptMark="$(apt-ma…   7.12MB
                                    <missing>           11 months ago       /bin/sh -c #(nop)  ENV PYTHON_PIP_VERSION=18…   0B
                                    <missing>           11 months ago       /bin/sh -c set -ex   && savedAptMark="$(apt-…   51.4MB
                                    <missing>           11 months ago       /bin/sh -c #(nop)  ENV PYTHON_VERSION=2.7.15    0B
                                    <missing>           11 months ago       /bin/sh -c #(nop)  ENV GPG_KEY=C01E1CAD5EA2C…   0B
                                    <missing>           11 months ago       /bin/sh -c apt-get update && apt-get install…   6.45MB
                                    <missing>           11 months ago       /bin/sh -c #(nop)  ENV PYTHONIOENCODING=UTF-8   0B
                                    <missing>           11 months ago       /bin/sh -c #(nop)  ENV LANG=C.UTF-8             0B
                                    <missing>           11 months ago       /bin/sh -c #(nop)  ENV PATH=/usr/local/bin:/…   0B
                                    <missing>           11 months ago       /bin/sh -c #(nop)  CMD ["bash"]                 0B
                                    <missing>           11 months ago       /bin/sh -c #(nop) ADD file:dab9baf938799c515…   55.3MB





      . docker build --tag=xxxx .              <--- it will give the default value 'latest' to the TAG column in 'docker image ls'
      . docker build --tag=xxxx:v0.0.1 .       <--- it gives a value for the TAG column

      . ex of  Dockerfile
                    | # Use an official Python runtime as a parent image
                    | FROM python:2.7-slim
                    |
                    | # Set the working directory to /app
                    | WORKDIR /app
                    |
                    | # Copy the current directory contents into the container at /app
                    | COPY . /app
                    |
                    | # Install any needed packages specified in requirements.txt
                    | RUN pip install --trusted-host pypi.python.org -r requirements.txt <-------- ./requirements.txt :   | Flask
                    |                                                                               this 2 lines file ->  | Redis
                    | # Make port 80 available to the world outside this container
                    | EXPOSE 80                            <------   I will be able to run my app (tagged as xxxx) with:   'docker run -p 4000:80 xxxx'
                    |
                    | # Define environment variable
                    | ENV NAME World
                    |
                    | # Run app.py when the container launches
                    | CMD ["python", "app.py"]    <----------  ./app.py: file where I wrote some Python code

      . note Docker-syntax commands like:

                     COPY
                     EXPOSE
                     ENV            (ENV is also used to manage proxy settings
                                     so that my app will be able to access the network:

                                          |    ENV http_proxy  host:port
                                          |    ENV https_proxy host:port
------------      DNS issues
      Besides the 'ENV ...proxy' settings
      also the DNS could need to be set:

        /etc/docker/daemon.json   ---->  {
                                             "dns": ["your_dns_address", "8.8.8.8"]
                                         }

      then make docker re-source it:

      'sudo service docker restart'


------------      run
      docker run -p 4000:80 xxxx                   to run an image (tagged as xxxx) mapping localhost port 4000 to the port 80 inside the docker image
                                                   (which was 'exposed' in the 'Dockerfile' )

      docker run -d -p 4000:80 xxxx                -d to 'detach' and run in background giving back the prompt.




------------      docker-compose.yml
               to deploy a service (i.e. a container)

              | version: "3"
              | services:
              |   web: <------------------------------------------ 0) define 'web' container
              |     # replace username/repo:tag with your name and image details
              |     image: basilest/get-started:part2  <---------- 1) the image for the service
              |     deploy:
              |       replicas: 5   <----------------------------- 2) run 5 instances of the  service
              |       resources:
              |         limits:
              |           cpus: "0.1" <--------------------------- 3) limit each one to use, at most, 10% of the CPU (across all cores), and 50MB of RAM.
              |           memory: 50M
              |       restart_policy:
              |         condition: on-failure <------------------- 4) Immediately restart containers if one fails.
              |     ports:
              |       - "4000:80"   <----------------------------- 5) Map port 4000 on the host to web’s port 80.
              |     networks:
              |       - webnet  <--------------------------------- 6) share port 80 for web-container via a load-balanced network called webnet.
              | networks:                                            (Internally, the containers themselves publish to web’s port 80 at an ephemeral port)
              |   webnet:



------------ PORTAINER    (https://portainer.readthedocs.io/en/stable/deployment.html)

    docker volume create portainer_data
    docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer



                  PERSISTENT DATA

                  By default, Portainer stores in "/data" the container's data.
                  to keep your changes after restart/upgrade of the Portainer container
                  I can use a bind mount on the Docker host folder:


    docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v /path/on/host/data:/data portainer/portainer
                                                                                                                 ^^^^^^^^^^^^^^^^^^







     Install and start Zookeeper

                                   docker run -d \
                                       --net=confluent \
                                       --name=zookeeper \
                                       --restart=always \
                                       -e ZOOKEEPER_CLIENT_PORT=32181 \
                                       confluentinc/cp-zookeeper:5.0.0

     Install and start Kafka

                                   docker run -d \
                                       --net=confluent \
                                       --name=kafka \
                                       --restart=always \                                                      This is the local host (i.e. Mac) IP
                                       -p 29093:29093 \                                                       /
                                       -e KAFKA_ZOOKEEPER_CONNECT=zookeeper:32181 \                          /
                                       -e KAFKA_ADVERTISED_LISTENERS=INSIDE://localhost:29092,OUTSIDE://172.19.68.36:29093 \
                                       -e KAFKA_LISTENER_SECURITY_PROTOCOL_MAP=INSIDE:PLAINTEXT,OUTSIDE:PLAINTEXT \
                                       -e KAFKA_INTER_BROKER_LISTENER_NAME=INSIDE \
                                       -e KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1 \
                                       confluentinc/cp-kafka:5.0.0



     Listing your Kafka Topics

                                   docker run \
                                       --net=confluent \
                                       --rm confluentinc/cp-kafka:5.0.0 \
                                       kafka-topics --list --zookeeper zookeeper:32181

    Running Kafka Console Consumer

                                   docker exec -it kafka /usr/bin/kafka-console-consumer --bootstrap-server localhost:29092 --topic PA_STREAMING_2 --from-beginning # Ctrl C to exit



    option -v     : to mount a volume (dir or file) so that it's visible in the docker from the host filesystem.

                docker run -d --name nginx -p 443:443 \
                           -v "/nginx.ssl.conf:/etc/nginx/conf.d/default.conf" \
                           -v "/ssl-cert.pem:/etc/nginx/certs/ssl-cert.pem" \
                           -v "/ssl-cert.key:/etc/nginx/certs/ssl-cert.key" \
                           nginx



    option -w     : to use ENV variables;


                The `docker run` command has -e and --env-file options to provide environments variables for processes inside the container


    Dockerfile:



                docker run -d --name nginx -p 443:443 \
                   -v "/ssl-cert.pem:/etc/nginx/certs/ssl-cert.pem" \
                   -v "/ssl-cert.key:/etc/nginx/certs/ssl-cert.key"\
                   -e "NGINX_ENABLE_SSL=True" \      <------------   we want to have a config var to control how the docker is config.
                   our-nginx



                Dockerfile:

                FROM nginx
                    RUN apt-get update && \
                        apt-get install python-dev python-setuptools
                    RUN easy_install j2cli

                    COPY nginx.conf.j2 /templates/
                    COPY docker-entrypoint.sh /         <-----------------------   #!/bin/bash -e
                    ENTRYPOINT ["/docker-entrypoint.sh"]                           j2 /templates/nginx.conf.j2 > /etc/nginx/conf.d/default.conf
                    CMD ["nginx", "-g", "daemon off;"]                             exec "$@"





                J2 Template

                server {
                        server_name _;
                        {% if NGINX_ENABLE_SSL|default('False') == 'True' %}
                        listen 443;
                        ssl on;

                        ssl_certificate /etc/ssl/certs/ssl-cert.pem;
                        ssl_certificate_key /etc/ssl/private/ssl-cert.key;
                        {% else %}
                        listen 80;
                        {% endif %}

                        location / {
                            proxy_pass http://localhost:8080;
                        }
                    }

